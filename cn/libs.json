{"cases":{"index":[0,{"t":"h1","c":"快速开始"},{"t":"p","c":"要开始使用，只需通过引入 CDN 地址将项目 ofajs 集成到你的项目中："},0,{"t":"p","c":"这是一个简单的示例，演示了如何使用 ofa.js 修改 DOM 元素的内容："},{"t":"h2","c":"使用方法"},{"t":"p","c":"引入了 ofa.js 后，全局作用域中将注册 $ 符号。通过 $('xxx') 来选择符合条件的第一个元素，其中 xxx 是标准的 CSS 选择器 内容。"},{"t":"p","c":"在上述示例中，我们使用了 $ 符号来选择三个具有不同 id 的元素，并通过设置 text 、 html 和 value 属性来修改其内容。"},{"t":"p","c":"要了解更多可用的属性和方法，请查阅 API 文档。"}],"event":[0,{"t":"h1","c":"事件响应"},{"t":"p","c":"您可以使用 on 方法来绑定事件。事件 是开发中最基础的概念，应用通过事件的触发才能产生反馈，从而实现互动性。"},{"t":"p","c":"以下示例演示了如何绑定点击事件："},{"t":"p","c":"在这个示例中，我们通过使用 $ 选择了 button 元素，并使用 on 方法绑定了 click 事件。当按钮被点击时，会触发回调函数，将 target 元素的文本内容更改为 \"你好，世界！\"。"},{"t":"p","c":"如果您想了解更多可用的事件类型，请参考 Events 文档。"}],"simple-component":[0,{"t":"h1","c":"组件的创建和使用"},{"t":"p","c":"一旦完成对 ofa.js 的加载，全局会注册一个名为 load-module 的组件，你可以使用缩写 l-m 来引用它。其使用方式类似于 script 标签，通过 src 属性来引用你开发好的组件地址。"},{"t":"p","c":"现在，让我们开始制作自己的组件。首先，创建一个 HTML 文件，文件名需要与组件名保持一致。"},{"t":"p","c":"在组件文件中，首先添加一个 template 元素，并添加 component属性。将组件需要渲染的内容放置在这个 template 元素内。最终，这些内容将被渲染到组件的 Shadow DOM 内，Shadow DOM 与外部环境隔离，以防止污染外部环境。"},{"t":"p","c":"接下来，只需使用 l-m 组件来引用你开发好的组件。在页面上，直接使用你定义的组件标签即可。"},{"t":"p","c":"需要注意的是，注册的组件名只能使用小写英文字母和 - 符号，并且必须包含至少一个 -。这个命名规则需要遵循。"},{"t":"p","c":"通过本示例，你可以了解如何创建一个名为 my-comp 的组件，并在另一个页面中使用它。同时可以通过链接外部的 CSS 文件来设置组件的样式。"}],"slot":[0,{"t":"h1","c":"组件插槽"},{"t":"p","c":"通过在模板中添加 <slot></slot> 标签，可以在使用组件时，将内容放置在对应组件标签内的插槽中。"},{"t":"p","c":"自定义的组件在默认情况下没有定义 display 属性，因此需要手动为组件定义。在组件的样式中，可以使用 :host 选择器来添加组件自身的样式。"},{"t":"p","c":"这个示例展示了如何创建一个名为 simple-btn 的组件。组件的模板中包含一个插槽，可以将内容插入到组件中。通过为组件的样式添加 :host 选择器，为组件添加样式。在另一个页面中，使用 l-m 组件引用 simple-btn 组件，并在其中插入内容。"}],"render-text":[0,{"t":"h1","c":"文本渲染"},{"t":"p","c":"在组件文件中，你可以添加一个 script 标签来编写组件的逻辑代码。通过暴露的 default 对象，可以设置组件参数。"},{"t":"p","c":"其中，data 参数用于定义组件元素的默认数据。一旦实例化完成，你就可以使用模板语法。"},{"t":"p","c":"文本渲染采用双大括号进行包裹，即 {{xxx}}，其中的 xxx 表示组件的属性名；"},{"t":"p","c":"案例演示了如何渲染组件元素的 val 属性："}],"attribute-transmission":[0,{"t":"h1","c":"特性传递"},{"t":"p","c":"attrs 参数和 data 参数在功能上类似，设置在 attrs 中的数据会合并到 data 中，但是 attrs 上的数据会体现在组件自身的特性上。"},0,{"t":"p","c":"在外部使用组件时，也可以通过特性将数据传递到组件内部。需要注意的是，通过特性传递的数据只能是字符串类型。"}],"get-set-comp":[0,{"t":"h1","c":"获取和修改组件实例的值"},{"t":"p","c":"从外部也可以获取或修改组件的数据。"},{"t":"p","c":"示例展示了如何在外部操作组件的数据；"}],"property-transmission":[0,{"t":"h1","c":"属性传递"},{"t":"p","c":"通过使用属性传递的模板语法，您可以将组件的数据应用于模板内的元素属性。"},{"t":"p","c":"使用方法是在元素上添加特性 :name=\"key\"，其中 name 为目标元素要设置的属性名，key 则为您自定义组件中要传递的属性键名。"},{"t":"p","c":"之前在提到了使用选择器的方式来设置属性，而这里介绍的是属性传递语法设置属性；"}],"nested-component":[0,{"t":"h1","c":"嵌套组件"},{"t":"p","c":"全部过多的逻辑放到一个组件上，不是一个明智的选择；我们可以将逻辑分到另外的组件，在通过 l-m 方式导入另一个组件来使用；"},{"t":"p","c":"案例中通过 <l-m src=\"./comp-two.html\"></l-m> 引入了名为 CompTwo 的嵌套组件。"},{"t":"p","c":"通过 <comp-two :txt=\"val\"></comp-two> 使用了嵌套组件，并将当前组件的 val 属性作为 txt 属性传递给嵌套组件。这样，嵌套组件可以使用传递过来的数据进行渲染。"},{"t":"p","c":"在 <comp-two></comp-two> 中，我们在不传递任何属性的情况下使用了嵌套组件。这里的使用方式取决于嵌套组件本身的逻辑和设计。"},{"t":"p","c":"只要一个组件加载成功，无论在何处，都可以使用相应名称的组件。即使在多个地方多次使用 l-m 组件加载相同的组件，也不会导致组件被多次加载。这种机制保证了组件的重用和一致性。"}],"bind-event":[0,{"t":"h1","c":"事件绑定"},{"t":"p","c":"在组件内部，您可以通过 on 属性来绑定事件，让组件具备交互能力。这里演示了如何在组件中绑定事件以实现交互效果。"},{"t":"p","c":"proto 参数用于定义组件自身的方法，这些方法可以在组件内部使用，也可以在外部通过选择器获取组件后运行。"},{"t":"p","c":"on:click=\"xxx\" 后面可以是组件内部定义的方法名，也可以是函数表达式。如果使用函数表达式，无需显式写出 this 关键字，变量的作用域会自动绑定到组件自身；"},{"t":"p","c":"如果您想了解更多可用的事件类型，请参考 Events 文档。"}],"inject-host":[0,{"t":"h1","c":"inject-host 组件"},{"t":"p","c":"鉴于 Web Components 的隔离性，很难直接修改组件插槽内元素的样式。为了应对这个问题，ofa.js 提供了一个名为 inject-host 的组件；inject-host 组件会向宿主层注入样式，从而更灵活地配置组件的外观。"},{"t":"p","c":"需要注意的是，使用此组件可能会影响宿主层的样式。因此，在侵入样式时应保持命名的规范性，以避免影响宿主的样式。"},{"t":"p","c":"示例中，我们定义了 comp-two 组件，内部使用了 inject-host 组件来注入样式。这使得我们可以通过注入的样式对 comp-two 组件内的元素进行样式设置，而不会影响到其他组件。"},{"t":"p","c":"同时，以下内容也需要特别注意："},{"t":"l","c":"- 通过在 inject-host 内添加 <style> 标签，我们可以定义组件内的特定样式。这些样式只会影响到当前组件的元素，而不会波及到其他组件。\n- 在注入样式时，应当避免使用过于普通的选择器，以免影响到其他组件的样式。需要保持选择器的唯一性和特定性。\n- inject-host 也可以注入外部的样式表文件，通过 <link rel=\"stylesheet\" href=\"target/style.css\"> 的方式。"},{"t":"p","c":"在整个示例中，通过使用 comp-two 组件内的 inject-host，我们可以在不破坏其他组件样式的情况下，灵活地设置并应用组件内部的样式。"}],"event-passing":[0,{"t":"h1","c":"事件传递"},{"t":"p","c":"除了监听原生事件，on 还可以用于监听自定义事件，这在组件间实现事件通信时非常重要。自定义事件通过 emit 方法来触发。通过触发自定义事件，可以将自定义数据传递给接收方。"},{"t":"p","c":"如果需要跨越组件的 Shadow DOM 边界，以触发事件，可以添加 composed 属性。"},{"t":"p","c":"在下面的案例中，我们将学习如何使用 emit 方法在嵌套的组件之间进行事件传递。"}],"sync":[0,{"t":"h1","c":"双向数据绑定"},{"t":"p","c":"通过使用 sync 语法，您可以在用户界面的交互元素（例如输入框或自定义组件）与数据模型之间建立实时的双向关联。"},{"t":"p","c":"以下示例演示了如何在组件中使用 sync 属性来实现输入框与数据模型之间的双向数据绑定："},{"t":"l","c":"- 在 data 参数中，我们定义了名为 testText 的数据，并为其设置初始值为 \"I am testText\"。\n- 使用 sync:value=\"testText\" 表示输入框的值与 testText 数据之间建立了双向数据绑定。因此，当用户在输入框中输入内容时，testText 数据会实时更新，反之亦然。\n- 同样，使用 sync:txt=\"testText\" 表示自定义组件的 txt 属性与 testText 数据之间建立了双向数据绑定。组件的 txt 属性发生变化时，testText 数据会实时更新，反之亦然。"},{"t":"p","c":"通过双向数据绑定，您可以轻松地在用户界面和数据模型之间建立联系，使得数据的变化能够自动反映在界面上，同时用户在界面上的输入也能立即影响到数据模型。"},{"t":"p","c":"值得注意的是，数据同步只能传递 字符串 或 数字，无法传递其他数据类型。"}],"fill":[0,{"t":"h1","c":"填充渲染"},{"t":"p","c":"填充渲染（x-fill）模板在前端框架中类似于列表渲染的概念，它允许您根据数据集合动态地渲染一组微型组件。"},{"t":"p","c":"在填充渲染过程中，您可以使用以下特殊变量："},{"t":"l","c":"- $data：代表填充项的数据。通过操作 $data，您可以获取或修改每个填充项的数据。\n- $index：代表当前数据项在数据集合中的索引。\n- $host：代表当前组件自身。如果您想要获取组件的数据或调用组件的方法，需要使用 $host 来访问组件。"}],"life-cycle":[0,{"t":"h1","c":"生命周期"},{"t":"p","c":"生命周期钩子函数提供了在组件不同阶段执行代码的机会。在 ofa.js 中，有五个主要的生命周期钩子函数，它们分别是：created、ready、watch、attached 和 detached。"},{"t":"l","c":"- created(): 在组件被创建时调用，此时 shadow root 尚未开始渲染。可以在这里执行一些初始化设置，但不能访问 shadow root 中的元素。\n  \n- ready(): 在 shadow root 渲染完成后调用，一般用于组件的初始化逻辑。在这个阶段，您可以访问并操作 shadow root 内的元素，以及执行其他需要在渲染完成后执行的操作。\n\n- watch: 通过定义 watch 对象来监听数据的变化。在 ready 完成后，会触发一次 watch，对应着 data 上的值。之后，每次对应的键的值发生变动后，都会触发 watch 内对应的函数。\n\n- attached(): 当组件被添加到 document 中时调用，此时可以进行与外部环境交互的操作，如获取组件外观或初始化共享数据的逻辑。\n\n- detached(): 当组件从 document 中移除时调用。在这个阶段，您可以执行清理工作，取消与外部环境的交互，并释放资源。"}],"fill-temp":[0,{"t":"h1","c":"递归填充渲染"},{"t":"p","c":"填充渲染允许您使用独立的模板来渲染数据，并通过 <template> 元素添加 name 属性进行命名。这种方式使得您可以实现嵌套结构的数据渲染，从而创建更复杂的组件。"},{"t":"p","c":"在使用 x-fill 进行填充渲染时，只需将对应的模板名称传递给 name 属性，即可渲染独立模板的内容。此外，填充渲染还支持递归填充，即在模板内部可以继续使用相同的模板名称，实现嵌套填充。"},{"t":"p","c":"在示例中，我们定义了一个名为 item 的独立模板，并在 x-fill 使用时传递了相应的模板名称。这样，数据中的每个项都将使用这个模板进行渲染，而且模板内部可以再次使用相同的模板名称进行递归填充。这种方式使得您可以灵活地处理具有嵌套结构的数据，实现更加复杂的组件渲染。"}],"condition":[0,{"t":"h1","c":"条件渲染"},{"t":"p","c":"模板内除了有模板语法，也有模板组件；"},0,{"t":"p","c":"条件渲染允许您在特定条件下，动态地在组件中插入不同的内容。以下是一个演示如何在组件内使用条件渲染的示例。"},{"t":"p","c":"在这个示例中，我们创建了一个名为 test-demo 的组件。组件内包含一个按钮，点击按钮会使 count 属性自增。通过 x-if、x-else-if 和 x-else 标签，我们实现了条件渲染的逻辑。"},{"t":"l","c":"- x-if 标签接受一个 value 属性，用于定义条件。如果 value 的值为 true，则渲染 x-if 内部的内容。在这个示例中，如果 count 为偶数，将显示红色文本。\n- x-else-if 标签也接受一个 value 属性，用于定义条件。如果前面的条件不满足且 value 的值为 true，则渲染 x-else-if 内部的内容。在这个示例中，如果 count 为 3 的倍数，将显示蓝色文本。\n- x-else 标签不需要 value 属性，它会在前面的条件都不满足时渲染其内部的内容。在这个示例中，如果 count 既不是偶数也不是 3 的倍数，将显示绿色文本。使用 x-else 时也可以紧跟在 x-if 后面；"},{"t":"p","c":"通过这种方式，您可以根据不同的条件动态地渲染不同的内容，实现灵活的交互和展示效果。"}],"custom-form-element":[0,{"t":"h1","c":"自定义表单组件"},{"t":"p","c":"使用 ofa.js，您可以轻松地开发自定义的表单元素组件，使其具有标准的表单特性。只需要为自定义组件添加 value 属性并设置 name 特性，您的自制组件就能够作为标准表单元素来使用。通过更新组件的 value 属性，您就能实现与表单元素的交互。"},{"t":"p","c":"初始化 formData 时，需要将自定义组件的选择器特征添加到参数中（尽管 formData 方法默认的参数为 \"input,select,textarea\"）。这样，formData 就能够与自定义组件进行联动。"},{"t":"p","c":"在这个示例中，我们通过自定义组件 custom-input 来实现一个可编辑的文本输入框。该组件被用作表单元素，并使用 value 属性进行数据交互。使用 formData 方法时，我们将 \"input,custom-input\" 添加为参数，以便正确地初始化表单数据。"}],"use-app":[0,{"t":"h1","c":"使用 app 组件"},{"t":"p","c":"在 ofa.js 中，您可以使用 o-app 组件来创建整个应用的布局结构，并在其中加载不同的页面模块。通过使用 o-app 组件、o-page 组件和页面模块，您可以构建整个应用的页面结构，并实现页面之间的导航"},{"t":"p","c":"当 o-page 组件位于 o-app 内部时，您可以使用带有 olink 属性的 <a> 标签来实现页面跳转。这种跳转不会影响当前页面，而是只会在 o-app 内部进行跳转，类似于使用 <iframe>。"},{"t":"p","c":"如果 o-page 组件在 o-app 内部，您还可以使用以下方法："},{"t":"l","c":"- goto 方法来进行页面跳转\n- back 方法返回上一页\n- replace 方法进行当前页面的替换式跳转"},{"t":"p","c":"通过使用 o-app 组件，您可以构建整个应用的布局结构，并在其中加载不同的页面模块。同时，o-app 提供的路由功能使得页面之间的跳转变得更加方便和灵活。"},{"t":"p","c":"在这个示例中，我们通过 o-app 组件创建了一个应用布局，然后在其中加载了一个页面模块 page1.html。"},{"t":"p","c":"在 page1.html 页面模块中，我们定义了一个标题和一个按钮，点击按钮会跳转到另一个页面模块 page2.html。我们还添加了一个带有 olink 属性的链接，点击链接同样会导航到 page2.html。"},{"t":"p","c":"在 page2.html 页面模块中，我们同样定义了一个标题和一个按钮，点击按钮会返回上一页，实现页面导航。"}],"form-data":[0,{"t":"h1","c":"表单数据"},{"t":"p","c":"在许多应用中，处理表单数据是一项常见的任务。为了简化这个过程，ofa.js 对表单数据的处理进行了二次抽象，提供了 formData 方法。通过这个方法，您可以轻松地将表单元素的值映射到一个对象上，并且在表单元素的值发生变化时，自动更新这个对象的数据，反之亦然。"},{"t":"p","c":"通过使用 shadow 属性，您可以获取到组件的 Shadow DOM 根节点的内容。这可以让您在组件内部访问和操作 Shadow DOM 中的元素和样式。"},{"t":"p","c":"在这个示例中，我们可以看到如何利用 formData 方法将表单数据自动映射到对象 fdata 上。这使得您可以通过操作 fdata 对象来获取或修改表单元素的值，而这些变动也会自动同步到对应的表单元素上。"}],"app-config":[0,{"t":"h1","c":"配置 app 参数"},{"t":"p","c":"您可以通过为 o-app 标签单独设置外部模块来配置应用的参数。"},{"t":"p","c":"这些参数是一个 ES 模块，您可以配置以下参数："},{"t":"l","c":"- home: 应用的首页，即初始加载时显示的页面。\n- loading: 在应用页面点击跳转时，在未完成模块加载前，显示的加载中内容。您可以通过返回一个字符串作为 loading 内容。\n- pageAnime: 页面跳转时的动画效果，使用的是一个包含 CSS 样式属性的对象。\n  - current: 表示页面处于当前页时的样式。\n  - next: 表示页面在未进场时的样式。\n  - previous: 表示页面在要退出时的样式。"},{"t":"p","c":"通过这种方式，您可以根据应用的需要，自定义首页、加载中样式和页面跳转动画等参数，从而为应用带来更加个性化的体验。"}],"use-page":[0,{"t":"h1","c":"使用页面组件"},{"t":"p","c":"一旦加载了 ofa.js，全局会自动添加一个名为 o-page 的页面组件。这个组件用于加载页面模块，页面模块是一种特殊的组件模块，不会注册为自定义标签，而是通过 o-page 组件来加载。"},{"t":"p","c":"页面模块类似于组件模块，但是有一些不同之处。页面模块使用 page 属性来定义模板，而不是 component 属性。页面模块的开发逻辑和组件模块一样，使用相同的模板语法和模板组件等。然而，页面模块不能使用 attrs 特性，因为页面的参数通常通过 URL 传递，而不是通过 data 或 attrs。"},{"t":"p","c":"在示例中，o-page 组件用于加载 page.html 页面模块。页面模块中使用 page 属性定义模板，然后通过 JavaScript 函数返回一个对象来设置数据。URL 中的查询参数 count 会被传递到页面模块中，并被用于初始化数据。页面内的按钮点击事件可以更新数据并在页面中呈现。"}],"app-loading":[0,{"t":"h1","c":"为 app 定制 loading"},{"t":"p","c":"以下是一个为 o-app 组件定制 loading 的示例。在这个示例中，我们为 loading 创建了一个漂亮的进度条，它会在页面加载期间逐渐增长，加载完成后会直接到达 100%，然后将 loading 元素删除。"},{"t":"p","c":"您可以将以下代码复制并用于定制您的应用的 loading 效果："},0,{"t":"p","c":"通过这段代码，您可以为您的应用添加一个独特的加载效果，让用户在页面切换过程中有更好的体验。"}],"set404":[0,{"t":"h1","c":"配置404页面"},{"t":"p","c":"在应用的配置模块中，通过设置 fail 函数，以自定义在页面加载失败时所展示的内容；"},{"t":"p","c":"在这个示例中，当页面加载失败时，将显示加载错误信息的第一行内容；"},0],"nested-page":[0,{"t":"h1","c":"嵌套页面"},{"t":"p","c":"一些应用程序的 UI 由多层嵌套的页面组成，例如公用顶部或侧边的导航。你可以使用 parent 属性来表示嵌套当前页的父页面。"},{"t":"p","c":"父页面的制作方式类似于组件开发，你需要创建一个包含整个框架布局的页面，然后将嵌套到内部的子页面放到 slot 中。"},{"t":"p","c":"这个示例演示了如何创建嵌套页面，其中 page1.html 和 page2.html 是子页面，而 layout.html 是父页面。父页面 layout.html 包含了整个框架布局，而子页面则通过 parent 属性指向父页面，表示它们应该嵌套在父页面内。"},{"t":"p","c":"当切换页面时，会触发 routerChange 事件。在页面初始化和切换页面时，你可以使用 app.current 属性来获取当前页地址，并在页面中修正标签页的激活状态。"}],"multi-nested":[0,{"t":"h1","c":"多级嵌套页面"},{"t":"p","c":"要使用多层嵌套页面功能，只需在父层的嵌套页面模块上设置\"parent\"属性，并将其值设为要嵌套页面模块的地址。"},{"t":"p","c":"更详细的信息，请参阅之前的文章，其中提供了与嵌套相关的参数和方法。"}],"use-hash-router":[0,{"t":"h1","c":"使用 hash router"},{"t":"p","c":"只需使用 o-router 组件，即可将 app 组件内的路由与当前网页关联起来。一旦页面与路由绑定，即使进行页面刷新，也能保持页面的路由状态。"},{"t":"p","c":"在这个示例中，请点击  <span style='font-family: \"iconfont\"'>&#xe7cb;</span>  按钮，以新页面的方式打开并尝试。"},0],"use-scsr":[0,{"t":"h1","c":"使用 SCSR 方案"},{"t":"p","c":"在这个示例中，请点击 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 按钮，以新页面的方式打开并尝试；"},{"t":"p","c":"SCSR 的全称是 Static Client-Side Rendering，又称为静态客户端渲染。它是 CSR（Client-Side Rendering）的一种变种，在保留了 CSR 用户体验的基础上，还能够让页面在静态状态下被搜索引擎爬取。"},{"t":"p","c":"当前网站采用的正是 SCSR 方案构建；"},{"t":"p","c":"SCSR 通过直接运行单文件模式的页面模块，无需使用 o-page 标签，实现在页面上进行渲染。具体而言，就是将页面模块的模板代码直接嵌套在 o-app 内。"},{"t":"h2","c":"注意事项"},{"t":"p","c":"对于所有采用 SCSR 方案的页面，除了页面描述性的内容（如 title、meta:description、keywords）和页面模板内容外，其他引用的资源必须保持一致，以确保在页面跳转和刷新后的用户体验一致。"}],"sync-state":[0,{"t":"h1","c":"状态同步"},{"t":"p","c":"有时候需要多个组件实例或页面共享一份数据，这时候就需要状态同步的功能。"},{"t":"p","c":"使用 $.stanz 方法创建可共享的数据；如果需要在组件中分享此数据，应在组件的 attached 时将数据绑定到组件上。"},{"t":"p","c":"注意：需要在 detached 周期将绑定的数据清除，不然会内存泄露。"},{"t":"p","c":"在这个示例中，我们演示了如何使用状态同步功能来实现暗黑模式的切换。首先，我们使用 $.stanz 方法创建了一个名为 isDark 的数据对象，该对象可以在多个组件间共享。使不同组件实例能够共享数据，实现暗黑模式的切换。"}],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"通过设置别名（alias），使用者能够更方便地使用共享的资源，特别适用于使跨域名的共享组件更方便地享用同一版本的资源。"},{"t":"p","c":"在这个示例中，我们通过 lm.config 方法设置了别名，将 @obook 别名映射到 https://cdn.jsdelivr.net/npm/obook。现在，当我们使用 @obook 作为前缀时，它将自动映射到指定的 URL。"},0,0,0,0,{"t":"p","c":"通过使用别名 @obook，我们在 l-m 标签中引入了 \"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\" 这个资源，使得跨域名的组件可以更方便地访问共享资源，而无需知晓详细的资源地址。这增强了代码的可维护性和跨域名资源共享的便捷性。"},{"t":"h2","c":"注意事项"},{"t":"p","c":"在设置别名时，请注意以下几点："},{"t":"l","c":"- 别名的键必须以 @ 开头，如 @example。"},0,{"t":"l","c":"- 不要重复设置相同名称的别名，否则会引发错误。"},0]},"docs":{"introduce":[{"t":"h1","c":"ofa.js - 渐进式前端框架"},{"t":"h2","c":"什么是 ofa.js"},{"t":"p","c":"ofa.js是一个渐进式前端框架，旨在让开发者以最低成本进入前端开发和使用流程。它提供了一系列简单而强大的工具和API，让前端开发变得更加高效和便捷。"},{"t":"h2","c":"存在目的"},{"t":"h3","c":"取代 jQuery"},{"t":"p","c":"在许多小型项目中，我们可能并不需要引入像React和Vue这样的大型框架，而是倾向于使用jQuery进行简单的前端操作。ofa.js改进了jQuery的API，并将jQuery的许多方法替代为属性，使得使用ofa.js在很多场景下更为合适。"},{"t":"h3","c":"简化前端开发和使用流程"},{"t":"p","c":"ofa.js的目标是简化繁琐的前端开发流程。它允许开发者无需学习复杂的Node.js、npm和脚手架等工具，从而更快地搭建前端应用。使用它，你可以回归到只需引入一个库即可进行开发的体验。"},{"t":"h3","c":"成为银弹型前端开发框架"},{"t":"p","c":"ofa.js旨在成为一种\"银弹\"，即能够解决多种前端开发问题，并提供全面的解决方案。它不仅仅是一个工具库，更是一种全面的前端开发框架。"},{"t":"h2","c":"特点"},{"t":"h3","c":"易上手的组件开发"},{"t":"p","c":"使用ofa.js开发的组件几乎没有学习成本。ofa.js提供了简洁而直观的API，让开发者可以快速创建和集成组件，同时保持代码的整洁和易于维护。"},{"t":"h3","c":"内置模块化、状态更新和应用集成方案"},{"t":"p","c":"ofa.js内部已经集成了模块化、状态更新和应用集成等解决方案，使得开发者无需额外寻找第三方库或工具，就可以完成复杂的前端开发任务。"},{"t":"h3","c":"官方提供路由和 SSG（静态站点生成）方案"},{"t":"p","c":"ofa.js还为路由和SSG提供了官方解决方案，帮助开发者更好地管理前端路由和生成静态站点，提高应用性能和SEO友好度。"},{"t":"h3","c":"精简的代码体积"},{"t":"p","c":"ofa.js的代码经过精心优化，压缩后的.min文件大小只有38kb(gzip下只有14kb)。这使得ofa.js成为一个高效的前端框架，可以在各种网络环境下快速加载和使用。"}],"get-started":{"index":[{"t":"h1","c":"上手使用"},{"t":"h2","c":"如何使用"},{"t":"h3","c":"直接引用"},{"t":"p","c":"你可以通过 CDN 的地址直接将 ofa.js 引用到你的页面上："},0,{"t":"h3","c":"通过 npm 安装"},{"t":"p","c":"首先，在你的项目中安装 ofa.js："},0,{"t":"p","c":"然后在项目中引入 ofa.js 模块："},0,{"t":"h3","c":"使用"},{"t":"p","c":"在引用资源后，ofa.js 将在全局作用域上设置一个 $ 属性，所有的功能都在 $ 上，后面的教程会详细讲解其用法；"},{"t":"p","c":"通常情况下，我们建议采用直接引用的方式添加 ofa.js，而使用 npm 的方式则用于与类似 React 和 Vue 等框架进行兼容。"}],"hello-world":[{"t":"h1","c":"第一个案例"},{"t":"p","c":"以下是一个案例，点击按钮后将文本更改为 \"Hello World\"："},0,0,0,0,{"t":"p","c":"当点击按钮后，将会显示加粗的 \"Hello World\" 文本。"},{"t":"p","c":"现在，让我们详细解释一下基础概念。"},{"t":"h2","c":"选择器"},{"t":"p","c":"引用了 ofa.js 后，$ 符号将被注册到全局作用域中。通过 $('xxx') 来选择符合条件的第一个 元素，其中 xxx 是标准的 CSS Selector  内容。你可以点击链接查看具体的选择器内容。"},{"t":"p","c":"以下是一个例子："},0,0,0,0,{"t":"p","c":"在上面的案例中，打开页面一秒后，会分别改变 p标签 、#desk 和 .logger  的文本内容。"},{"t":"h2","c":"事件绑定"},{"t":"p","c":"选择元素成功后，你可以为元素绑定事件。就像前面提到的 \"Hello World\" 案例中，我们给 id 为 \"btn\" 的元素绑定了点击事件。当点击按钮后，绑定的函数会被执行。"},{"t":"p","c":"你可以点击跳转查看 事件示例  章节，了解一些事件绑定的案例；"},{"t":"p","c":"所有可用的事件，可以参考 Web Events 来了解完整的事件列表。"},{"t":"h2","c":"属性"},{"t":"p","c":"在上面的两个案例中，我们分别展示了 html 和 text 属性的使用。"},{"t":"p","c":"你还可以通过 html 或 text 属性来获取元素的内容，如下所示："},0,0,0,0,{"t":"p","c":"这个例子中，我们将 #t1 元素内的 HTML 内容赋值给了 #t2 和 #t3 元素。"}],"elements-and-events":[{"t":"h1","c":"获取元素和事件相关"},{"t":"p","c":"该章节旨在加强对上一章内容的理解，包括选择元素 和 事件绑定。"},{"t":"h2","c":"选择元素"},{"t":"p","c":"在之前的章节中，我们已经了解了通过 $ 符号从全局获取某个元素的方法。接下来，我们将介绍其他获取元素的方法。"},{"t":"h3","c":"从元素内查找某个元素"},{"t":"h4","c":"使用 $(\"xxx\").$('xxxx') 的方式"},{"t":"p","c":"$(\"xxx\").$('xxxx') 是通过先选择一个父元素，然后在其内部查找符合条件的子元素的方式。其中，$(\"xxx\") 选择了一个父元素，然后使用 $('xxxx') 在该父元素内查找符合条件的子元素。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，首先通过 $(\".parent\") 选择了具有 parent 类的父元素，然后使用 $(\".child\") 在该父元素内查找具有 child 类的子元素。然后修改了子元素的文本内容为 \"Modified child element\"。"},{"t":"h3","c":"使用 $('xxx xxxx') 的方式"},{"t":"p","c":"$('xxx xxxx') 是通过在全局范围内查找符合第二个选择器条件的元素，然后在这些元素内部查找符合第一个选择器条件的元素。这种方式可以直接一步到位地查找到符合条件的子元素。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，直接使用 $('div .child') 查找到具有 child 类的子元素，并修改了子元素的文本内容为 \"Modified child element\"。"},{"t":"h3","c":"选择多个元素"},{"t":"h4","c":"使用 $.all('xxx') 查找全局的元素"},{"t":"p","c":"$.all('xxx') 方法用于查找页面中所有符合选择器条件的元素，并将它们作为一个元素集合返回。这样可以选择页面中的多个元素进行批量操作。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，使用 $.all(\"p\") 查找到页面中的所有 p 标签元素，并对它们进行了批量操作，将文本内容修改为 \"Modified Paragraph 1\"、\"Modified Paragraph 2\" 和 \"Modified Paragraph 3\"。"},{"t":"h3","c":"从元素内查找所有符合条件的元素"},{"t":"p","c":"除了可以在全局范围内查找元素，还可以从某个元素内查找所有符合条件的子元素，使用方式为：$('xxx').all('xxxx')。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，首先使用 $(\".container\") 查找到具有 container 类的元素，然后通过 .all(\".item\") 在该容器内查找所有带有 item 类的子元素，并对它们进行了批量操作，将文本内容修改为 \"Modified Item 1\"、\"Modified Item 2\" 和 \"Modified Item 3\"。"},{"t":"h2","c":"事件"},{"t":"p","c":"前面已经讲过 on 绑定事件的使用方法，后面介绍几个和事件相关的方法；"},{"t":"h3","c":"off 方法的使用文档"},{"t":"p","c":"off 方法用于移除通过 on 方法绑定的事件处理函数。当不再需要某个事件的处理函数时，可以使用 off 方法将其从元素上移除，以避免重复执行或内存泄漏。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: 选择要移除事件处理函数的元素。 \n- eventName: 要移除的事件名称。 \n- eventHandler: 要移除的事件处理函数。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，当点击按钮时，会弹出一个对话框显示 \"Button clicked!\"。但是在5秒后，通过 off 方法移除了点击事件处理函数，所以按钮再次点击时不会触发弹出对话框。"},{"t":"h3","c":"one 方法的使用文档"},{"t":"p","c":"one 方法用于绑定事件处理函数，但该处理函数只会在第一次触发事件时执行一次。在执行一次后，事件处理函数会被自动移除，避免重复触发。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: 选择要绑定事件处理函数的元素。 \n- eventName: 要绑定的事件名称。 \n- eventHandler: 要执行的事件处理函数。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，当点击按钮时，会弹出一个对话框显示 \"Button clicked once!\"。但是在第一次点击后，事件处理函数就会被移除，所以后续点击按钮不会再触发弹出对话框。"},{"t":"h3","c":"emit 方法的使用文档"},{"t":"p","c":"emit 方法用于手动触发元素上绑定的特定事件。通过 emit 方法可以在不进行实际操作的情况下触发事件处理函数的执行。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: 选择要触发事件的元素。 \n- eventName: 要触发的事件名称。"},{"t":"h4","c":"示例"},0,{"t":"p","c":"在上面的示例中，通过 emit 方法手动触发了按钮的点击事件，结果会弹出一个对话框显示 \"Button clicked!\"，尽管没有实际点击按钮。"},{"t":"p","c":"注意：使用 emit 方法不会模拟鼠标点击或其他实际事件，它只会直接调用已绑定的事件处理函数。所以，如果你希望在特定情况下触发事件的执行，可以使用 emit 方法。"},{"t":"p","c":"当你绑定事件后，有时你可能希望阻止事件的进一步传播（冒泡）或取消事件的默认行为。下面将介绍如何在事件触发后禁止冒泡和取消默认事件。"},{"t":"h3","c":"禁止事件冒泡"},{"t":"p","c":"事件冒泡是指当一个元素上的事件被触发时，它会沿着 DOM 树向上冒泡，依次触发父元素上的同类型事件。如果你希望在特定元素上处理事件后阻止其继续冒泡，可以使用 event.stopPropagation() 方法。"},{"t":"p","c":"示例代码："},0,{"t":"p","c":"在上面的示例中，当你点击按钮 \"Click Me\" 后，它会显示 \"Button Clicked!\"，但不会触发 \"Inner Div Clicked!\" 和 \"Outer Div Clicked!\"。这是因为我们在按钮的点击事件处理程序中调用了 event.stopPropagation()，阻止了事件的进一步传播。"},{"t":"h3","c":"取消事件的默认行为"},{"t":"p","c":"有些元素上的事件在触发时会有默认的行为。例如，点击提交按钮会导致表单提交，点击链接会跳转到链接的地址等。如果你希望阻止事件的默认行为，可以使用 event.preventDefault() 方法。"},{"t":"p","c":"示例代码："},0,{"t":"p","c":"在上面的示例中，当你点击提交按钮 \"Submit\" 后，它会显示 \"Hello, {name}! Form submission prevented.\"，但不会触发 \"Form Submitted!\" 的警报。这是因为我们在提交按钮的点击事件处理程序中调用了 event.preventDefault()，阻止了表单的提交默认行为。"}],"basic-concept":[{"t":"h1","c":"实例的基础概念"},{"t":"p","c":"$ 实例是对页面上元素的封装，除了用于选择现有的元素外，它还可以直接创建新元素并进行操作。在本章中，我们将介绍如何创建新元素以及对 $ 实例的一些操作。"},{"t":"h2","c":"创建新元素"},{"t":"p","c":"通过 $ 实例，我们可以直接创建新的元素并进行操作，例如："},0,0,0,0,{"t":"p","c":"在上面的例子中，我们通过 $('<div style=\"color:red\">I am text</div>') 创建了一个新的 div 元素，并将其添加到了 body 中。"},{"t":"h2","c":"获取子元素"},{"t":"p","c":"通过 $ 获取的实例，并不像 DOM 元素那样拥有 children 属性。但是我们可以通过数组索引来访问实例的直接子元素："},0,0,0,0,{"t":"p","c":"在上面的例子中，我们获取了 div 元素，并通过索引来访问第一个和第二个 p 元素。同时，我们还使用了 $div.length 获取了子元素的数量。"},{"t":"h2","c":"操作子元素"},{"t":"p","c":"通过 $ 实例，我们还可以直接使用数组的方法来操作子元素，例如 push 和 pop："},0,0,0,0,{"t":"p","c":"在上面的例子中，我们获取了所有 p 元素的 $ 实例，并使用 push 方法添加了一个新的 div 元素作为子元素，然后使用 pop 方法移除了最后一个子元素。"},{"t":"p","c":"通过上述示例，你可以了解 $ 实例的一些基本操作，包括创建新元素和对子元素的访问与操作。 $ 实例提供了简便的方法来操作页面上的元素。"}],"common-properties":[{"t":"h1","c":"常用属性或方法"},{"t":"p","c":"在 $ 实例中，除了可以通过选择器选择元素外，还提供了一些常用的来方便元素的操作和查找。"},{"t":"p","c":"可以稍微浏览一下，将来在需要时，可以随时参考 API 文档。"},{"t":"h2","c":"常用的属性"},{"t":"l","c":"- tag：获取目标的标签名\n- ele：获取实例的实际原生元素\n- index：获取目标元素在其父元素下的排序\n- text：获取或设置目标元素的文本\n- html：获取或设置目标元素的 HTML 代码\n- css：获取或设置目标元素的样式\n- style：获取目标元素的原生样式\n- classList：获取目标元素的原生 class 列表\n- data：获取目标元素的原生数据集"},{"t":"h3","c":"节点操作"},{"t":"l","c":"- before：在目标实例的前面添加元素\n- after：在目标实例的后面添加元素\n- remove：删除目标元素\n- attr：获取或设置目标元素的 attributes"},{"t":"h2","c":"重要特性"},{"t":"l","c":"- 表单数据：方便地绑定和获取表单数据"},{"t":"p","c":"如果还想更深入了解 ofa.js 的 api，可以参考 API 文档；"}]},"create-component":{"index":[{"t":"h1","c":"制作和使用组件"},{"t":"p","c":"ofa.js 使用基础的 HTML 和 JavaScript 文件来定义组件，避免引入新的文件类型以减少学习成本。只要你对 HTML 有一定的了解，就能够快速开发和使用 ofa.js 组件。"},{"t":"h2","c":"准备创建组件前的步骤"},{"t":"p","c":"在开始创建组件之前，需要注意一些准备工作。由于创建组件涉及到浏览器请求资源的操作，如果你仅仅是双击打开 HTML 文件来查看，会在 \"file\" 协议下进行查看。在 \"file\" 协议下，JavaScript 模块的加载可能会报错。因此，你需要准备一个静态服务器来正确查看组件。"},{"t":"p","c":"如果你使用的是 Visual Studio Code 编辑器，你可以简单地安装一个支持静态服务器的插件。我们推荐使用 Live Server 插件。"},{"t":"p","c":"安装插件后，只需在 demo.html 文件上右键点击，选择 \"Open with Live Server\"，插件将会自动以静态服务器模式打开文件。"},{"t":"p","c":"如果你使用的是其他编辑器，你也可以创建一个 Nginx 或 Apache 服务器，只要能够支持静态 HTML 查看即可。这样做可以确保你能够正常预览和开发你的组件。"},{"t":"h2","c":"创建一个按钮组件"},{"t":"p","c":"下面，我们将创建一个简单的按钮组件，命名为 simple-button，它将具有比原生按钮更美观的样式。"},{"t":"p","c":"首先，创建一个名为 simple-button.html 的文件，其中使用 template 标签，并添加 component 属性以标识为组件。"},{"t":"p","c":"然后，在 template 内部编写组件的模板代码。接着，在模板内容下方，添加一个 script 标签，将组件的 JavaScript 代码放入其中。"},0,{"t":"p","c":"在成功引入 ofa.js 后，会自动注册 load-module 组件，这是一个用于声明式引用模块的组件，类似于 script 标签。该组件会代理加载指定 src 的模块，并对需要加载的模块进行预处理。在本案例中，会加载模板并注册 simple-button 组件。"},{"t":"p","c":"load-module 组件还可以使用缩写 l-m，以减少代码量。"},0,{"t":"p","c":"load-module 组件是一个定制的声明式加载器库，提供了强大的功能，可以扩展支持各种类型的文件，或者对 JavaScript 模块进行中转处理。它已经拆分成了一个独立的项目，具体的使用文档在 https://github.com/kirakiray/drill.js。"},{"t":"h3","c":"双文件模式"},{"t":"p","c":"双文件模式将 静态模板 和 逻辑代码 分开，使组件更加清晰。"},{"t":"p","c":"逻辑代码放在 js 文件内，这个 js 需要标识 export const type = $.COMP;，以通知页面这是一个组件模块。在这种拆分模式下，模块代码可以使用 import 等 ES Module 的标准语法。"},{"t":"p","c":"按钮组件由两个文件组成："},{"t":"l","c":"1. simple-button.html：按钮组件的 HTML 模板和样式。"},0,{"t":"l","c":"2. simple-button.mjs：按钮组件的注册代码。"},0,{"t":"p","c":"在需要使用该组件的地方，使用 l-m 引入这个模块。以下是使用 simple-button 的案例页面（双文件模式）。"},0],"parameter-description":[{"t":"h1","c":"组件的注册参数详解"},{"t":"p","c":"在 ofa.js 中，你可以在组件模块中定义一些特定的注册参数，以便更灵活地配置组件。下面详细说明了每个注册参数，并附带了相应的示例演示。"},{"t":"h2","c":"基础参数"},{"t":"p","c":"基础参数是注册组件的最基本配置，包含以下几个属性："},{"t":"h3","c":"tag"},{"t":"p","c":"tag 代表注册的组件名。当没有定义 tag 属性时，注册的组件名与文件名保持一致。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"data"},{"t":"p","c":"data 是对象类型属性，用于生成组件后，默认添加的自定义数据。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs 是对象类型属性，也属于 data，但是这个数据会反映到 element 的 attributes 上，attributes 上的改动也会动态改动到组件的 data 上。当出现大写的 key 时，反应到组件 property 会变成 - 驼峰的命名。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"proto"},{"t":"p","c":"在组件的注册参数中，你可以添加一个 proto 对象，用于定义需要添加到组件原型上的方法。这样，在创建组件的实例时，这些属性和方法就会被添加到实例的原型上，从而所有实例都可以访问和共享这些方法。"},0,{"t":"h3","c":"watch"},{"t":"p","c":"watch 是对象类型属性，用于监听 data 变化的监听函数放在这里。注册成功后，监听的值会被立刻执行一次。"},{"t":"l","c":"- watch 注册的函数在单次线程改动中，只会被触发一次。因此，在一次线程中，即使多次修改这个监听的值，也只会被触发一次。\n- 第一个参数为当前值。\n- 第二个参数是对象，会带有 watchers 数据集，一般情况下 watchers 上只会有一个对象，可以从这个对象上获取到 oldValue。当单次线程的这个被监听的值被改动过多次，这个数据集会记录多次的变化。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"temp"},{"t":"p","c":"通常情况下，不需要设置这个变量，它主要在分离模式下使用，用于指定组件模板的地址。当未定义 temp 时，默认会加载与当前模块同名的 HTML 文件，该文件应位于相同目录中。"},{"t":"h2","c":"合并变量到 default"},{"t":"p","c":"可以将所有的导出变量写到 default 上，这样写起来更方便；"},0,{"t":"h2","c":"示例代码"},{"t":"p","c":"以下为一个完整的示例代码，包括基础参数的定义和组件模板。"},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"你还可以使用异步函数来定义 default 数据，以便动态地返回组件的注册参数。"},{"t":"p","c":"函数的 function 会带来一个对象，包含 load、url 和 query："},{"t":"l","c":"- load 方法是异步加载函数，使用方法和异步 import 加载一致，可以通过 const data = await load(xxx) 加载异步模块。\n- 通过 load 加载的模块，会有和 load-module 加载一样的效果。load 方法相当于 load-module 组件的函数版，具体使用方法可以查阅https://github.com/kirakiray/drill.js的文档。\n- url 是当前模块的文件名。\n- query 是加载这个模块时的 URL 参数转成的对象。"},{"t":"p","c":"以下是使用 default 的示例："},0,{"t":"p","c":"在这个示例中，我们演示了如何使用 ofa.js 的注册参数来定制化组件的行为。通过合理地配置这些参数，你可以更好地适应不同的组件需求，实现更灵活的组件开发。"}],"life-cycle":[{"t":"h1","c":"组件的生命周期"},{"t":"p","c":"在 ofa.js 中，组件生命周期是在特定时间点触发的钩子函数。这些钩子函数让你能更精细地控制和交互，ofa.js 有五个关键生命周期钩子：created、ready、watch、loaded、attached 和 detached，分别在不同时刻触发。"},{"t":"h2","c":"生命周期钩子"},{"t":"h3","c":"created"},{"t":"p","c":"created 生命周期钩子在组件创建时被触发。在此阶段，组件的数据尚未被初始化，模板内容也未被渲染。你可以在这个阶段执行一些初始化操作，或者准备在后续阶段使用的数据。"},{"t":"h3","c":"ready"},{"t":"p","c":"ready 生命周期钩子会在组件的数据和模板刚被初始化后触发，表示组件已经准备就绪。在这个阶段，你可以访问组件的数据，并且模板已经渲染完成，可以执行一些与界面交互相关的操作。"},{"t":"p","c":"如果组件模板存在对其他组件的依赖，这个阶段不会等待依赖加载完成。因此，这个阶段适合为组件添加Loading样式，但需要注意等待依赖加载完成后再执行相关操作。"},{"t":"h3","c":"watch"},{"t":"p","c":"一旦 ready 阶段完成，与之关联的 watch 对象中的监听函数会被触发一次。随后，当数据的某个值发生变动时，会再次触发相应键（key）的监听函数。"},{"t":"h3","c":"loaded"},{"t":"p","c":"loaded 生命周期钩子在组件模板内的所有依赖都加载完成后触发。这个阶段确保在渲染组件之前，所有的依赖都已经加载完毕。这个时候适合去除在 ready 阶段添加的Loading样式。"},{"t":"h3","c":"attached"},{"t":"p","c":"attached 生命周期钩子会在组件被添加到文档中时触发。在这个阶段，适合获取组件内元素的尺寸相关信息，进行数据绑定和全局事件的操作。"},{"t":"h3","c":"detached"},{"t":"p","c":"detached 生命周期钩子会在组件从文档中移除时触发。在这个阶段，你可以执行一些清理操作，比如取消事件监听或者释放资源，以防止内存泄漏。"},{"t":"h2","c":"示例演示"},{"t":"p","c":"以下是一个示例，展示了如何使用这些生命周期钩子："},0,{"t":"h2","c":"生命周期流程图"},0],"web-components":[{"t":"h1","c":"组件化常规知识"},{"t":"p","c":"ofa.js 是一个基于 Web Components 技术的封装库，旨在简化和加速组件开发过程。它通过将复杂的技术细节隐藏在背后，让开发者能够更专注地构建高质量的组件和应用。"},{"t":"p","c":"为了更好地开发组件，有必要学习一些 Web Components 的知识。下面介绍的知识点不仅可以在 ofa.js 中应用，还可以让你在其他使用 Web Components 的框架上同样受益。"},{"t":"h2","c":"Shadow DOM 容器"},{"t":"p","c":"在 Web Components 中，Shadow DOM 提供了一种隔离的容器，用于封装组件内部的样式和结构。这意味着组件内部的样式和 DOM 结构不会与外部的样式和结构相互干扰，从而确保组件的可预测性和可维护性。"},{"t":"p","c":"在 ofa.js 中，每个组件都有一个 Shadow DOM 容器，用于隔离组件的内部内容。模板内容就是被渲染到这个容器内。通过 $ 获取的组件实例，也可以使用 shadow 属性访问组件内部的 Shadow DOM 容器，从而实现对组件内部元素的操作和访问。"},0,{"t":"h2","c":"Web Components 中的常用 CSS 选择器"},{"t":"p","c":"Web Components 提供了一些特殊的 CSS 选择器，用于选择和样式化组件内部的不同部分。以下是一些常用的选择器："},{"t":"h3","c":":host 选择器"},{"t":"p","c":":host 选择器用于选择组件自身的外部容器。可以通过这个选择器来定义组件的样式。"},0,{"t":"h3","c":"::slotted() 选择器"},{"t":"p","c":"::slotted() 选择器用于选择被插槽内容包裹的元素。可以在组件内部的样式中使用这个选择器来样式化被插槽的内容。"},0,{"t":"h2","c":"插槽（Slot）的使用"},{"t":"p","c":"插槽是 Web Components 中用于在组件内部嵌入外部内容的机制。插槽允许开发者将自定义的内容传递到组件内部，实现更灵活的组件结构。"},{"t":"h3","c":"单个插槽"},{"t":"p","c":"在组件模板中，可以使用 <slot> 元素来定义插槽。外部传入的内容会被插入到插槽内部。"},0,0,{"t":"h3","c":"多个命名插槽"},{"t":"p","c":"除了默认插槽外，还可以定义多个命名插槽。命名插槽允许开发者将不同的内容插入到不同的插槽位置。"},0,0,{"t":"h2","c":"slotchange 事件的使用"},{"t":"p","c":"slotchange 事件在插槽内容变化时触发。可以通过监听这个事件来执行一些与插槽内容相关的操作。"},0],"template-syntax":[{"t":"h1","c":"模板语法"},{"t":"p","c":"ofa.js 提供了一系列强大的模板语法，使你能够更灵活地操作组件的界面元素和数据。这些模板语法能够帮助你实现丰富的界面效果和交互体验。"},{"t":"l","c":"- 文本渲染：快速在模板文件上渲染文本\n- class：快速在模板文件上渲染类名\n- sync：快速同步数据到模板文件\n- 条件渲染：按需在模板文件上渲染内容\n- 列表渲染：在模板文件上快速渲染数组数据"}]},"create-app":{"page":[{"t":"h1","c":"使用 o-page 组件"},{"t":"p","c":"在 ofa.js 内部，我们构建了一个名为 o-page 的自定义组件，旨在为页面的开发提供便利。这个组件在应用开发中扮演着关键的角色。当你想要使用组件的模板语法，但又不想创建全新的组件时，o-page 组件将成为你的最佳选择。"},{"t":"h2","c":"页面模块"},{"t":"p","c":"创建一个单文件页面模块时，类似于创建组件模块。使用 template 标签来包裹页面的模板代码，并添加 page 属性。在该标签内部，可以自由使用模板语法与其他组件或页面模块进行交互。"},0,{"t":"p","c":"在 HTML 文件中，使用 o-page 标签的 src 属性指定页面模块的文件路径。页面内容将在该组件内部进行渲染。"},0,{"t":"h2","c":"双文件模式"},{"t":"p","c":"双文件模式将 静态模板 和 逻辑代码 分开，使页面的内容更加清晰。"},{"t":"p","c":"以下是使用 o-page 组件和页面模块的步骤："},{"t":"l","c":"1. 创建页面模块："},{"t":"p","c":"与创建组件模块类似，创建一个页面模块，但将 type 属性设置为 $.PAGE。页面模块可用的参数包括 temp、data、proto 和 watch。"},0,{"t":"l","c":"2. 创建页面模板："},{"t":"p","c":"在与页面模块相同的目录下，创建一个名为 my-page-template.html 的页面模板文件。在这个模板文件中，你可以使用模板语法进行交互，用法与前面提到的组件模板语法类似。"},0,{"t":"p","c":"在你的 HTML 文件中，通过 <o-page> 标签来使用 o-page 组件，通过 src 属性引用页面模块的文件路径。页面的内容将会在这个组件内部渲染。"},0,{"t":"p","c":"这样，当你打开页面时，o-page 组件会动态加载 my-page.mjs 这个页面模块，并根据模块中的模板和数据渲染页面内容。页面模块的生命周期和模板语法与组件模块保持一致，使得页面的开发和管理变得更加统一和灵活。"}],"index":[{"t":"h1","c":"介绍"},{"t":"p","c":"除了可以开发组件，ofa.js 还可以用于开发功能完整的应用程序。"},{"t":"p","c":"ofa.js 将应用程序集成为一个 o-app 组件，通过直接使用这个标签，你就能够快速创建应用程序。这种方式使应用的创建变得简单且高效。"},{"t":"p","c":"此外，ofa.js 官方还提供了完整的 路由 和 SSG（静态页面生成） 方案，帮助开发者构建更健全的应用程序。这些功能能够加速开发流程，让你能够专注于应用程序的逻辑和用户体验，而不必过多担心底层细节。"},0,{"t":"p","c":"上面是一个简单的应用教程代码示例，接下来会逐步讲解应用的开发过程。"}],"app":[{"t":"h1","c":"使用 o-app 组件"},{"t":"p","c":"使用 o-app 标签可以轻松地创建一个完整的应用程序窗口。下面是如何制作一个应用并配置它的步骤："},{"t":"p","c":"文字显得略显枯燥，我们建议您前往 应用案例演示 进行实际尝试；"},{"t":"h2","c":"基础代码"},{"t":"l","c":"1. 创建一个 HTML 文件，设置 o-app 标签为应用的显示窗口。确保为 o-app 设置全屏的样式，以使应用占据整个视口。"},0,{"t":"l","c":"2. 创建一个 es 模块，用于设置应用的配置数据。配置数据包括以下选项：\n\n   - home：字符串类型，应用的首页的页面模块地址。\n   - loading：函数类型，应用在加载新页面时，会运行这个函数，得到的内容会插入到应用中，作为加载时的提示，等到页面加载完成后，会自动去除这个 loading 元素。\n   - fail：函数类型，应用加载页面失败时，会运行这个函数，返回得到的值会显示在应用中作为加载失败的提示。函数会带有加载失败页面的 src 地址和错误报错对象。\n   - pageAnime：页面之间切换时的动画配置。"},{"t":"p","c":"下面是应用的配置数据示例："},0,{"t":"l","c":"3. 在 HTML 文件中使用 o-app 标签，并通过 src 属性引用配置数据的 es 模块。"},0,{"t":"p","c":"通过以上步骤，你已经成功制作了一个使用 o-app 组件的应用程序窗口。o-app 组件会根据配置数据中的设置加载页面，展示加载中的提示或加载失败的提示，并支持页面切换动画。这样，你可以快速搭建一个功能完整且具有交互性的应用程序。"},{"t":"h2","c":"路由跳转"},{"t":"p","c":"在 o-app 应用中，你可以轻松地实现路由跳转，从一个页面模块跳转到另一个页面模块。下面介绍几种不同的方式来进行路由跳转。"},{"t":"h3","c":"使用 <a> 标签进行路由跳转"},{"t":"p","c":"你可以在页面的 HTML 中使用 <a> 标签来实现路由跳转。需要将 href 属性指定为目标页面模块的路径，并添加 olink 属性，以告知 o-app 组件这是一个路由链接。"},0,{"t":"h3","c":"goto"},{"t":"p","c":"你可以在页面模板中使用 on:click 属性来绑定点击事件，并调用模块上的 goto 方法进行路由跳转。"},0,{"t":"p","c":"又或者直接卸载目标元素上："},0,{"t":"h3","c":"替换跳转和返回页面"},{"t":"p","c":"除了 goto 方法外，o-app 还支持 replace 和 back 方法。"},{"t":"l","c":"- replace 方法用于替换跳转，它会取代当前页面的路由，使新页面成为当前页面的路由。"},0,{"t":"l","c":"- back 方法用于返回到前一个页面。"},0,{"t":"p","c":"需要注意的是，应用内会保持组件的路由状态，但路由数据不会绑定到当前浏览器标签上。这样，你可以方便地在应用中实现页面之间的跳转和导航。"},{"t":"p","c":"如果你想实现路由和页面的绑定，可以使用 o-router 组件，我们将在后面的章节中详细介绍。"},{"t":"p","c":"通过以上方法，你可以在 o-app 应用中实现灵活的路由跳转，让用户能够方便地浏览不同的页面内容。"},{"t":"h2","c":"访问应用和当前页面"},{"t":"p","c":"在应用内的各个元素（包括组件），你通过 app 属性来获取它们所在的 o-app 实例。这对于需要与整个应用进行交互的操作非常有用。"},{"t":"p","c":"通过 app.current 属性，你可以获取当前激活的页面模块的地址。"},{"t":"p","c":"以下是一个使用示例："},0,{"t":"p","c":"在上面的示例中，通过选择器 .app 获取了应用标签，然后通过访问 app.current 属性获取了当前激活的页面地址。"},{"t":"h2","c":"使用技巧：提前缓存下一页"},{"t":"p","c":"在一些场景下，你可能已经预知用户即将跳转到下一页。为了提高用户体验，你可以提前缓存下一页的页面模块，这样在实际跳转时可以立即加载，减少用户等待的时间，让用户体验更加流畅。。"},{"t":"p","c":"在当前页面的 JavaScript 代码中，调用 load 方法并传入下一页的模块路径，该模块将被加载并缓存。"},0],"subrouting":[{"t":"h1","c":"子路由模式"},{"t":"p","c":"在 ofa.js 中，设置子路由与一些前端框架的做法略有不同。ofa.js 使用一种更加直观的方式，通过在页面模块上设置父页面来作为容器，从而实现子路由的需求。"},{"t":"h2","c":"设置父页面容器"},{"t":"p","c":"要创建子路由，首先需要在子页面的页面模块上设置 parent 参数，指定父页面的页面模块地址。这样，在子页面加载时，ofa.js 会自动将子页面包裹在父页面容器中。"},0,{"t":"p","c":"在上述示例中，子页面的页面模块通过 parent 参数指定了父页面容器的地址。"},{"t":"h2","c":"父页面容器模板设置"},{"t":"p","c":"父页面容器的模板需要设置一个 <slot> 元素，以便子页面能够插入到父页面的指定位置。同时，确保 <slot> 元素的容器元素设置为 position: relative，这是非常重要的，因为子页面会在父页面容器中绝对定位。"},{"t":"p","c":"以下是一个父页面容器的示例模板："},0,{"t":"p","c":"在上述示例中，通过设置一个带有 slot 的容器元素，子页面会被插入到该容器中。确保容器元素具有相对定位，这样子页面可以根据容器定位。"},{"t":"p","c":"通过使用这种方式，你可以更直观地配置子路由，通过设置父页面容器和子页面的关联，来实现子页面的加载和渲染。"},{"t":"h2","c":"父页面的路由监听"},{"t":"p","c":"在某些情况下，多个页面共用同一个父页面作为容器，当这些页面之间进行跳转时，父页面不会被刷新。这种情况下，父页面仍然可以监听路由的变动，以便在不刷新页面的情况下执行相应的操作。"},{"t":"h3","c":"监听路由变动"},{"t":"p","c":"父页面模块可以设置一个 routerChange 函数，用于监听路由的变动。当页面发生路由切换且不刷新父页面时，将触发 routerChange 事件。这个事件会传递当前页面的信息，以及跳转的方式（type）。"},{"t":"p","c":"以下是一个父页面模块的示例，展示了如何设置 routerChange 函数来监听路由变动："},0,{"t":"p","c":"在上述示例中，routerChange 函数接收两个参数，current 表示当前页面的地址，type 表示跳转的方式。当页面发生路由切换时，该函数会被触发，并输出相应的信息。"}],"o-router":[{"t":"h1","c":"o-router 组件的使用"},{"t":"p","c":"o-router 组件是一个用于将 o-app 内的路由绑定到当前浏览器标签页的组件，它能够帮助你更方便地管理页面路由和展示。"},{"t":"h2","c":"加载 o-router 组件"},{"t":"p","c":"首先，你需要在页面中引用 o-router 组件。你可以通过以下方式引用 router.mjs 文件："},0,{"t":"h2","c":"使用 o-router 组件"},{"t":"p","c":"使用 o-router 组件是通过将其包裹在 o-app 组件外部来实现的。这样可以将应用内的路由绑定到当前浏览器标签上。"},0,{"t":"h2","c":"fix-body 属性"},{"t":"p","c":"o-router 组件还提供了 fix-body 属性，当你设置了该属性后，组件会自动为 <html> 标签添加样式，使应用的尺寸等于页面的大小，从而让应用的内容充满整个窗口。"},0],"scsr":[{"t":"h1","c":"静态客户端渲染(SCSR)"},{"t":"h2","c":"什么是 SCSR？"},{"t":"p","c":"SCSR 全名 Static Client-Side Rendering，称为静态客户端渲染；静态客户端渲染（SCSR）是 CSR（Client-Side Rendering）的一种变种，它在保留了 CSR 用户体验的基础上，还能够让页面在静态状态下被爬虫获取。"},{"t":"h2","c":"如何使用 SCSR"},{"t":"p","c":"你可以通过以下方式引用 SCSR 库："},0,{"t":"h2","c":"SCSR 的工作原理"},{"t":"p","c":"SCSR 是通过直接运行单文件模式的页面模块，而无需使用 o-page 标签，从而实现在页面上进行渲染。具体来说，就是将页面模块的模板代码直接放在 o-app 内。"},{"t":"p","c":"以下是一个 SCSR 示例，展示了如何在页面上直接渲染页面模块的内容："},0,{"t":"p","c":"通过 SCSR，template 标签内的内容会被直接渲染到页面上，而这部分内容实际上就是单文件模式的页面模块。"},{"t":"p","c":"继续以上面的 home.html 页面为例，我们创建一个 help 页面："},0,{"t":"p","c":"在 home.html 页面中点击 \"GO TO HELP\" 后，将平滑跳转到 help.html 页面，实现了客户端渲染的平滑跳转效果。"},{"t":"h2","c":"注意事项"},{"t":"p","c":"所有采用 SCSR 方案的页面，除页面描述性的内容（如 title、meta:description、keywords）和页面模板内容外，其他引用资源必须保持一致，以确保在页面跳转和刷新后的体验一致。"},{"t":"h2","c":"关于 SSR 方案"},{"t":"p","c":"当前的 SCSR 方案实际上更类似于一种 SSG（Static Site Generation）方案，因为它将页面预先渲染成静态内容，然后再通过客户端进行交互。ofa.js 已经提供了相对独立的组件封装方案，使得前端开发人员可以将组件封装好，然后结合传统的后端渲染页面方案（如 Node.js、Go、Java、PHP 等语言的网站渲染框架），后端开发人员可以快速使用这些封装好的组件来构建优质的网页。"},{"t":"p","c":"我们计划在未来提供一个完整的 SSR（Server-Side Rendering）方案。这个方案的原理大致是先获取下一页的元素内容，然后与当前页的标签内容进行对比，从而进行动态的增加、删除和修改属性值等操作。不过需要注意的是，这个 SSR 方案会比较耗费时间，因为这个过程涉及到复杂的元素比较和修改操作。"},{"t":"p","c":"ofa.js 是一个新兴的框架，而且作者的业余时间也有限，暂时还没有完整开发出这个 SSR 方案。但如果未来 ofa.js 能够得到更多的用户使用，并且出现了对于 SSR 方案的强烈需求时，作者会继续完善并开发这个方案。目前，作者会专注于框架的稳定性和功能扩展，同时也欢迎用户的反馈和建议，以便未来更好地满足用户的需求。"}]},"others":{"about-micro-frontend":[{"t":"h1","c":"关于微前端"},{"t":"p","c":"微前端是一种前端架构模式，旨在帮助团队更好地构建和维护大型、复杂的前端应用程序。它借鉴了微服务架构的思想，将前端应用程序拆分为更小的独立部分，每个部分都可以由不同的团队开发、测试和部署。"},{"t":"p","c":"在传统的单体前端应用不断扩展的过程中，可能会变得难以维护和扩展。微前端的目标是通过将应用拆分成更小、更可管理的模块，使得开发团队能够独立地开发和部署这些模块，从而提高团队的效率和应用的可维护性。"},{"t":"p","c":"ofa.js 天生具备微前端的特性，它与其它框架的不同之处在于，基于 ofa.js 开发的组件、页面和应用无需预编译。相比于一些框架如 React、Vue 和 Angular 等，它们需要在 Node.js 环境下进行一次构建，生成用于客户端的代码。然而，ofa.js 的开发代码可以直接放置在静态服务器上，无需额外的构建步骤，就能实时查看、使用和运行。"},{"t":"p","c":"ofa.js 符合了微前端的特点："},{"t":"l","c":"1. 独立部署：每个组件和页面都可以独立地开发、测试和部署，这使得团队能够更迅速地发布新功能和解决问题。\n\n2. 集成：基于 ofa.js 开发的应用，可以将不同的模块组合在一起。这可以通过应用、页面、组件等方式共享组合。\n\n3. 独立团队：每个前端模块（组件/页面/应用）可以由独立的团队进行开发和维护，从而鼓励团队的自主性和创新。\n\n4. 共享资源：在 ofa.js 项目中，通常会存在一些共享的资源，如样式、组件、页面等，以确保一致性和效率。\n\n5. 按需加载：ofa.js 的应用可以根据需要加载模块，从而提升应用的性能和加载速度。"},{"t":"p","c":"尽管 ofa.js 无法直接使用 Vue 和 React 等框架开发的组件，但基于 ofa.js 开发的组件可以被 Vue 和 React 使用，这为不同技术栈的开发人员提供了更强的灵活性和扩展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 将 Vue 与 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 与 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 将 Web Components 集成到 React 中"}],"data-sharing":[{"t":"h1","c":"数据共享"},{"t":"p","c":"ofa.js与其他第三方框架不同，不采用传统的状态管理模式。作者认为状态更新应该是无感知的，即改变数据后应自动触发数据更新。"},{"t":"p","c":"ofa.js天生就具备出色的数据共享能力，它的实例基于数据共享库 Stanz 进行开发。实例上的对象都是可同步的。如果要实现数据共享，只需创建一个独立的 Stanz 对象，然后让所有组件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享数据："},0,0,0,0,{"t":"p","c":"在上述示例中，两个组件在 attached 生命周期时，将数据写入到组件本身。然后，组件的 obj 就成为共享数据。在 detached 生命周期后，将之前共享的数据设置为 null，以确保数据得到回收。"},{"t":"h2","c":"注意事项"},{"t":"p","c":"由于数据是共享的，务必要确保在适当的时候回收数据，以避免内存泄漏。"},0]}},"api":{"index":[{"t":"h1","c":"API 介绍"},{"t":"p","c":"以下是 ofa.js API 的概览，你可以先浏览一遍，以备将来需要时再来查阅详细文档："},{"t":"h2","c":"实例相关"},{"t":"l","c":"- $：主要用于获取实例的方法\n- all：获取所有相关实例\n- prev：获取目标元素的前一个实例\n- prevs：获取目标元素前面的所有实例\n- next：获取目标元素的后一个实例\n- nexts：获取目标元素后面的所有实例\n- siblings：获取目标元素的所有相邻元素实例\n- parent：获取父元素实例\n- parents：获取所有父元素的实例集\n- clone：克隆实例的方法\n- ele：获取实例的实际原生元素\n- shadow：获取自定义组件的影子根节点\n- root：获取目标实例的根节点\n- 子元素：通过数字直接获取子元素\n- host：获取目标的 app 元素实例"},{"t":"h2","c":"节点操作"},{"t":"l","c":"- 添加或删除子节点\n- before：在目标实例的前面添加元素\n- after：在目标实例的后面添加元素\n- remove：删除目标元素\n- wrap：将目标元素上包裹一层元素\n- unwrap：将目标元素去除包裹的元素"},{"t":"h2","c":"属性操作"},{"t":"l","c":"- text：获取或设置目标元素的文本\n- html：获取或设置目标元素的 HTML 代码\n- attr：获取或设置目标元素的 attributes\n- css：获取或设置目标元素的样式\n- style：获取目标元素的原生样式\n- classList：获取目标元素的原生 class 列表\n- data：获取目标元素的原生数据集"},{"t":"h2","c":"事件相关"},{"t":"l","c":"- on：绑定事件到目标元素\n- one：一次性绑定事件到目标元素\n- emit：主动触发事件\n- off：解除绑定的事件"},{"t":"h2","c":"模板语法"},{"t":"l","c":"- 文本渲染：快速在模板文件上渲染文本\n- class：快速在模板文件上渲染类名\n- sync：快速同步数据到模板文件\n- 条件渲染：按需在模板文件上渲染内容\n- 列表渲染：在模板文件上快速渲染数组数据"},{"t":"h2","c":"生命周期"},{"t":"l","c":"- created：组件被创建，但未渲染内容时触发\n- ready：组件被创建，内容被渲染后触发\n- watch：组件初始化完成后和值被改变后触发\n- loaded：组件内嵌资源被加载完成后触发\n- attached：组件被添加到 document 后触发\n- detached： 组件从 document 被移除后触发\n- routerChange：内嵌的父页面在应用路由改变时触发"},{"t":"h2","c":"其他"},{"t":"l","c":"- 盒模型：获取目标元素的所有尺寸相关的数据\n- formData：方便地绑定和获取表单数据\n- tag：获取目标的标签名\n- index：获取目标元素在其父元素下的排序\n- is：判断目标元素是否匹配 CSS 选择器表达式\n- refresh：主动刷新组件的界面\n- PATH：获取组件或页面的注册文件地址\n- extend：扩展实例的数据或方法；扩展 ofa.js 底层的数据或方法；\n- 实例数据特征：介绍实例数据的子对象数据特性，如何监听数据的变动"}],"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"$ 方法 是 ofa.js 中的核心函数，用于操作 DOM 元素实例。下面将介绍 $ 的主要作用："},{"t":"h2","c":"获取元素实例"},{"t":"p","c":"通过 $ 方法，你可以获取页面上符合css选择器的第一个元素实例，并对其进行操作。以下是一个示例："},0,0,0,0,{"t":"p","c":"在上面的示例中，我们使用 $ 符号选择了具有 id 为 \"target1\" 的元素实例，并通过设置 text 属性来修改其文本内容。"},{"t":"h2","c":"查找子元素实例"},{"t":"p","c":"实例也拥有 $ 方法，可以通过实例上的 $ 方法获取元素实例的第一个符合条件的子元素实例。"},0,0,0,0,{"t":"h2","c":"元素实例特性"},{"t":"p","c":"请不要将获取的元素实例直接插入到其他地方，这样的操作会导致原来的元素受到影响。如果需要创建一份副本，您可以使用 clone 方法。"},0,0,0,0,{"t":"h2","c":"获取影子节点内的子元素"},{"t":"p","c":"可以通过 shadow 属性获取实例后，在通过 $ 方法获取想要的元素；"},0,{"t":"h2","c":"直接实例化元素"},{"t":"p","c":"你可以通过以下方式直接将原生元素初始化为 $ 实例对象："},0,0,{"t":"p","c":"这样，你可以方便地将现有的 HTML 元素转换为 $ 实例，以便使用 $ 提供的功能进行操作和处理。"},{"t":"h2","c":"生成元素实例"},{"t":"p","c":"除了获取现有的元素实例，$ 还可以用于创建新的元素实例，并将其添加到页面中。"},{"t":"h3","c":"通过字符串生成"},{"t":"p","c":"你可以使用 $ 函数通过字符串创建新元素实例，如下所示："},0,0,0,0,{"t":"p","c":"在这个示例中，我们使用 $ 函数创建了一个具有指定样式和文本内容的新元素实例，并将其添加到具有 id 为 \"target1\" 的现有元素实例内。"},{"t":"h3","c":"通过对象生成"},{"t":"p","c":"你还可以使用 $ 函数通过对象的方式生成新元素实例，如下所示："},0,0,0,0,{"t":"p","c":"在这个示例中，我们使用 $ 函数通过对象的方式定义了一个新元素实例，包括标签类型、文本内容和样式属性，并将其添加到具有 id 为 \"target1\" 的现有元素实例内。"}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"使用 all 方法，你可以获取页面上符合 CSS 选择器 的所有元素，并返回一个数组包含这些元素。"},0,0,0,0,{"t":"h2","c":"获取子元素"},{"t":"p","c":"实例也拥有 all 方法，可以通过实例上的 all 方法选择并获取子元素。"},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"使用 prev 属性，你可以获取元素的前一个相邻元素实例。"},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"使用 prevs 属性，您能够轻松获取当前元素之前的所有相邻元素实例，这些元素将以数组的形式返回。"},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"使用 next 属性，你可以获取元素的后一个相邻元素实例。"},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"使用 nexts 属性，您能够轻松获取当前元素后面的所有相邻元素实例，这些元素将以数组的形式返回。"},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"使用 siblings 属性，您能够轻松获取当前元素的所有相邻元素实例，这些元素将以数组的形式返回。"},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"使用 parent 属性，您可以获得实例的父元素实例；"},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"使用 parents 属性，您能够轻松获取当前元素的所有父元素实例，这些元素将以数组的形式返回。"},0,0,0,0],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"使用 shadow 属性，你可以获取元素的影子根节点实例。"},0,0,0,{"t":"p","c":"需要注意的是，避免在具有模板语法的元素内直接修改影子节点内的元素，以确保操作的一致性和可维护性。"},{"t":"h2","c":"从外部获取组件影子元素内的元素实例"},{"t":"p","c":"您还可以从外部获取自定义元素实例，然后通过 shadow 属性访问影子节点内的元素，如下所示："},0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"通过 ele 属性，你可以获取实例的实际元素，从而使用原生的属性或方法。"},0,0,0,0,{"t":"p","c":"在上面的示例中，我们使用 ele 属性获取了一个元素，并修改了其内部的 HTML 内容，以及用于记录的元素的 tagName。这使得你可以结合原生 JavaScript 方法对元素进行更复杂的操作。"}],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"使用 clone 方法可以克隆并生成一份元素实例；"},0,0,0,0],"root":[{"t":"h1","c":"root"},{"t":"p","c":"使用 root 属性获取元素的根节点；"},{"t":"p","c":"在页面上，普通元素的根节点都是 document 实例；"},0,0,0,0,{"t":"h2","c":"在影子节点内的元素"},{"t":"p","c":"由于组件内元素，是与外部环境隔离的，影子节点内的元素的 root 属性就是影子根节点；"},0,0,0],"children":[{"t":"h1","c":"子元素"},{"t":"p","c":"获取子元素实例非常简单，你只需要将实例当作数组，通过数字获取它的子元素实例。"},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"获取目标元素的子元素数量；案例如上所示；"},0],"host":[{"t":"h1","c":"host"},{"t":"p","c":"使用 host 属性，可以获取元素的宿主组件实例。这对于在组件内部访问其宿主组件的数据和方法非常有用。"},{"t":"p","c":"下面是一个示例，演示如何使用 host 属性获取宿主组件的实例："},0,0,0,{"t":"p","c":"在这个示例中，我们创建了一个自定义组件 host-demo，并在组件内部访问了它的宿主组件实例，然后比较了它们是否相等。"},{"t":"p","c":"如果元素不在组件内，host 的值将为 null。例如："},0,0,0,0,{"t":"p","c":"在这个示例中，#target 元素在 body下，不在任何组件或页面内，所以 $(\"#target\").host 的值为 null。"}],"app":[{"t":"h1","c":"app"},{"t":"p","c":"在 o-app 内的元素，包括在 o-app 内的 o-page 的影子节点内的元素，或者再内部的子组件，它们的 app 属性都是指向这个 o-app 的元素实例。"},{"t":"p","c":"以下是一个示例，演示了如何在 o-app 内的元素中访问 app 属性："},0,{"t":"p","c":"代码如下："},0,0,0,{"t":"p","c":"在上述示例中，o-app 元素的 app 属性包含了 o-page 元素和 test-comp 自定义组件内的元素。这意味着它们都可以通过 app 属性访问到 o-app 元素的数据和方法。"}]},"operation":{"array-like":[{"t":"h1","c":"添加或删除子元素"},{"t":"p","c":"元素实例拥有类似数组的特性，添加或删除节点只需要使用数组那几个操作方法即可；其中使用 push、unshift、pop、shift、splice 方法时，内部会自动执行 $ 方法 的初始化操作，所以可以直接填写具体的元素字符串或对象。"},{"t":"p","c":"同样的，您也可以使用其他数组方法，例如 forEach、map、some 等等。"},{"t":"p","c":"请注意，在具有模板语法的元素上不要添加或删除子元素。"},{"t":"h2","c":"push"},{"t":"p","c":"从末尾添加子元素。"},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"在数组的开头添加子元素。下面是一个示例："},0,0,0,0,{"t":"h2","c":"pop"},{"t":"p","c":"从末尾删除子元素。"},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"在数组的开头删除子元素。"},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"可以删除或替换现有子元素，也可以添加新子元素。其使用方式与数组的 splice 方法相似。下面是一个示例："},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"before 方法用于向目标元素的前面添加元素。在执行 before 操作之前，会自动执行 $ 方法 的初始化操作，因此可以直接填写具体的元素字符串或对象。"},{"t":"p","c":"请注意，在具有模板语法的元素上不要操作元素。"},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"after 方法用于向目标元素的后面添加元素。在执行 after 操作之前，会自动执行 $ 方法 的初始化操作，因此可以直接填写具体的元素字符串或对象。"},{"t":"p","c":"请注意，在具有模板语法的元素上不要操作元素。"},0,0,0,0],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"wrap 方法用于在目标元素的外部包裹一层元素。在执行 wrap 操作之前，会自动执行 $ 方法 的初始化操作，因此可以直接填写具体的元素字符串或对象。"},{"t":"p","c":"下面是一个示例："},0,0,0,0,{"t":"h2","c":"注意事项"},{"t":"p","c":"目标元素必须拥有父节点，否则包裹操作会失败。"},0,{"t":"p","c":"请注意，在具有模板语法的元素上不要操作元素。"}],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"删除目标节点；"},{"t":"p","c":"请注意，在具有模板语法的元素上不要操作元素。"},0,0,0,0],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"unwrap 方法用于在目标元素的移除一层外部包裹的元素。"},{"t":"p","c":"下面是一个示例："},0,0,0,0,{"t":"h2","c":"注意事项"},{"t":"p","c":"目标元素必须拥有父节点，否则包裹操作会失败。"},0,{"t":"p","c":"当拥有其他兄弟元素时，也不可以执行 unwrap；"},0,{"t":"p","c":"请注意，在具有模板语法的元素上不要操作元素。"}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"text 方法用于获取或设置元素的文本内容。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接获取或设置元素的文本内容。下面是一个示例："},0,0,0,0,{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以在模板内使用 :text 属性来向目标元素设置对应的属性值。这在组件的渲染中特别有用。下面是一个示例："},0,0,0],"html":[{"t":"h1","c":"html"},{"t":"p","c":"设置目标内部的 html 代码；"},0,0,0,0,{"t":"h2","c":"注意事项"},{"t":"p","c":"html 是个比较危险的方法，被塞入 script 也会自动执行内部的 javascript 代码，使用时注意预防 XSS；"},{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以在模板内使用 :html 属性来向目标元素设置对应的属性值。这在组件的渲染中特别有用。下面是一个示例："},0,0,0],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"attr 方法用于获取或设置元素的 attributes。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接使用 attr 方法获取或设置元素的属性。下面是一个示例："},0,0,0,0,{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以在模板内使用 attr:aaa=\"bbb\" 方式，将目标元素的 aaa 属性设置为组件 bbb 的值。这种方法对于组件渲染特别有用。下面是一个示例："},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"css 方法用于获取或设置目标元素的样式。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接使用 css 方法来获取或设置元素的样式。下面是一个示例："},0,0,0,0,{"t":"h2","c":"全量设置"},{"t":"p","c":"通过获取的 css 对象，你可以得到直接设置在元素上的 style 值。下面是一个示例："},0,0,0,0,{"t":"p","c":"使用 css 对象的特性，你可以快速地调整目标元素的样式。"},{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以通过模板语法来设置目标元素的样式。下面是一个示例："},0,0,0,{"t":"h2","c":"设置 css 的技巧"},{"t":"p","c":"你可以通过 $ele.css = {...$ele.css, color:'red'} 的方式来修改元素的某个样式属性，而不影响其他样式属性。这种方式可以在不重写整个样式的情况下，只修改其中一个属性。"},{"t":"h3","c":"示例"},0,{"t":"p","c":"在上面的示例中，通过使用 { ...myElement.css, color: 'red' }，我们只修改了元素的颜色样式，而将其他样式属性保持不变。这是一个很方便的技巧，可以灵活地修改元素的样式。"}],"style":[{"t":"h1","c":"style"},{"t":"p","c":"使用 style 属性和原生保持一致；"},{"t":"p","c":"请注意，style 属性无法获取样式的实际值，而只能获取在 style 属性上设置的值。尽管 style 方法与 css 方法 类似，但它无法进行全量样式覆盖。相较于 css，style 方法的内部执行效率更高。"},{"t":"p","c":"下面是一个示例，演示了如何使用 style："},0,0,0,0,{"t":"p","c":"请记住，style 方法只获取和设置 style 属性上的值，而不是实际的计算样式。"}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"classList 属性和原生保持一致；"},{"t":"p","c":"下面是一个示例，演示了如何使用 classList："},0,0,0,0,{"t":"p","c":"classList 属性允许你轻松地添加、删除和切换类名，以便动态更改元素的样式。有关更多操作方法，请查阅 classList。"}],"data":[{"t":"h1","c":"data"},{"t":"p","c":"获取元素的 dataset，使用 data 属性和原生 dataset 保持一致；"},0,0,0,0]},"event":{"on":[{"t":"h1","c":"on"},{"t":"p","c":"使用 on 方法，你可以为目标元素注册事件处理程序。这使你能够轻松地捕获和响应用户的交互操作。"},{"t":"p","c":"下面是一个示例，演示如何使用 on 方法为按钮元素注册点击事件处理程序："},0,0,0,0,{"t":"p","c":"在这个示例中，我们使用 on 方法为按钮元素添加了一个点击事件处理程序。当用户点击按钮时，会触发事件处理程序，计数器将递增并将结果显示在页面上。"},{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以使用模板语法来为目标元素绑定方法。下面是一个示例："},0,0,0,{"t":"p","c":"在这个示例中，我们在按钮元素上使用 on:click 绑定了一个名为 addCount 的方法。当用户点击按钮时，这个方法将被调用，计数器的值将递增并在页面上显示。这种方式使你可以将事件处理程序与组件的方法关联，实现更复杂的交互。"},{"t":"h2","c":"event"},{"t":"p","c":"在注册时间后，触发的函数会被带上 event，和原生保持一致；"},0,0,0,0],"one":[{"t":"h1","c":"one"},{"t":"p","c":"使用 one 方法，你可以为目标元素注册一次性事件处理程序，这意味着事件处理程序将在第一次触发后自动解除绑定，不会再次触发。"},{"t":"p","c":"下面是一个示例，演示如何使用 one 方法为按钮元素注册点击事件处理程序："},0,0,0,0,{"t":"p","c":"在这个示例中，我们使用 one 方法为按钮元素添加了一个点击事件处理程序。当用户点击按钮时，事件处理程序会触发，但之后不会再次触发，因为它已被解除绑定。"},{"t":"h2","c":"模板语法方式使用"},{"t":"p","c":"你还可以使用模板语法来为目标元素绑定一次性事件处理程序。下面是一个示例："},0,0,0,{"t":"p","c":"在这个示例中，我们在按钮元素上使用 one:click 绑定了一个名为 addCount 的方法。当用户点击按钮时，这个方法将被调用，但之后不会再次触发，因为它是一次性事件处理程序。"}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"使用 emit 方法，你可以主动触发事件，而且触发的事件具有冒泡机制。冒泡机制意味着事件从内部元素冒泡到外部元素，从内到外的层级触发事件。"},{"t":"p","c":"下面是一个示例，演示如何使用 emit 方法触发自定义事件并利用冒泡机制传递事件到外部元素："},0,0,0,0,{"t":"p","c":"在这个示例中，我们为 <ul> 元素和 <li> 元素分别注册了相同的自定义事件 custom-event 处理程序。当我们使用 emit 方法触发事件时，该事件从 <li> 元素冒泡到 <ul> 元素，触发了两个事件处理程序。"},{"t":"h2","c":"自定义数据"},{"t":"p","c":"通过带上 data 参数，你可以传递自定义数据给事件处理程序："},0,0,0,0,{"t":"p","c":"在这个示例中，我们通过 data 参数传递了自定义数据给事件处理程序。事件处理程序可以通过 event.data 获取传递的数据。"},{"t":"h2","c":"不冒泡触发事件"},{"t":"p","c":"如果你不希望事件冒泡，你可以在触发事件时带上 bubbles: false 参数："},0,0,0,0,{"t":"p","c":"在这个示例中，我们使用 bubbles: false 参数触发了自定义事件。这个事件不会冒泡到上层元素，所以只有 <li> 元素的事件处理程序被触发。"},{"t":"h2","c":"穿透根节点"},{"t":"p","c":"默认情况下，事件不会穿透自定义组件的影子 DOM。但你可以通过设置 composed: true 让自定义事件穿透根节点，触发根节点之外的元素。"},0,0,0,0,0,{"t":"p","c":"在这个示例中，我们创建了一个自定义组件 composed-test，它包含一个影子 DOM 中的元素和一个触发事件的按钮。默认情况下，事件不会穿透影子 DOM 到根节点。但是，通过在事件触发时使用 composed: true 参数，我们让事件穿透到了根节点，触发了根节点外的元素。"}],"off":[{"t":"h1","c":"off"},{"t":"p","c":"使用 off 方法可以注销已注册的事件处理程序，以取消对事件的监听。"},{"t":"p","c":"下面是一个示例，演示如何使用 off 方法取消事件监听："},0,0,0,0,{"t":"p","c":"在这个示例中，我们注册了一个点击事件处理程序 f，当按钮被点击时，事件处理程序会在 #logger 中显示点击次数。使用 off 方法，我们在点击次数达到3时取消了事件的监听。"}]},"temp-syntax":{"text-render":[{"t":"h1","c":"文本渲染"},{"t":"p","c":"你可以使用两个包裹的大括号的形式 {{xxx}} 在模板内渲染文本，其中 xxx 是组件或页面自身的属性。这允许你将属性的值直接渲染到页面上。"},{"t":"p","c":"以下是一个示例，演示了如何在模板中渲染文本："},0,0,0,{"t":"p","c":"在这个示例中，{{txt}} 将会被属性 txt 的值替代，最终呈现在页面上。"}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"通过 sync 语法对组件进行双向数据绑定"},0,0,0,{"t":"p","c":"sync 还可以和内嵌的组件实例属性进行绑定，案例请查看双向数据绑定；"}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"你可以通过 class 语法快速切换模板内的 class 名。在 class:aaa=\"bbb\" 中，当 bbb 表达式(或组件自身的 bbb 属性)为 true 时，会为目标元素添加 aaa 这个 className。"},{"t":"p","c":"请注意，className 不能包含大写字母，请使用 - 作为分隔符。"},{"t":"p","c":"以下是一个示例，演示了如何使用 class 语法在模板中切换元素的 class 名："},0,0,0,{"t":"h2","c":"直接使用 class"},{"t":"p","c":"你可以使用 class 方法来直接调整元素的 className。在下面的示例中，演示了如何使用 class 方法来动态添加和删除类名："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先通过 class 方法将 color-red 类添加到元素上，然后在一秒后将其移除，再过半秒后将 color-blue 类添加到元素上。这会动态更改目标元素的样式。"},{"t":"p","c":"我们建议使用 classList 属性来操作类名，因为这是更常见和标准的方法。"}],"condition":[{"t":"h1","c":"条件渲染"},{"t":"p","c":"条件渲染是通过三个条件组件来实现的："},{"t":"h2","c":"x-if"},{"t":"p","c":"x-if 是主要的判断组件，需要设置 value 值。如果 value 的条件满足，它会显示包裹的内容。"},{"t":"h2","c":"x-if-else"},{"t":"p","c":"x-if-else 可以跟在 x-if 或 x-if-else 后面，需要设置 value 值。如果前面的条件组件不满足，且自身的 value 为 true，它会显示包裹的内容。"},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else 可以跟在 x-if 或 x-if-else 后面，放在最后。如果前面的条件都不满足，它会显示自身包裹的内容。不需要设置 value 值。"},{"t":"h2","c":"示例"},0,0,0,{"t":"p","c":"在示例中，使用了这些条件渲染组件来根据 count 的值选择要显示的内容。当 count 能被 3 整除时，x-if 条件满足，显示红色的文本；当 (count + 1) 能被 3 整除时，x-if-else 条件满足，显示绿色的文本；否则，显示蓝色的文本。"}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"使用 x-fill 组件来进行列表渲染；设置 value 属性来填充数组数据。"},{"t":"p","c":"在 x-fill 内部，可以使用特殊变量 $index 代表当前列表项的索引，以及 $data 代表列表项本身的数据。"},{"t":"p","c":"下面是一个示例，演示了如何使用 x-fill 渲染一个数组："},0,0,0,{"t":"p","c":"在这个示例中，我们将 x-fill 组件用于渲染数组 arr，并在每个列表项中显示索引和数据。"},{"t":"h2","c":"模板列表渲染"},{"t":"p","c":"你可以使用模板元素template并添加 name 属性，来定制组件内的临时模板。在 x-fill 使用时，使用 name 属性指定要填充的模板名。"},{"t":"p","c":"下面是一个示例，演示了如何使用模板列表渲染："},0,0,0,{"t":"p","c":"在这个示例中，我们创建了一个名为 \"easyLi\" 的模板，然后使用 x-fill 填充了数组 arr 的数据，并在每个列表项中显示索引和数据的名称。"},{"t":"h2","c":"嵌套列表渲染"},{"t":"p","c":"在进行嵌套列表渲染时，从第二层开始，必须使用模板来填充。这样的设计是为了避免多层嵌套的列表渲染代码变得复杂。"},{"t":"p","c":"下面是一个示例，演示了如何进行嵌套列表渲染："},0,0,0,{"t":"p","c":"在这个示例中，我们有一个数组 arr，其中包含了两个对象。每个对象都有一个 name 属性，以及一个可能包含嵌套子项的 childs 属性。我们使用 x-fill 来填充列表，并使用模板 \"easyLi\" 渲染子项。如果某项具有子项，我们使用 x-if 来检查并创建嵌套的列表。"},{"t":"h2","c":"递归列表渲染"},{"t":"p","c":"模板渲染还可以进行递归渲染，这对于构建树形结构的列表非常有用。"},{"t":"p","c":"下面是一个演示如何进行递归列表渲染的示例："},0,0,0,{"t":"p","c":"在这个示例中，我们有一个数组 arr，其中包含了两个对象。每个对象都有一个 name 属性，以及一个可能包含嵌套子项的 childs 属性。我们使用 x-fill 来填充列表，并使用模板 \"easyLi\" 渲染子项。如果某项具有子项，我们使用 x-fill 来递归渲染子列表，实现了递归列表渲染。"},{"t":"h2","c":"replace-temp"},{"t":"p","c":"有时候，当我们尝试列表渲染到 select 或 table 内，浏览器可能会自动移除 <x-fill> 元素，导致无法正常进行列表渲染。在这种情况下，可以使用 replace-temp 的方式进行渲染。使用 replace-temp 的方法是，在一个 <template> 标签中设置 is=\"replace-temp\"，并将这个模板放在浏览器会自动修正的元素内。"},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created 生命周期钩子在组件创建时被触发。在此阶段，组件的数据尚未被初始化，模板内容也未被渲染。你可以在这个阶段执行一些初始化操作，或者准备在后续阶段使用的数据。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"ready 生命周期钩子会在组件的数据和模板刚被初始化后触发，表示组件已经准备就绪。在这个阶段，你可以访问组件的数据，并且模板已经渲染完成，可以执行一些与界面交互相关的操作。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"一旦 ready 阶段完成，与之关联的 watch 对象中的监听函数会被触发一次。随后，当数据的某个值发生变动时，会再次触发相应键（key）的监听函数。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"loaded 生命周期钩子在组件模板内的所有依赖都加载完成后触发。这个阶段确保在渲染组件之前，所有的依赖都已经加载完毕。这个时候适合去除在 ready 阶段添加的Loading样式。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"attached 生命周期钩子会在组件被添加到文档中时触发。在这个阶段，适合获取组件内元素的尺寸相关信息，进行数据绑定和全局事件的操作。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"detached 生命周期钩子会在组件从文档中移除时触发。在这个阶段，你可以执行一些清理操作，比如取消事件监听或者释放资源，以防止内存泄漏。"},{"t":"h2","c":"示例代码"},0,0,0,0,0,{"t":"h2","c":"生命周期流程图"},0],"router-change":[{"t":"h1","c":"routerChange 事件"},{"t":"p","c":"routerChange 事件是一个特定于 o-page 元素的事件，它只会在 o-page 的嵌套父页面上触发。此事件在应用路由发生变化时被触发，无论是跳转到新页面还是返回到先前的页面。"},{"t":"p","c":"它提供了一种方式来监听和响应应用程序的路由变化，通常在嵌套页面的父页面中使用。当路由发生变化时，可以监听 routerChange 事件以执行相应的操作，例如更新页面内容或导航状态。"},{"t":"p","c":"这个事件对于构建具有多个嵌套页面的应用程序非常有用，它使得在页面之间导航和通信变得更加容易。"},{"t":"h2","c":"示例"},{"t":"p","c":"跳转到嵌套页面查看；"}]},"others":{"page":[{"t":"h1","c":"o-page 组件"},{"t":"p","c":"o-page 是 ofa.js 中的核心组件之一，代表着一个独立的页面或页面模块。以下是 o-page 的一些关键属性和方法："},{"t":"h2","c":"src 属性"},{"t":"p","c":"src 属性用于指定页面模块的具体地址。这是指定页面内容和行为的关键属性，告诉应用程序从哪里加载特定页面的内容。"},0,{"t":"h2","c":"goto 方法"},{"t":"p","c":"goto 方法用于从当前页面跳转到另一个页面。相比较于 app 的 goto 方法，page 的 goto 方法可以使用相对地址来导航到其他页面。"},0,{"t":"h2","c":"replace 方法"},{"t":"p","c":"replace 方法用于替换当前页面为另一个页面。这与 app 的 replace 方法类似，但是在页面内进行替换操作。"},0,{"t":"h2","c":"back 方法"},{"t":"p","c":"back 方法用于返回到前一个页面。这会导航用户回到上一个页面，类似于浏览器的后退操作。"},0],"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app 是 ofa.js 中的核心组件之一，用于配置和管理整个应用程序。以下是app的一些关键属性和方法："},{"t":"h2","c":"src"},{"t":"p","c":"src 属性用于指定应用参数配置模块的具体地址。有关详细示例，请参考 案例。"},0,{"t":"h2","c":"current"},{"t":"p","c":"current 属性用于获取正在展示中的页面实例。这可以帮助您访问和操作当前正在显示的页面，例如更新其内容或执行特定的操作。"},0,{"t":"h2","c":"goto"},{"t":"p","c":"goto 方法用于跳转到指定的页面。您可以传递目标页面的地址，应用将加载并显示该页面。这是应用导航的重要方法。"},0,{"t":"h2","c":"replace"},{"t":"p","c":"replace 方法与 goto 类似，但它是用来替换当前页面而不是在堆栈中添加新页面。这可以用于实现页面替换而不是堆栈导航。"},0,{"t":"h2","c":"back"},{"t":"p","c":"back 方法用于返回上一页，实现页面导航的后退操作。这会将用户导航回上一个页面。"},0,{"t":"h2","c":"routers"},{"t":"p","c":"routers 属性包含应用程序的路由配置信息。这是一个重要的属性，定义了应用程序中各个页面的路由规则和映射。路由配置决定了页面之间的导航和如何处理 URL。"},0],"box":[{"t":"h1","c":"盒模型"},{"t":"p","c":"在网页开发中，元素的尺寸是一个重要的概念，它包括了内容区域、内边距、边框和外边距。以下是一些表示元素尺寸的相关属性："},{"t":"h2","c":"width"},{"t":"p","c":"width 表示元素的内容区域的宽度，它不包括内边距、边框和外边距。"},{"t":"h2","c":"height"},{"t":"p","c":"height 表示元素的内容区域的高度，它不包括内边距、边框和外边距。"},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidth 表示元素的可见内容区域的宽度，包括内边距，但不包括边框和外边距。"},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeight 表示元素的可见内容区域的高度，包括内边距，但不包括边框和外边距。"},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"offsetWidth 表示元素的整体宽度，包括内容区域、内边距、边框和外边距。"},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"offsetHeight 表示元素的整体高度，包括内容区域、内边距、边框和外边距。"},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidth 表示元素的整体宽度，包括内容区"},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"formData 方法用于生成与表单元素绑定的对象数据，使得处理表单元素更加简单和高效。这个方法会生成一个对象，包含目标元素内所有表单元素的值，该对象会实时反映表单元素的改动。"},{"t":"p","c":"在下面的示例中，我们演示了如何使用 formData 方法生成与表单元素绑定的对象数据："},0,0,0,0,{"t":"p","c":"在这个示例中，我们创建了一个包含文本输入框、单选按钮和文本区域的表单，并使用 formData 方法创建了一个对象 data，该对象包含了这些表单元素的值。我们还使用 watch 方法来监视数据的变化，以及将数据实时显示在页面上。当用户修改表单元素的值时，data 对象会相应地更新，使得数据处理变得非常简单和高效。"},{"t":"h2","c":"反向数据绑定"},{"t":"p","c":"生成的对象数据同样具有反向的绑定能力，这意味着当你修改对象的属性时，相关的表单元素值也会自动更新。这在处理表单数据时非常有用，因为你可以轻松地实现双向数据绑定。"},{"t":"p","c":"在下面的示例中，我们演示了如何使用 formData 方法生成的对象数据，以及如何进行反向数据绑定："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先创建了一个包含文本输入框、单选按钮和文本区域的表单，然后使用 formData 方法生成了一个数据对象 data。随后，通过修改 data 对象的属性，我们实现了反向数据绑定，即表单元素的值会随着对象属性的更改而自动更新。这种双向数据绑定功能使得与表单数据的交互更加便捷。"},{"t":"h2","c":"监听特定的表单"},{"t":"p","c":"默认情况下，formData() 方法会监听目标元素内的所有 input、select 和 textarea 元素。但如果你只想监听特定的表单元素，可以通过传递 CSS 选择器 来实现。"},{"t":"p","c":"在下面的示例中，我们演示了如何通过传递 CSS 选择器来监听特定的表单元素："},0,0,0,0,{"t":"p","c":"在此示例中，我们只希望监听具有 class 为 \"use-it\" 的表单元素，因此我们传递了 \".use-it\" 作为参数给 formData() 方法。这样，只有带有该类名的表单元素会被监听和包括在生成的数据对象中。这对于选择性地监听表单元素非常有用，以便更精确地管理你的表单数据。"},{"t":"h2","c":"自定义表单"},{"t":"p","c":"自定义表单组件的使用非常简单，只需要为自定义组件添加一个 value 属性 并设置 name 特性。"},{"t":"p","c":"在下面的示例中，我们创建了一个名为 \"custom-input\" 的自定义表单组件。这个组件是一个可编辑的文本框，当文本发生变化时，它会实时更新其 value 属性。"},0,0,0,0,{"t":"p","c":"在你使用自定义表单组件时，你只需将它添加到你的表单中，并设置所需的 name 属性："},0,{"t":"p","c":"在上述示例中，我们通过添加 <custom-input> 元素并设置 name 属性来使用自定义表单组件。随后，我们使用 formData() 方法监听输入元素和自定义组件的值，以便实时获取和处理表单数据。这种方法可以让你非常方便地扩展你的表单，以包括自定义的表单组件，从而满足你的特定需求。"},{"t":"h2","c":"在组件或页面内使用表单数据"},{"t":"p","c":"有时，你可能需要在组件或页面内使用表单数据，并且需要在 ready 周期生命周期时生成数据并将其绑定到组件上。"},{"t":"p","c":"在下面的示例中，我们演示了如何在自定义组件内使用表单数据。这个组件包含一个文本输入框，当你输入内容时，它会实时更新日志中的数据。"},0,0,0,{"t":"p","c":"通过 ready 周期生命周期，在组件准备就绪后，我们使用 this.shadow.formData() 方法生成了表单数据对象 fdata。然后，我们使用 watch 监听 fdata 的变化，当数据发生变化时，将其转化为 JSON 字符串并更新 logtext，以实现实时显示表单数据的功能。"}],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"用于主动刷新组件的渲染视图，有时候组件上的数据没有更新时，可以使用该方法刷新组件的视图；"},0,0,0],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"tag 属性用于获取元素的标签，返回一个小写字符串。"},{"t":"p","c":"在下面的示例中，我们演示了如何使用 tag 方法来获取一个元素的标签："},0,0,0,0],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"PATH 属性通常用于自定义组件或页面组件上，用于获取该组件的注册组件的文件地址。这在开发过程中可以帮助你了解组件的来源，特别是当你需要引用或加载其他资源文件时，可以使用 PATH 属性来构建文件路径。"},{"t":"p","c":"下面是一个简单示例，演示如何在自定义组件中使用 PATH 属性："},0,{"t":"p","c":"在这个示例中，我们选择了一个具有 id 为 \"myCustomComponent\" 的 my-comp 元素，然后通过 PATH 属性获取了该自定义组件的文件路径。你可以根据需要在脚本部分使用 componentPath 变量，例如，用它来构建其他资源文件的路径或进行其他操作。"}],"index":[{"t":"h1","c":"index"},{"t":"p","c":"index 属性用于获取元素在其父元素下的位置。这个位置是从0开始计数的，也就是说第一个元素的位置是0，第二个是1，以此类推。"},{"t":"p","c":"在下面的示例中，我们演示了如何使用 index 属性来获取一个元素在其父元素下的位置："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先选中一个具有 id 为 \"target\" 的 <li> 元素。然后，我们使用 index 属性来获取该元素在其父元素 <ul> 下的位置，即第二个元素，所以 index 的值为1。然后将这个值显示在具有 id 为 \"logger\" 的 <div> 元素中。"}],"is":[{"t":"h1","c":"is"},{"t":"p","c":"用于检测元素是否符合表达式；"},0,0,0,0],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extend 是一个高阶方法，用于扩展实例的属性或方法；"},0,0,0,0,{"t":"h2","c":"扩展 $ 底层"},{"t":"p","c":"和 jQuery 类似，你也可以通过 fn.extend 扩展底层实例的属性或方法；从 fn 扩展的属性或方法会应用到所有实例上；"},0,0,0,0,{"t":"h2","c":"扩展模板语法"},{"t":"p","c":"通过 extend 扩展属性或函数，可以增加模板语法的功能，甚至为组件提供专属的模板语法糖。但需要注意的是，尽量不要使用非官方的模板语法，因为它们会给使用者带来一定的学习成本，并且大量非官方模板语法糖会降低开发体验。"},{"t":"h3","c":"扩展属性"},{"t":"p","c":"你可以通过扩展属性，在模板中使用 : 来进行设置。下面我们将扩展一个 red 属性，当 red 为 true 时，字体颜色变为红色："},0,0,0,0,0,{"t":"p","c":"在这个示例中，我们为模板语法添加了一个 red 属性，当 count % 3 不为 0 时，字体颜色将变为红色。"},{"t":"h3","c":"扩展方法"},{"t":"p","c":"你还可以通过 extend 扩展方法，使其在模板语法中可用。方法名称就是冒号前的部分。在这里，我们扩展了一个 color 模板语法，后面跟着的参数将被传递给定义的扩展方法。"},{"t":"p","c":"此处设置了 always 属性为 true，表示在组件每次需要刷新界面的时机时，都会调用这个定义好的方法。如果不设置 always，那么这个模板语法函数只会运行一次。"},{"t":"p","c":"其中，options 提供了更多的参数，可以帮助你开发更具定制性的模板语法；"},0,0,0,0,0,{"t":"h2","c":"模板语法原理"},{"t":"p","c":"到目前为止，你应该已经能够理解，ofa.js 上的许多模板语法实际上是通过 extend 扩展出来的："},{"t":"l","c":"- class、attr 方法每次刷新视图都会运行\n- on、one 这种函数绑定只会运行一次"},{"t":"p","c":"你可以查看下面的示例来更好地理解 ofa.js 的模板渲染原理："},0,0,0],"stanz":[{"t":"h1","c":"实例数据特征"},{"t":"p","c":"通过 $ 获取或创建的实例对象，拥有完整 stanz 数据特性，因为 $ 实例是从 stanz 继承而来的。这意味着你可以利用 stanz 提供的数据操作方法和特性来操作和监听实例对象的数据。"},0,{"t":"h2","c":"watch"},{"t":"p","c":"实例可以通过 watch 方法监听值的变动；即使改动了对象的子对象的值，也能在对象的 watch 方法中监听到变动。"},{"t":"p","c":"下面是一个示例，演示如何使用 $ 实例和 watch 方法："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先创建了一个 $ 实例对象 target，然后使用 watch 方法来监听它的变动。即使我们改动了对象的子对象的值，例如 target.bbb.child.val 的值，在 watch 方法中都能监听到这些变动并更新 logger 元素的内容。这展示了 $ 实例对象的强大特性，使你能够轻松监控对象的变化。"},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick 和 watch 方法功能类似，但 watchTick 内部有节流操作，它在单个线程下执行一次，因此在某些性能要求更高的场景下可以更有效地监听数据变动。"},{"t":"p","c":"下面是一个示例，演示如何使用 $ 实例的 watchTick 方法："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先创建了一个 $ 实例对象 target。然后，我们使用 watch 方法和 watchTick 方法来监听对象的变动。watch 方法会在数据变动时立即运行，而 watchTick 方法在单个线程下执行一次，因此能够限制监听操作的频率。你可以根据你的需求选择使用 watch 或 watchTick 方法来监听数据的变化。"},{"t":"h2","c":"unwatch"},{"t":"p","c":"unwatch 方法用于取消对数据的监听，可以撤销之前注册的 watch 或 watchTick 监听。"},{"t":"p","c":"下面是一个示例，演示如何使用 $ 实例的 unwatch 方法："},0,0,0,0,{"t":"p","c":"在这个示例中，我们首先创建了一个 $ 实例对象 target，然后使用 watch 方法和 watchTick 方法分别注册了两个监听。之后，通过 unwatch 方法传递之前保存的监听返回值 tid1 和 tid2 来撤销这两个监听。这意味着在第一个 setTimeout 中的属性改变不会触发任何监听，因为监听已被撤销。"},{"t":"h2","c":"不被监听的值"},{"t":"p","c":"在 $ 实例中，使用下划线 _ 开头的属性名表示这些值不会被 watch 或 watchTick 方法监听。这对于一些临时或私有的属性非常有用，你可以在不触发监听的情况下随意更改它们。"},{"t":"p","c":"下面是一个示例，演示了如何使用下划线开头的属性值来避免被监听："},0,0,0,0,{"t":"p","c":"在这个示例中，我们创建了一个 $ 实例对象 target，然后使用 watch 方法监听属性值的变动。在 setTimeout 中，我们尝试更改 _aaa 属性值，但这个更改不会触发监听。这对于需要在不触发监听的情况下更新属性值的情况非常有用。"},{"t":"h2","c":"基本特征"},{"t":"p","c":"设置在实例上的对象数据将被转换为 Stanz 实例，这种 Stanz 实例允许进行监听。"},0,{"t":"p","c":"我们还可以使用 $.stanz 来创建一个没有与实例绑定的 Stanz 数据。"},0,{"t":"p","c":"这些示例展示了将对象数据设置为 Stanz 实例以进行监听的基本特征。"},{"t":"p","c":"更多完整的特性请查阅 stanz；"}]}}}