{"cases":{"simple-component":[0,{"t":"h","c":"Creating and Using Components"},{"t":"p","c":"Once the loading of ofa.js is completed, a global component named \"load-module\" will be registered. You can use the abbreviation \"l-m\" to refer to it. It is used in a similar way as the \"script\" tag, by using the \"src\" attribute to refer to the address of your developed component."},{"t":"p","c":"Now, let's start creating our own component. First, create an HTML file with the same name as the component."},{"t":"p","c":"In the component file, first add a template element and add the component attribute. Place the content that the component needs to render inside this template element. Finally, this content will be rendered into the component's Shadow DOM. Shadow DOM is isolated from the external environment to prevent contamination of the external environment."},{"t":"p","c":"Next, simply use the l-m component to reference the component you have developed. On the page, just use the tag of the component you defined."},{"t":"p","c":"The component name for registration can only use lowercase letters of the alphabet and hyphens (-), and must include at least one hyphen. This naming convention must be followed."},{"t":"p","c":"Through this example, you can learn how to create a component called my-comp and use it on another page. You can also set the style of the component by linking an external CSS file."}],"slot":[0,{"t":"h","c":"Component Slot"},{"t":"p","c":"By adding the <slot></slot> tag in the template, you can place the content inside the corresponding component label's slot when using the component."},{"t":"p","c":"Custom components do not have a defined 'display' property by default, so it needs to be defined manually. In the component's style, the ':host' selector can be used to add styles specific to the component itself."},{"t":"p","c":"This example demonstrates how to create a component called simple-btn. The template of the component includes a slot where content can be inserted into the component. The component is styled by adding the :host selector to its styles. In another page, the simple-btn component is referenced using the l-m component and content is inserted into it."}],"render-text":[0,{"t":"h","c":"Text rendering"},{"t":"p","c":"In the component file, you can add a script tag to write the logic code of the component. You can set component parameters through the exposed default object."},{"t":"p","c":"data parameter is used to define the default data for component elements. Once the instantiation is complete, you can use template syntax."},{"t":"p","c":"Text rendering is wrapped in double braces, that is {{xxx}}, where xxx represents the component's attribute name."},{"t":"p","c":"This case demonstrates how to render the val attribute of component elements."}],"attribute-transmission":[0,{"t":"h","c":"Attribute Propagation"},{"t":"p","c":"The attrs parameter and the data parameter are similar in function. The data set in attrs will be merged into data, but the data in attrs will be reflected in the characteristics of the component."},{"t":"p","c":"Here the characteristics refer to the attributes of the elements."},{"t":"p","c":"When using components externally, data can also be passed to the component internally through attributes. It should be noted that data passed through attributes can only be of string type."}],"get-set-comp":[0,{"t":"h","c":"Get and Modify the Value of a Component Instance"},{"t":"p","c":"From the outside, you can also access or modify the data of the components."},{"t":"p","c":"The example demonstrates how to manipulate the data of a component externally."}],"property-transmission":[0,{"t":"h","c":"Property Binding"},{"t":"p","c":"By using props binding in template syntax, you can apply component data to element attributes within the template."},{"t":"p","c":"The usage is to add the attribute :name=\"key\" to the element, where name is the attribute name to be set for the target element, and key is the property key that you want to pass in your custom component."},{"t":"p","c":"Previously, it was mentioned to use selector syntax to set properties, and here we introduce the syntax of attribute passing to set properties;"}],"inject-host":[0,{"t":"h","c":"inject-host Component"},{"t":"p","c":"Given the isolation of Web Components, it is difficult to directly modify the styles of elements within component slots. To address this problem, ofa.js provides a component called inject-host; the inject-host component injects styles into the host layer, allowing for more flexible configuration of the component's appearance."},{"t":"p","c":"It should be noted that using this component may affect the styles of the host layer. Therefore, when intruding styles, naming conventions should be followed to avoid affecting the styles of the host."},{"t":"p","c":"In the example, we defined the comp-two component, which internally uses the inject-host component to inject styles. This allows us to style the elements inside the comp-two component using the injected styles without affecting other components."},{"t":"p","c":"At the same time, special attention should also be paid to the following content: "},{"t":"l","c":"- By adding <style> tags within inject-host, we can define specific styles for components. These styles will only affect the elements within the current component and will not extend to other components.\n- When injecting styles, it is important to avoid using common selectors that may affect the styles of other components. It is necessary to maintain the uniqueness and specificity of the selectors.\n- inject-host can also inject external stylesheet files using the <link rel=\"stylesheet\" href=\"target/style.css\"> format."},{"t":"p","c":"In the entire example, by using inject-host in the comp-two component, we can flexibly set and apply the styles within the component without breaking the styles of other components."}],"bind-event":[0,{"t":"h","c":"Event Binding"},{"t":"p","c":"In the component, you can use the on attribute to bind events and enable interactivity for the component. Here is a demonstration of how to bind events in a component to achieve interactive effects."},{"t":"p","c":"The proto parameter is used to define the methods of the component itself. These methods can be used internally within the component or can be executed externally after obtaining the component through a selector."},{"t":"p","c":"on:click=\"xxx\" can be followed by either a method name defined within the component or a function expression. If using a function expression, there is no need to explicitly write the this keyword, as the variable scope will automatically be bound to the component itself."},{"t":"p","c":"If you want to learn more about the available event types, please refer to the Events documentation."}],"nested-component":[0,{"t":"h","c":"Nested Components"},{"t":"p","c":"It is not a wise choice to put all excessive logic in one component; we can separate the logic into another component and import it in the current component using the l-m approach."},{"t":"p","c":"In the case, the nested component named CompTwo is imported using <l-m src=\"./comp-two.html\"></l-m>."},{"t":"p","c":"By using <comp-two :txt=\"val\"></comp-two>, a nested component is used and the val attribute of the current component is passed to the nested component as txt attribute. This way, the nested component can render using the passed data."},{"t":"p","c":"In <comp-two></comp-two>, we used nested components without passing any properties. The usage here depends on the logic and design of the nested component itself."},{"t":"p","c":"As long as a component is successfully loaded, it can be used anywhere with its corresponding name. Even if the \"l-m\" component is loaded multiple times in different places, it will not cause the component to be loaded multiple times. This mechanism ensures component reuse and consistency."}],"condition":[0,{"t":"h","c":"Conditional Rendering"},{"t":"p","c":"In addition to template syntax, the template also includes template components."},0,{"t":"p","c":"Conditional rendering allows you to dynamically insert different content within a component based on specific conditions. Here is an example demonstrating how to use conditional rendering within a component."},{"t":"p","c":"In this example, we create a component called test-demo. The component contains a button that increments the count attribute. By using the x-if, x-else-if, and x-else tags, we implement the logic for conditional rendering."},{"t":"l","c":"- The x-if tag accepts a value attribute to define a condition. If the value of value is true, the content inside x-if will be rendered. In this example, if count is an even number, red text will be displayed.\n- The x-else-if tag also accepts a value attribute to define a condition. If the previous conditions are not met and the value of value is true, the content inside x-else-if will be rendered. In this example, if count is a multiple of 3, blue text will be displayed.\n- The x-else tag does not require a value attribute. It will render its content when none of the previous conditions are met. In this example, if count is neither an even number nor a multiple of 3, green text will be displayed. The x-else tag can also be placed immediately after x-if."},{"t":"p","c":"Through this method, you can dynamically render different content based on different conditions, achieving flexible interaction and display effects."}],"event-passing":[0,{"t":"h","c":"Event Propagation"},{"t":"p","c":"Besides listening for native events, on can also be used to listen for custom events, which is very important for event communication between components. Custom events are triggered through the emit method. By triggering custom events, custom data can be passed to the receiving party."},{"t":"p","c":"If you need to cross Shadow DOM boundaries between components to trigger an event, you can add the composed attribute."},{"t":"p","c":"In the following example, we will learn how to use the emit method to pass events between nested components."}],"life-cycle":[0,{"t":"h","c":"Lifecycle"},{"t":"p","c":"Lifecycle hooks provide an opportunity to execute code at different stages of a component. In ofa.js, there are five main lifecycle hooks, which are created, ready, watch, attached, and detached."},{"t":"l","c":"- created(): Called when the component is created, at this time the shadow root has not started rendering. You can perform some initialization settings here, but you cannot access the elements inside the shadow root.\n\n- ready(): Called after the shadow root has finished rendering, usually used for component initialization logic. At this stage, you can access and manipulate the elements inside the shadow root, as well as perform other operations that need to be executed after rendering is completed.\n\n- watch: Listen for changes in data by defining a watch object. After the ready event, the corresponding value on the data object will trigger a watch. Afterwards, whenever the value of the corresponding key changes, the corresponding function in the watch object will be triggered.\n\n- attached(): Called when the component is added to the document, at this time you can perform operations that interact with the external environment, such as obtaining the appearance of the component or initializing shared data.\n\n- detached(): Called when the component is removed from the document. At this stage, you can perform cleanup work, cancel interactions with the external environment, and release resources."}],"fill":[0,{"t":"h","c":"Fill Rendering"},{"t":"p","c":"Fill rendering (x-fill) templates in front-end frameworks are similar to the concept of list rendering. It allows you to dynamically render a set of microcomponents based on a data collection."},{"t":"p","c":"During the filling and rendering process, you can use the following special variables: "},{"t":"l","c":"- $data: Represents the data of the fill item. By manipulating $data, you can obtain or modify the data of each fill item.\n- $index: Represents the index of the current data item in the data collection.\n- $host: Represents the current component itself. If you want to obtain the data of the component or call the component's methods, you need to use $host to access the component."}],"fill-temp":[0,{"t":"h","c":"Recursive Filling and Rendering"},{"t":"p","c":"Filling rendering allows you to render data using independent templates, with the addition of the name attribute to the <template> element for naming purposes. This allows you to achieve data rendering with nested structures, thereby creating more complex components."},{"t":"p","c":"When using x-fill for template rendering, you just need to pass the corresponding template name to the name attribute, and the content of the independent template can be rendered. In addition, fill rendering also supports recursive filling, which means that the same template name can be used inside the template to achieve nested filling."},{"t":"p","c":"In the example, we defined a standalone template named \"item\" and passed the corresponding template name when using \"x-fill\". This way, each item in the data will be rendered using this template, and the template can be recursively filled with the same template name again. This approach allows you to flexibly handle data with nested structures and achieve more complex component rendering."}],"sync":[0,{"t":"h","c":"Two-way Data Binding"},{"t":"p","c":"By using the sync syntax, you can establish real-time bidirectional associations between user interface interactive elements (such as input boxes or custom components) and data models."},{"t":"p","c":"The following example demonstrates how to use the sync attribute in a component to achieve two-way data binding between an input box and a data model:"},{"t":"l","c":"- In the data parameter, we defined a data called testText and set its initial value to \"I am testText\".\n- Using sync:value=\"testText\" represents a two-way data binding between the value of the input box and the testText data. Therefore, when the user enters content in the input box, the testText data will be updated in real time, and vice versa.\n- Similarly, using sync:txt=\"testText\" represents a two-way data binding between the txt property of the custom component and the testText data. When the txt property of the component changes, the testText data will be updated in real time, and vice versa."},{"t":"p","c":"Through two-way data binding, you can easily establish a connection between the user interface and the data model, so that changes in data can be automatically reflected in the interface, and user input on the interface can immediately affect the data model."},{"t":"p","c":"It is worth noting that data synchronization can only transmit strings or numbers, and cannot transmit other data types."}],"form-data":[0,{"t":"h","c":"Form Data"},{"t":"p","c":"In many applications, handling form data is a common task. To simplify this process, ofa.js provides a secondary abstraction for handling form data, offering the formData method. With this method, you can easily map the values of form elements to an object, and automatically update the data of this object when the values of the form elements change, and vice versa."},{"t":"p","c":"By using the shadow property, you can access the content of the Shadow DOM root node of a component. This allows you to access and manipulate elements and styles within the Shadow DOM from inside the component."},{"t":"p","c":"In this example, we can see how to use the formData method to automatically map form data to the object fdata. This allows you to get or modify the values of form elements by manipulating the fdata object, and these changes will be automatically synchronized to the corresponding form elements."}],"custom-form-element":[0,{"t":"h","c":"Custom Form Components"},{"t":"p","c":"Using ofa.js, you can easily develop custom form element components with standard form features. Just add the value property and set the name attribute to your custom component, and your homemade component can be used as a standard form element. By updating the value property of the component, you can interact with the form element."},{"t":"p","c":"When initializing formData, the selector features of custom components need to be added to the parameters (even though the default parameters for the formData method are \"input,select,textarea\"). This allows formData to be linked with custom components."},{"t":"p","c":"In this example, we implement an editable text input box using the custom component custom-input. This component is used as a form element and interacts with data using the value attribute. When using the formData method, we add \"input, custom-input\" as parameters to correctly initialize the form data."}],"app-config":[0,{"t":"h","c":"Configure app parameters"},{"t":"p","c":"You can configure the parameters of the application by setting external modules for the o-app tag."},{"t":"p","c":"These parameters are an ES module, and you can configure the following parameters:"},{"t":"l","c":"- home: The homepage of the application, which is the page displayed when it is initially loaded.\n- loading: The content displayed while modules are being loaded when navigating between pages in the application. You can provide a string as the loading content.\n- pageAnime: The animation effect used when navigating between pages, defined as an object with CSS style properties.\n  - current: Represents the style of the page when it is the current page.\n  - next: Represents the style of the page when it is entering.\n  - previous: Represents the style of the page when it is exiting."},{"t":"p","c":"Through this method, you can customize parameters such as the home page, loading style, and page transition animation according to the needs of the application, thus bringing a more personalized experience to the application."}],"use-app":[0,{"t":"h","c":"Using the app component"},{"t":"p","c":"In ofa.js, you can use the o-app component to create the layout structure of the entire application and load different page modules within it. By using the o-app component, o-page component, and page modules, you can build the page structure of the entire application and implement navigation between pages."},{"t":"p","c":"When the o-page component is inside o-app, you can use the <a> tag with the olink attribute to achieve page navigation. This navigation will not affect the current page, but will only navigate within o-app, similar to using an <iframe>."},{"t":"p","c":"If the o-page component is within o-app, you can also use the following method:"},{"t":"l","c":"- Use the goto method to navigate to another page.\n- Use the back method to return to the previous page.\n- Use the replace method for replacing the current page during navigation."},{"t":"p","c":"By using the o-app component, you can build the layout structure of the entire application and load different page modules in it. At the same time, the routing function provided by o-app makes it more convenient and flexible to navigate between pages."},{"t":"p","c":"In this example, we create an application layout using the o-app component and then load a page module page1.html within it."},{"t":"p","c":"In the page1.html page module, we defined a title and a button. Clicking the button will navigate to another page module page2.html. We also added a link with the olink attribute, and clicking the link will also navigate to page2.html."},{"t":"p","c":"In the page2.html module, we also defined a title and a button, clicking the button will go back to the previous page, implementing page navigation."}],"app-loading":[0,{"t":"h","c":"Customizing loading for the app"},{"t":"p","c":"The following is an example of customizing the loading of the o-app component. In this example, we have created a beautiful progress bar for loading, which will gradually grow during the page loading process and reach 100% directly after loading is complete, then delete the loading element."},{"t":"p","c":"You can copy and use the following code to customize the loading effect of your application:"},0,{"t":"p","c":"With this code snippet, you can add a unique loading effect to your application, providing users with a better experience during page transitions."}],"use-page":[0,{"t":"h","c":"Use Page Components"},{"t":"p","c":"Once ofa.js is loaded, a page component called o-page will be automatically added to the global scope. This component is used to load page modules, which are a special type of component module that is not registered as a custom tag, but loaded through the o-page component."},{"t":"p","c":"Page modules are similar to component modules, but with a few differences. Page modules use the page attribute to define templates instead of the component attribute. The development logic for page modules is the same as for component modules, using the same template syntax, template components, and so on. However, page modules cannot use the attrs feature because page parameters are usually passed via URL, not via data or attrs."},{"t":"p","c":"In the example, the o-page component is used to load the page.html page module. The template is defined in the page module using the page attribute, and then an object is returned through a JavaScript function to set the data. The query parameter count in the URL will be passed to the page module and used to initialize the data. Button click events within the page can update the data and render it in the page."}],"use-hash-router":[0,{"t":"h","c":"Use hash router"},{"t":"p","c":"Just use the o-router component to link the routing inside the app component to the current webpage. Once the page is bound to the router, the routing state of the page can be maintained even when the page is refreshed."},{"t":"p","c":"In this example, please click the <span style='font-family: \"iconfont\"'>&#xe7cb;</span> button to open and try in a new page."},0],"use-scsr":[0,{"t":"h","c":"Using SCSR Solution"},{"t":"p","c":"In this example, please click the  button to open and try in a new page;"},{"t":"p","c":"SCSR, short for Static Client-Side Rendering, is also known as static client-side rendering. It is a variant of CSR (Client-Side Rendering) that preserves the user experience of CSR and allows web pages to be crawled by search engines while being in a static state."},{"t":"p","c":"The current website adopts the SCSR solution for construction."},{"t":"p","c":"SCSR achieves rendering on the page by directly running the single-file mode of the page module, without using the o-page tag. Specifically, the template code of the page module is directly nested inside the o-app."},{"t":"h","c":"Caveat"},{"t":"p","c":"For all pages using the SCSR scheme, except for descriptive content such as title, meta:description, keywords, and page template content, all referenced resources must remain consistent to ensure a consistent user experience after page redirection and refresh."}],"set404":[0,{"t":"h","c":"Configuration 404 page"},{"t":"p","c":"In the configuration module of the application, customize the content displayed when the page fails to load by setting the fail function."},{"t":"p","c":"In this example, the first line of the error message that displays when the page fails to load will be shown;"},0],"event":[0,{"t":"h","c":"Event Response"},{"t":"p","c":"You can use the on method to bind events. Events are the most fundamental concept in development. Applications rely on the triggering of events to generate feedback and achieve interactivity."},{"t":"p","c":"The following example demonstrates how to bind a click event:"},{"t":"p","c":"In this example, we selected the button element using $ and bound the click event using the on method. When the button is clicked, it triggers a callback function that changes the text content of the target element to \"Hello, world!\"."},{"t":"p","c":"If you want to learn more about the available event types, please refer to the Events documentation."}],"index":[0,{"t":"h","c":"Quick Start"},{"t":"p","c":"To get started, simply integrate the ofajs project into your project by importing the CDN address:"},0,{"t":"p","c":"This is a simple example that demonstrates how to use ofa.js to modify the content of DOM elements:"},{"t":"h","c":"Instructions"},{"t":"p","c":"After introducing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that meets the criteria, where xxx is the standard CSS selector content."},{"t":"p","c":"In the above example, we used the $ symbol to select three elements with different ids and modified their content by setting the text, html, and value attributes."},{"t":"p","c":"To learn more about available properties and methods, please refer to the API documentation."}]},"docs":{"introduce":[{"t":"h","c":"ofa.js - Progressive Front-end Framework"},{"t":"h","c":"What is ofa.js"},{"t":"p","c":"ofa.js is a progressive front-end framework designed to allow developers to enter front-end development and usage processes at the lowest cost. It provides a series of simple yet powerful tools and APIs to make front-end development more efficient and convenient."},{"t":"h","c":"Purpose of Existence"},{"t":"h","c":"Replacing jQuery"},{"t":"p","c":"In many small projects, we may not need to introduce large frameworks like React and Vue, but prefer to use jQuery for simple front-end operations. ofa.js improves jQuery's API and replaces many of jQuery's methods with properties, making it more suitable to use ofa.js in many scenarios."},{"t":"h","c":"Simplify Front-end Development and Usage Process"},{"t":"p","c":"The goal of ofa.js is to simplify the tedious front-end development process. It allows developers to build front-end applications faster without the need to learn complex tools such as Node.js, npm, and scaffolding. With ofa.js, you can go back to the experience of development with just importing a library."},{"t":"p","c":"Become a silver bullet type front-end development framework."},{"t":"p","c":"ofa.js aims to be a \"silver bullet\" that can solve various frontend development problems and provide comprehensive solutions. It is not just a utility library, but a comprehensive frontend development framework."},{"t":"h","c":"Features"},{"t":"h","c":"Easy-to-use Component Development"},{"t":"p","c":"The components developed using ofa.js have almost no learning cost. ofa.js provides a concise and intuitive API, allowing developers to quickly create and integrate components while keeping the code clean and easy to maintain."},{"t":"h","c":"Built-in modular, state update, and application integration solutions"},{"t":"p","c":"The ofa.js has already integrated solutions such as modularity, state update, and application integration, allowing developers to complete complex front-end development tasks without the need to search for third-party libraries or tools."},{"t":"p","c":"Officially provided routing and SSG (Static Site Generation) solutions"},{"t":"p","c":"ofa.js also provides official solutions for routing and SSG, helping developers better manage frontend routing and generating static websites to improve application performance and SEO friendliness."},{"t":"h","c":"Compact code size"},{"t":"p","c":"The code of ofa.js has been carefully optimized, and the size of the compressed .min file is only 38kb (14kb under gzip). This makes ofa.js an efficient front-end framework that can be quickly loaded and used in various network environments."}],"get-started":{"index":[{"t":"h","c":"Getting Started"},{"t":"h","c":"How to Use"},{"t":"h","c":"Direct Quote"},{"t":"p","c":"You can directly reference ofa.js to your page by using the CDN address: "},0,{"t":"h","c":"Install via npm"},{"t":"p","c":"First, install ofa.js in your project: "},0,{"t":"p","c":"Then import the ofa.js module into the project:"},0,{"t":"h","c":"Use"},{"t":"p","c":"After referencing the resource, ofa.js will set a $ property on the global scope, and all functionalities are accessed through $. Its usage will be explained in detail in the following tutorials."},{"t":"p","c":"Usually, we recommend using the direct injection method to add ofa.js, while the npm method is used for compatibility with frameworks such as React and Vue."}],"hello-world":[{"t":"h","c":"First Case"},{"t":"p","c":"Here is an example, when the button is clicked, change the text to \"Hello World\":"},0,{"t":"p","c":"When you click the button, the bold \"Hello World\" text will be displayed."},{"t":"p","c":"Now, let's explain the basic concepts in detail."},{"t":"h","c":"Selectors"},{"t":"p","c":"After importing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that matches the specified condition, where xxx is a standard CSS Selector. You can click on the link to view the specific selector syntax."},{"t":"p","c":"Following is an example: "},0,{"t":"p","c":"In the example above, after one second of opening the page, the text content of the p tag, #desk, and .logger will be changed respectively."},{"t":"h","c":"Event Binding"},{"t":"p","c":"Once you have successfully selected an element, you can bind events to it. As mentioned in the previous \"Hello World\" example, we bind a click event to the element with the ID \"btn\". When the button is clicked, the bound function will be executed."},{"t":"p","c":"You can click to jump and view example events section to learn some examples of event binding."},{"t":"p","c":"Refer to Web Events for a complete list of all available events."},{"t":"h","c":"Attributes"},{"t":"p","c":"In the above two examples, we have demonstrated the use of the html and text attributes."},{"t":"p","c":"You can also get the content of an element through the html or text attributes, as shown below:"},0,{"t":"p","c":"In this example, we assign the HTML content within the #t1 element to the #t2 and #t3 elements."}],"basic-concept":[{"t":"h","c":"Basic Concepts of Instances"},{"t":"p","c":"The $ instance encapsulates elements on the page and can be used to select existing elements as well as to create and manipulate new elements. In this chapter, we will introduce how to create new elements and perform some operations on the $ instance."},{"t":"h","c":"Create New Elements"},{"t":"p","c":"Through $ examples, we can directly create new elements and manipulate them, for example: "},0,{"t":"p","c":"In the example above, we created a new div element using $('<div style=\"color:red\">I am text</div>') and added it to the body."},{"t":"h","c":"Getting Child Elements"},{"t":"p","c":"For instances obtained through $, they do not have the children property like DOM elements. However, we can access the direct child elements of an instance through array indexing."},0,{"t":"p","c":"In the above example, we obtained the div element and accessed the first and second p elements using indexing. At the same time, we also used $div.length to get the number of child elements."},{"t":"h","c":"Operating on Subelements"},{"t":"p","c":"Through the $ instance, we can also directly use array methods to manipulate child elements, such as push and pop:"},0,{"t":"p","c":"In the above example, we obtained instances of all p elements using $ and added a new div element as a child element using the push method. Then, we removed the last child element using the pop method."},{"t":"p","c":"Through the examples above, you can understand some basic operations of the $ instance, including creating new elements and accessing and manipulating child elements. The $ instance provides a convenient way to manipulate elements on the page."}],"common-properties":[{"t":"h","c":"Commonly Used PropertiesIn the $ instance, in addition to selecting elements with selectors, there are also some commonly used methods provided to facilitate element manipulation and searching."},{"t":"h","c":"tagtag is used to get the tag name (in lowercase form) of the current element, similar to the tagName of DOM elements."},0,{"t":"h","c":"ele"},{"t":"p","c":"ele is used to access the actual DOM element of the $ instance, so that native JavaScript operations can be performed on that element."},0,{"t":"p","c":"Sorry, I cannot see any simplified Chinese text in the given input.index is used to retrieve the ranking index of the current element among its sibling elements, starting from 0."},0,{"t":"h","c":"parent and parents- parent is used to retrieve the immediate parent element of the current element."},{"t":"l","c":"- parents is used to retrieve an array of all ancestor elements of the current element, including the parent element's parent element, the parent element's parent element's parent element, and so on."},0,{"t":"h","c":"next, nexts, prev, prevs, siblings- next is used to get the next sibling element of the current element."},{"t":"l","c":"- nexts is used to get an array of all the sibling elements after the current element.\n- prev is used to get the previous sibling element of the current element.\n- prevs is used to get an array of all the sibling elements before the current element.\n- siblings is used to get all the sibling elements of the current element, excluding itself."},0],"common-function":[{"t":"h","c":"Commonly Used Methods"},{"t":"h","c":"attr"},{"t":"p","c":"attr method allows you to get or set the attributes of an element."},0,{"t":"p","c":"In the above example, we first selected a div element with an id of \"example\". Then, we used the attr method to get the name attribute of this element and print it to the console. Next, we used the attr method to set the title attribute of this element to \"change title\"."}],"elements-and-events":[{"t":"h","c":"Get Elements and Events Related"},{"t":"p","c":"This chapter aims to enhance understanding of the previous chapter, including selecting elements and event binding."},{"t":"h","c":"Selecting Elements"},{"t":"p","c":"In the previous chapters, we have learned how to access a specific element from the global scope using the $ symbol. Next, we will introduce other methods of accessing elements."},{"t":"h","c":"Look for an element within an element"},{"t":"h","c":"Using $(\"xxx\").$('xxxx') method"},{"t":"p","c":"$(\"xxx\").$('xxxx') is a way to select a parent element first and then find the child element that meets the condition inside it. In this example, $(\"xxx\") selects a parent element, and then uses $('xxxx') to find the child element that meets the condition within that parent element."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, first select the parent element with the parent class using $(\".parent\"), and then use $(\".child\") to search for the child element with the child class within this parent element. Then modify the text content of the child element to \"Modified child element\"."},{"t":"h","c":"Using $('xxx xxxx') method"},{"t":"p","c":"$('xxx xxxx') is used to find elements that match the second selector condition within the global scope, and then search for elements that match the first selector condition within these elements. This approach allows for directly finding the desired child elements in one step."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, you directly use $('div .child') to find the child elements with the child class and modify their text content to \"Modified child element\"."},{"t":"h","c":"Selecting Multiple Elements"},{"t":"h","c":"Use $.all('xxx') to search for global elements."},{"t":"p","c":"The $.all('xxx') method is used to find all elements on the page that meet the selector condition and return them as a collection of elements. This allows for batch operations on multiple elements in the page."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, $.all(\"p\") is used to find all the p tag elements on the page and perform a batch operation on them, modifying their text content to \"Modified Paragraph 1\", \"Modified Paragraph 2\", and \"Modified Paragraph 3\"."},{"t":"h","c":"Finding all elements that meet the conditions within an element"},{"t":"p","c":"In addition to searching for elements globally, you can also search for all matching child elements within a specific element using the following syntax: $('xxx').all('xxxx')."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, first use $(\".container\") to find elements with the class container, then use .all(\".item\") to find all child elements with the class item within that container, and perform batch operations on them, modifying their text content to \"Modified Item 1\", \"Modified Item 2\", and \"Modified Item 3\"."},{"t":"h","c":"Events"},{"t":"p","c":"We have already discussed the usage of on to bind events. Now let's introduce a few methods related to events."},{"t":"h","c":"Usage documentation for the off method"},{"t":"p","c":"The off method is used to remove event handlers that have been bound using the on method. When a handler for a certain event is no longer needed, the off method can be used to remove it from the element, preventing it from being executed repeatedly or causing memory leaks."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: Select the element to remove the event handler from.\n- eventName: The name of the event to be removed.\n- eventHandler: The event handler to be removed."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, when the button is clicked, a dialog displaying \"Button clicked!\" will pop up. However, after 5 seconds, the click event handler is removed using the off method, so the dialog will not pop up again when the button is clicked."},{"t":"h","c":"Documentation for the use of the one method"},{"t":"p","c":"one method is used to bind event handlers, but this handler will only be executed once when the event is triggered for the first time. After being executed once, the event handler will be automatically removed to avoid repetitive triggering."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: Element to bind event handler to.\n- eventName: Event name to bind.\n- eventHandler: Event handling function to be executed."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, when the button is clicked, a dialog box will appear displaying \"Button clicked once!\". However, after the first click, the event handler will be removed, so subsequent button clicks will not trigger the dialog box."},{"t":"h","c":"Documentation for the emit method"},{"t":"p","c":"emit method is used to manually trigger a specific event bound to an element. By using the emit method, we can trigger the execution of event handling functions without performing any actual operations."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: Select the element to trigger the event.\n- eventName: The name of the event to trigger."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, the emit method is used to manually trigger the button's click event. As a result, a dialog box will appear displaying \"Button clicked!\" even though the button was not actually clicked."},{"t":"p","c":"Note: Using the emit method does not simulate mouse clicks or other actual events. It simply directly calls the bound event handling function. Therefore, if you want to trigger the execution of an event under specific circumstances, you can use the emit method."},{"t":"p","c":"When you bind an event, sometimes you may want to stop the event from further propagation (bubbling) or cancel the default behavior of the event. Below, we will introduce how to prevent event propagation and cancel default events after the event is triggered."},{"t":"h","c":"Stop Event Bubbling"},{"t":"p","c":"Event bubbling refers to the propagation of an event along the DOM tree when it is triggered on an element, sequentially triggering the same type of event on parent elements. If you want to stop the event from further bubbling after handling it on a specific element, you can use the event.stopPropagation() method."},{"t":"p","c":"Example code: "},0,{"t":"p","c":"In the example above, when you click the button \"Click Me\", it will display \"Button Clicked!\" but not trigger \"Inner Div Clicked!\" and \"Outer Div Clicked!\". This is because we called event.stopPropagation() in the button's click event handler, which prevents the event from further propagation."},{"t":"h","c":"Cancel Default Behavior of an Event"},{"t":"p","c":"Some events on certain elements have default behaviors when triggered. For example, clicking a submit button will cause the form to be submitted, clicking a link will navigate to the link's address, and so on. If you want to prevent the default behavior of an event, you can use the event.preventDefault() method."},{"t":"p","c":"Example code: "},0,{"t":"p","c":"In the example above, when you click the \"Submit\" button, it will display \"Hello, {name}! Form submission prevented.\", but it will not trigger the \"Form Submitted!\" alert. This is because we called event.preventDefault() in the event handler for the submit button, preventing the form's default submission behavior."}],"css":[{"t":"h","c":"Usage of CSS"},{"t":"p","c":"In ofa.js, you can manipulate CSS styles of elements using the following methods:"},{"t":"h","c":"Get the specific CSS styles of an element"},{"t":"p","c":"You can use $ele.css.xxx to get the specific CSS style of an element, where xxx is the CSS property name you want to get."},{"t":"h","c":"Example"},0,{"t":"p","c":"Setting a style property"},{"t":"p","c":"You can use $ele.css.xxx = '' to set the CSS style of an element, where xxx is the CSS property name you want to set. By setting the property value to an empty string, you can remove the specified style property."},{"t":"h","c":"Example"},0,{"t":"h","c":"Assignment Object"},{"t":"p","c":"You can use $ele.css = {xxx} to set the style of an element, where xxx is an object that contains CSS property names and values."},{"t":"h","c":"Example"},0,{"t":"h","c":"Assigning Strings"},{"t":"p","c":"You can use $ele.css = 'color:red;...' to set the style of an element, where 'color:red;...' is a string that contains CSS style rules."},{"t":"h","c":"Example"},0,{"t":"h","c":"Tips for Setting CSS"},{"t":"p","c":"You can modify a specific style property of an element by using $ele.css = {...$ele.css, color:'red'}, without affecting other style properties. This method allows you to modify only one property without rewriting the entire style."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, by using { ...myElement.css, color: 'red' }, we only modified the color style of the element, while keeping other style properties unchanged. This is a convenient trick that allows flexible modifications of the element's style."}],"classlist-and-data":[{"t":"h","c":"classList and data"},{"t":"h","c":"classList"},{"t":"p","c":"In ofa.js, you can manipulate the classList of elements using the following methods:"},{"t":"l","c":"- $ele.classList: Returns the classList object of the element, which is used to manipulate the element's class names."},{"t":"h","c":"Usage of classList for adding or removing classes"},{"t":"l","c":"- Add Class Name: $ele.classList.add('className'), adds the specified class name to the element's classList.\n- Remove Class Name: $ele.classList.remove('className'), removes the specified class name from the element's classList.\n- Toggle Class Name: $ele.classList.toggle('className'), removes the class name if it already exists in the element's classList; otherwise, adds the class name."},{"t":"h","c":"Example"},0,{"t":"p","c":"In this example, there is a <div> element with an initial class name box, and three buttons: Add Highlight, Remove Highlight, and Toggle Highlight."},{"t":"l","c":"- When the \"Add Highlight\" button is clicked, use the classList.add() method to add the class name \"highlight\" to the <div> element, giving it a yellow background color.\n- When the \"Remove Highlight\" button is clicked, use the classList.remove() method to remove the class name \"highlight\" from the <div> element's class list, restoring the original style.\n- When the \"Toggle Highlight\" button is clicked, use the classList.toggle() method to toggle the \"highlight\" class name of the <div> element. If the class name already exists, remove it; if it doesn't exist, add it, thus achieving the toggling of the style."},{"t":"p","c":"In this way, you can use the classList object to manage the class names of the elements, thus achieving dynamic control over the element styles."},{"t":"h","c":"Usage of the \"data\" keyword"},{"t":"p","c":"In ofa.js, you can manipulate the data attribute of an element using the following methods:"},{"t":"l","c":"- $ele.data: Returns the dataset object of the element to manipulate the element's data attribute."},{"t":"p","c":"Specific usage of dataset"},{"t":"p","c":"The data-* attribute of an element can be used to store custom data in HTML, and these attributes can be accessed through the data object."},{"t":"p","c":"For example, if there is an element that defines the data-info attribute:"},0,{"t":"p","c":"You can use dataset to access this property: "},0,{"t":"p","c":"Note: The attribute name in the dataset object will convert the part after \"data-\" to camel case. For example, data-info becomes dataset.info. If you want to set the data-* attribute, you can also achieve it through the dataset object."},0,{"t":"p","c":"This will add a data-another-info attribute to the element and set its value to \"another value\"."}],"formdata":[{"t":"h","c":"Form Functionality"},{"t":"p","c":"$ provides convenient form functions that make handling form elements easier and more efficient."},{"t":"h","c":"Create an object using formData"},{"t":"p","c":"formData method is used to generate an object containing the values of all form elements within the target element. This object will reflect the changes made to the form elements in real time."},0,{"t":"h","c":"Listening for specific form elements"},{"t":"p","c":"By default, formData() listens to all input, select, and textarea elements within the target element. You can specify specific form elements to listen to by passing a selector."},0,{"t":"h","c":"Stanz Objects"},{"t":"p","c":"The object returned by the formData() method is called a Stanz object. Stanz is part of the $ extension library, which provides efficient handling and monitoring functionality for form data."},{"t":"p","c":"You can find detailed tutorials and features of Stanz by visiting https://github.com/kirakiray/stanz."},{"t":"p","c":"Through the above form functionality, you can easily handle the values and changes of form elements, thereby improving the convenience and efficiency of form operations."}],"box-model":[{"t":"h","c":"Box Model"},{"t":"p","c":"In frontend development, some properties that represent element sizes are often used. These properties include width, height, clientWidth, clientHeight, offsetWidth, offsetHeight, outerWidth, and outerHeight. Understanding their meanings and usage is essential for developing responsive and dynamic layouts. Let's explain them one by one and demonstrate with an example."},{"t":"l","c":"- width: Represents the width of the content area of an element, excluding padding, borders, and margins.\n- height: Represents the height of the content area of an element, excluding padding, borders, and margins.\n- clientWidth: Represents the visible width of the content area of an element, including padding but excluding borders and margins.\n- clientHeight: Represents the visible height of the content area of an element, including padding but excluding borders and margins.\n- offsetWidth: Represents the total width of an element, including content area, padding, borders, and margins.\n- offsetHeight: Represents the total height of an element, including content area, padding, borders, and margins.\n- outerWidth: Represents the total width of an element, including content area, padding, borders, margins, but excluding the width of the scroll bar.\n- outerHeight: Represents the total height of an element, including content area, padding, borders, margins, but excluding the height of the scroll bar."},0]},"create-component":{"life-cycle":[{"t":"h","c":"The Lifecycle of Components"},{"t":"p","c":"In ofa.js, the component lifecycle is triggered by specific hooks at certain points in time. These hooks allow you to have more precise control and interaction. ofa.js has five key lifecycle hooks: created, ready, watch, loaded, attached, and detached, which are triggered at different times."},{"t":"h","c":"Lifecycle Hooks"},{"t":"h","c":"Created"},{"t":"p","c":"created lifecycle hook is triggered when a component is created. At this stage, the component's data has not been initialized and the template content has not been rendered. You can perform some initialization operations at this stage or prepare data to be used in later stages."},{"t":"h","c":"ready"},{"t":"p","c":"ready lifecycle hook is triggered after the component's data and template are initialized, indicating that the component is ready. At this stage, you can access the component's data, and the template has been rendered, allowing you to perform some interactive operations related to the interface."},{"t":"p","c":"If the component template relies on other components, this stage will not wait for the dependencies to be loaded. Therefore, this stage is suitable for adding loading styles to the component, but it is important to wait for the dependencies to be loaded before performing related operations."},{"t":"h","c":"watch"},{"t":"p","c":"Once the ready stage is completed, the listening function in the associated watch object will be triggered once. Afterwards, when a value of the data changes, the corresponding key's listening function will be triggered again."},{"t":"h","c":"loaded"},{"t":"p","c":"The loaded lifecycle hook is triggered after all dependencies in the component template have been loaded. This stage ensures that all dependencies are loaded before rendering the component. This is a good time to remove the Loading style added during the ready stage."},{"t":"h","c":"attached"},{"t":"p","c":"attached lifecycle hook is triggered when the component is added to the document. At this stage, it is suitable for obtaining size-related information of the elements within the component, performing data binding, and global event operations."},{"t":"h","c":"detached"},{"t":"p","c":"detached lifecycle hook is triggered when a component is removed from the document. During this stage, you can perform some cleanup operations, such as unregistering event listeners or releasing resources, to prevent memory leaks."},{"t":"h","c":"Examples and Demonstrations"},{"t":"p","c":"The following is an example demonstrating how to use these lifecycle hooks:"},0,0,0,{"t":"p","c":"In the example above, we defined a component called lifecycle-demo and placed a button in its template. Through different lifecycle hooks, we can observe the logs triggered at each stage in the console."},{"t":"h","c":"Lifecycle Flowchart"},0],"parameter-description":[{"t":"h","c":"Explanation of registration parameters for components"},{"t":"p","c":"In ofa.js, you can define certain specific registration parameters in the component module to configure the component more flexibly. The following explains each registration parameter in detail, accompanied by corresponding examples for demonstration."},{"t":"h","c":"Basic Parameters"},{"t":"p","c":"Basic parameters are the most basic configuration for registering a component, which includes the following attributes:"},{"t":"h","c":"Component Identification"},{"t":"p","c":"The component module must have export const type = $.COMP to identify it as a component module."},{"t":"p","c":"Example: "},0,{"t":"h","c":"tag"},{"t":"p","c":"tag represents the registered component name. When the tag attribute is not defined, the registered component name remains the same as the file name."},{"t":"p","c":"Example: "},0,{"t":"h","c":"temp"},{"t":"p","c":"temp is a string-type property used to define the address of the component template. When temp is not defined, the HTML file with the same name as the component in the same directory as the current module will be loaded by default."},{"t":"p","c":"Example: "},0,{"t":"h","c":"data"},{"t":"p","c":"data is an object-type property used to add default custom data to the generated component."},{"t":"p","c":"Example: "},0,{"t":"h","c":"attrs"},{"t":"p","c":"attrs is an object-type attribute, which also belongs to data, but this data will be reflected in the attributes of the element. Changes in the attributes will also dynamically change the data of the component. When there is a capital key, it will be transformed into a kebab-case naming in the component attribute."},{"t":"p","c":"Example: "},0,{"t":"h","c":"proto"},{"t":"p","c":"In the registration parameter of the component, you can add a proto object to define the methods that need to be added to the component prototype. In this way, when creating an instance of the component, these properties and methods will be added to the prototype of the instance, so that all instances can access and share these methods."},0,{"t":"h","c":"watch"},{"t":"p","c":"watch is an object type property used to listen to the changes of data. The listener function is placed here. After being successfully registered, the value being listened to will be executed immediately."},{"t":"l","c":"- The function registered with watch will only be triggered once during a single-threaded change. Therefore, even if the value being listened to is modified multiple times within a single thread, it will only be triggered once.\n- The first parameter is the current value.\n- The second parameter is an object that contains the watchers data set. In general, there will only be one object on watchers, and you can obtain the oldValue from this object. When the value being listened to in a single thread is changed multiple times, this data set will record the changes multiple times."},{"t":"p","c":"Example: "},0,{"t":"h","c":"Example code"},{"t":"p","c":"The following is a complete example code, including the definition of basic parameters and component templates."},0,0,0,{"t":"h","c":"default"},{"t":"p","c":"You can also use asynchronous functions to define the default data, in order to dynamically return the registration parameters of the component."},{"t":"p","c":"Functions in JavaScript will introduce an object that includes"},{"t":"p","c":"load, url, and query:"},{"t":"l","c":"- The load method is an asynchronous loading function, used in the same way as asynchronous import loading. You can use const data = await load(xxx) to load asynchronous modules.\n- Modules loaded through load have the same effect as modules loaded through load-module. The load method is a function version of the load-module component. For specific usage, you can refer to the documentation of https://github.com/kirakiray/drill.js.\n- url is the file name of the current module.\n- query is an object converted from the URL parameters when loading this module."},{"t":"p","c":"Below are examples of using default:"},0,{"t":"p","c":"In this example, we demonstrate how to customize the behavior of components using the registration parameters of ofa.js. By configuring these parameters appropriately, you can better adapt to different component requirements and achieve more flexible component development."},{"t":"p","c":"Write a documentation on the use of the proto registration parameters for components."}],"index":[{"t":"h","c":"Creating and Using Components"},{"t":"p","c":"ofa.js uses basic HTML and JavaScript files to define components, avoiding the introduction of new file types to reduce learning costs. As long as you have a certain understanding of HTML, you can quickly develop and use ofa.js components."},{"t":"h","c":"Steps before creating a component"},{"t":"p","c":"Before starting to create components, there are some preparations that need to be done. Since creating components involves browser resource requests, if you only double-click to open an HTML file for viewing, it will be viewed under the \"file\" protocol. Under the \"file\" protocol, the loading of JavaScript modules may result in errors. Therefore, you need to prepare a static server to correctly view the components."},{"t":"p","c":"If you are using Visual Studio Code editor, you can simply install a plugin that supports a static server. We recommend using the Live Server plugin."},{"t":"p","c":"After installing the plugin, simply right-click on the demo.html file and select \"Open with Live Server\". The plugin will automatically open the file in static server mode."},{"t":"p","c":"If you are using a different editor, you can also create an Nginx or Apache server as long as it can support static HTML viewing. Doing so will ensure that you can preview and develop your components properly."},{"t":"h","c":"Create a button component"},{"t":"p","c":"Below, we will create a simple button component named simple-button, which will have a more stylish appearance than native buttons."},{"t":"p","c":"First, create a file named 'simple-button.html' that uses the 'template' tag and add the 'component' attribute to identify it as a component."},{"t":"p","c":"Then, write the template code for the component in the template. Next, below the template content, add a script tag and put the component's JavaScript code inside it."},0,{"t":"p","c":"After successfully introducing ofa.js, the load-module component will be automatically registered. This is a component used to declaratively reference modules, similar to the script tag. This component will proxy load the specified src modules and preprocess the modules that need to be loaded. In this case, templates will be loaded and the simple-button component will be registered."},{"t":"p","c":"The load-module component can also be abbreviated as l-m to reduce code size."},0,{"t":"p","c":"load-module component is a customized declarative loader library that provides powerful functionality to extend support for various types of files or to perform intermediate processing on JavaScript modules. It has been split into a separate project, and the specific usage documentation can be found at https://github.com/kirakiray/drill.js."},{"t":"h","c":"Dual File Mode"},{"t":"p","c":"Dual-file mode separates static templates and logic code, making components more clear."},{"t":"p","c":"The logic code is put in a js file, and this js file needs to indicate export const type = $.COMP; to notify the page that it is a component module. In this split mode, the module code can use standard syntax like import in ES Module."},{"t":"p","c":"Button component consists of two files:"},{"t":"l","c":"1. simple-button.html: HTML template and style for the button component."},0,{"t":"l","c":"2. simple-button.mjs: Registration code for the button component."},0,{"t":"p","c":"In the places where this component is needed, use l-m to import this module. Here is an example page using simple-button (dual-file mode)."},0],"web-components":[{"t":"h","c":"Encapsulation and Componentization: Common Knowledge of Componentization"},{"t":"p","c":"ofa.js is a wrapper library based on Web Components technology, aiming to simplify and accelerate the component development process. By hiding complex technical details behind the scenes, it allows developers to focus more on building high-quality components and applications."},{"t":"p","c":"In order to develop components better, it is necessary to learn some knowledge about Web Components. The knowledge points introduced below can not only be applied in ofa.js, but also benefit you when using other frameworks that use Web Components."},{"t":"h","c":"Shadow DOM Container"},{"t":"p","c":"In Web Components, Shadow DOM provides an isolated container for encapsulating the styles and structure of a component. This means that the styles and DOM structure inside the component will not interfere with the external styles and structure, ensuring the predictability and maintainability of the component."},{"t":"p","c":"In ofa.js, each component has a Shadow DOM container to isolate the internal content of the component. The template content is rendered into this container. The component instance obtained through $ can also access the Shadow DOM container within the component by using the shadow property, thereby achieving manipulation and access to the internal elements of the component."},0,{"t":"h","c":"Common CSS Selectors in Web Components"},{"t":"p","c":"Web Components provides special CSS selectors for selecting and styling different parts within a component. Here are some commonly used selectors:"},{"t":"h","c":":host Selector"},{"t":"p","c":"The :host selector is used to select the outer container of the component itself. This selector can be used to define the style of the component."},0,{"t":"h","c":"::slotted() Selector"},{"t":"p","c":"::slotted() selector is used to select elements that are wrapped by slotted content. This selector can be used in the styles of a component to style the slotted content."},0,{"t":"h","c":"How to Use Slots"},{"t":"p","c":"Slots are the mechanism in Web Components used to embed external content inside a component. Slots allow developers to pass custom content into the component, enabling more flexible component structures."},{"t":"h","c":"Single Slot"},{"t":"p","c":"In component templates, <slot> element can be used to define slots. Contents passed from the outside will be inserted into the slots."},0,0,{"t":"h","c":"Multiple Named Slots"},{"t":"p","c":"Except for the default slot, multiple named slots can also be defined. Named slots allow developers to insert different content into different slot positions."},0,0,{"t":"h","c":"Usage of the \"slotchange\" event"},{"t":"p","c":"The \"slotchange\" event is used to detect changes in the assigned nodes within a web component."},{"t":"p","c":"The slotchange event is triggered when the content of a slot changes. You can listen to this event to perform operations related to the content of the slot."},0],"template-syntax":[{"t":"h","c":"Template Syntax"},{"t":"p","c":"ofa.js provides a series of powerful template syntax that allows you to manipulate component's interface elements and data more flexibly. These template syntax can help you achieve rich interface effects and interactive experiences."},{"t":"h","c":"Render Text Syntax"},{"t":"p","c":"By using the {{key}} rendering syntax, you can render data as text content and embed it in the component's template. When the data changes, the corresponding text content will also be automatically updated."},{"t":"p","c":"The following is an example using text rendering syntax: "},0,0,{"t":"p","c":"In the above example, {{username}} will be replaced by the value of the username property in the component's data, thus displaying \"Welcome, JohnDoe!\" on the interface."},{"t":"h","c":"Attribute Binding Syntax"},{"t":"p","c":"Using the :xxx='yyy' attribute binding syntax, you can bind a component's property to an attribute on an element within the template. This binding is one-way, meaning that changes to the property will affect the element's attribute, but not vice versa."},{"t":"p","c":"The following are some common examples of attribute bindings:"},0,{"t":"p","c":"// MyComponent.js\nexport const type = $.COMP;"},{"t":"p","c":"export const data = {\n  greeting: \"Hello, World!\",\n  inputValue: \"\",\n  customValue: \"Custom Value\",\n};"},{"t":"p","c":"In the above example, :text=\"greeting\" binds the value of the greeting property in the component's data to the text content of the <p> element. :value=\"inputValue\" binds the value of the inputValue property in the component's data to the value attribute of the <input> element. For custom components, custom-prop is the attribute name for the custom component, and it passes the value of the customValue property in the component's data to the custom component."},{"t":"h","c":"Event Binding"},{"t":"p","c":"Using the form on:click=\"yyy\", you can bind the specified event (such as click) of the target element to the yyy property of the host component. This way, when the target element triggers the specified event, it will call the corresponding property method in the host component."},{"t":"p","c":"Following is an example: "},0,0,{"t":"p","c":"In the above example, when the button is clicked, the increaseCount method of the host component is called to increase the value of the count property."},{"t":"h","c":"attribute binding"},{"t":"p","c":"By using the attr:xxx=\"yyy\" format, you can bind the specified attribute xxx of the target element to the property yyy of the host component. This way, the attribute of the target element will change along with the property of the host component."},0,0,{"t":"p","c":"In the above example, attr:fontcolor=\"val\" will bind the val property of the host component to the fontcolor attribute of the <div> element."},{"t":"h","c":"Dynamic Class Name Binding"},{"t":"p","c":"Using the format class:xxx=\"yyy\", you can dynamically add or remove class names to the target element based on the value of the host component's property. When the yyy property of the host component is true, the target element will add the class name xxx; otherwise, the class name will be removed."},0,0,{"t":"p","c":"In the above example, if the isActive attribute is true, the button will add the active class name, thus applying specific styles."},{"t":"h","c":"Two-way Data Binding"},{"t":"p","c":"% Through the sync:xxx='yyy' format, you can achieve two-way data binding. This ensures that the target element's attribute xxx stays synchronized with the host component's attribute yyy. Any changes in the target attribute will be reflected in the host attribute, and changes in the host attribute will be synchronized to the target attribute."},{"t":"p","c":"Following is an example: "},0,0,{"t":"p","c":"In the above example, sync:value=\"inputValue\" implements a two-way data binding, when the value of the input box changes, inputValue will automatically be updated; conversely, when inputValue changes, the value of the input box will also change accordingly."}],"template-component":[{"t":"h","c":"Template Rendering Component"},{"t":"p","c":"In addition to being able to use template syntax, ofa.js also provides dedicated rendering components for templates, including conditional rendering components and filling rendering components."},{"t":"h","c":"Conditional Rendering Component"},{"t":"h","c":"x-if Component"},{"t":"p","c":"x-if component is a component used to dynamically render content based on conditions. It accepts a value attribute to determine whether to render its child elements. If the value is true, the child elements will be rendered; otherwise, they will not be rendered."},{"t":"p","c":"The following is an example of using x-if to render different content based on conditions:"},0,0,{"t":"h","c":"x-else component"},{"t":"p","c":"x-if can be used in conjunction with x-else to achieve conditional rendering switch."},{"t":"p","c":"Below is an example using x-if and x-else to switch the rendered content based on different conditions:"},0,0,{"t":"h","c":"x-if + x-else-if + x-else Components"},{"t":"p","c":"x-if can also be used with x-else-if and x-else to achieve rendering with multiple conditions."},{"t":"p","c":"Below is an example using x-if, x-else-if, and x-else to toggle the rendered content based on multiple conditions:"},0,0,{"t":"p","c":"In the above example, different content will be rendered based on the value of condition, achieving the effect of rendering with multiple conditions."},{"t":"h","c":"Template Component: x-fill"},{"t":"p","c":"x-fill component allows you to dynamically fill content in a template. It can generate different content based on the attribute values of the host component. The x-fill component uses the name attribute to specify the filling template to be used, and passes data to the filling template through the value attribute."},{"t":"h","c":"Example of x-fill to fill an array string"},{"t":"p","c":"The following is an example of using x-fill to fill an array of strings, filling different string contents through looping:"},0,{"t":"p","c":"In this example, the x-fill template tag is used to concatenate the index number and the string content in each iteration. The resulting array will contain the modified strings."},0,{"t":"p","c":"In the above example, x-fill uses a filling template called fillTemplate and passes an array to it. The {{ $data }} is used in the filling template to render each element in the array, thus achieving the cyclic filling of different string contents."},{"t":"h","c":"x-fill Example of an Object that Can Fill Itself with Fill"},{"t":"p","c":"x-fill can also fill objects with more complex structures and supports self-nested filling."},{"t":"p","c":"Here is an example of using x-fill to fill an object and generate nested content:"},0,0,{"t":"p","c":"In the example above, x-fill uses a fill template called nestedFillTemplate and passes a complex nested object to it. The fill template uses {{ $data.title }} to render the title of the object and also uses nested x-fill to fill the content of the child items, achieving nested content generation."},{"t":"h","c":"The meanings of $data, $ele, and $host within the template"},{"t":"p","c":"When filling in the template, you can use special placeholders to access different data: ."},{"t":"l","c":"- {{ $data }}: represents the data passed to the template for filling, i.e., the value of the value attribute.\n- {{ $ele }}: represents the element where the filling template is located, can be used to access the element's attributes and styles.\n- {{ $host }}: represents the instance of the host component, can be used to access the host component's properties and methods."},{"t":"p","c":"These special identifiers can help you dynamically access and render different data within the template. In the example, you can see how {{ $data.title }} is used to access the title of the passed data, and how {{ $host.num }} is used to access the property of the host component."}]},"create-app":{"index":[{"t":"h","c":"Develop Applications"},{"t":"p","c":"Apart from developing components, ofa.js can also be used to develop fully functional applications."},{"t":"p","c":"ofa.js integrates applications as an o-app component, allowing you to quickly create applications by directly using this tag. This approach simplifies and streamlines the process of application creation."},{"t":"p","c":"In addition, the official ofa.js also provides a complete routing and SSG (Static Site Generation) solution, which helps developers build more robust applications. These features can accelerate the development process, allowing you to focus on the logic and user experience of the application without worrying too much about the underlying details."},0,{"t":"p","c":"Above is a simple application tutorial code example. The development process of the application will be explained step by step."}],"page":[{"t":"h","c":"Develop Page"},{"t":"p","c":"In ofa.js, we have built a custom component called o-page to provide convenience for page development. This component plays a crucial role in application development. When you want to use component template syntax but don't want to create a completely new component, o-page component will be your best choice."},{"t":"h","c":"Page Modules"},{"t":"p","c":"When creating a single file page module, it is similar to creating a component module. Use the template tag to wrap the template code of the page and add the page attribute. Inside this tag, you can freely use template syntax to interact with other components or page modules."},0,{"t":"p","c":"In HTML files, use the src attribute of the o-page tag to specify the file path of the page module. The page content will be rendered inside this component."},0,{"t":"h","c":"Dual File Mode"},{"t":"p","c":"Dual file mode separates static templates and logic code to make the content of the web page clearer."},{"t":"p","c":"Here are the steps to use the o-page component and page modules:"},{"t":"p","c":"Creating page module: ."},{"t":"p","c":"Similar to creating a component module, create a page module but set the type attribute to $.PAGE. The available parameters for a page module include temp, data, proto, and watch."},0,{"t":"p","c":"Create page template: "},{"t":"p","c":"In the same directory as the page module, create a page template file named my-page-template.html. In this template file, you can use template syntax for interaction, which is similar to the component template syntax mentioned earlier."},0,{"t":"p","c":"In your HTML file, use the <o-page> tag to use the o-page component, and reference the file path of the page module through the src attribute. The content of the page will be rendered inside this component."},0,{"t":"p","c":"In this way, when you open the page, the o-page component will dynamically load the my-page.mjs page module and render the page content based on the templates and data in the module. The lifecycle and template syntax of the page module are consistent with the component module, making page development and management more unified and flexible."},{"t":"h","c":"Determine if the page has finished loading"},{"t":"p","c":"In some cases, you may need to determine whether the page has been fully loaded so that you can perform certain operations. ofa.js provides several methods to determine if the page has finished loading."},{"t":"h","c":"Using the page._loaded property"},{"t":"p","c":"In the page module, page._loaded is a boolean attribute that becomes true when the page content is fully loaded. You can use this attribute to determine if the page has finished loading."},0,{"t":"h","c":"Use the page._rendered property"},{"t":"p","c":"Another way is to use the page.rendered property, which is a Promise. When the page is loaded, this Promise will enter the resolve state. You can use await page.rendered to wait for the page to load, and then perform corresponding operations."},0],"app":[{"t":"h","c":"Creating Applications"},{"t":"p","c":"Using the o-app tag allows you to easily create a complete application window. Here is the step-by-step process for creating an application and configuring it:"},{"t":"h","c":"Basic code"},{"t":"p","c":"Create an HTML file and set the 'o-app' tag as the display window for the application. Make sure to set the 'o-app' tag to full screen style so that the application occupies the entire viewport."},0,{"t":"l","c":"2. Create an ES module to set up the configuration data for the application. The configuration data includes the following options:\n\n   - home: String type, the page module address of the application's homepage.\n   - loading: Function type, this function will be executed when the application is loading a new page. The content obtained will be inserted into the application as a loading prompt. After the page is loaded, this loading element will be automatically removed.\n   - fail: Function type, this function will be executed when the application fails to load a page. The value returned will be displayed in the application as a loading failure prompt. The function will have the src address of the failed page and the error object.\n   - pageAnime: Animation configuration for page transitions."},{"t":"p","c":"The following is an example of the configuration data for the application:"},0,{"t":"l","c":"3. Use the o-app tag in HTML files and reference the configuration data es module through the src attribute."},0,{"t":"p","c":"By following the steps above, you have successfully created an application window using the o-app component. The o-app component will load the page based on the settings in the configuration data, display a loading prompt or a loading failure prompt, and support page transition animations. This way, you can quickly build a fully functional and interactive application."},{"t":"h","c":"Route Jump"},{"t":"p","c":"In the o-app application, you can easily achieve route navigation, jumping from one page module to another page module. Below are several different ways to perform route navigation."},{"t":"h","c":"Use <a> tag for route navigation"},{"t":"p","c":"You can use the <a> tag in the HTML of the page to implement routing. You need to specify the href attribute as the path of the target page module and add the olink attribute to inform the o-app component that this is a routing link."},0,{"t":"h","c":"goto"},{"t":"p","c":"You can use the on:click attribute in the page template to bind a click event and call the goto method on the module for routing."},0,{"t":"p","c":"Uninstall the target element directly."},0,{"t":"h","c":"Replace Jump and Return Pages"},{"t":"p","c":"Besides the goto method, o-app also supports the replace and back methods."},{"t":"l","c":"- The replace method is used to replace navigation, it replaces the current page's route with the route of the new page."},0,{"t":"l","c":"- The back method is used to go back to the previous page."},0,{"t":"p","c":"It should be noted that the application will maintain the routing state of the components, but the routing data will not be bound to the current browser tab. In this way, you can easily implement page transitions and navigation between pages in the application."},{"t":"p","c":"If you want to bind routes and pages, you can use the o-router component, which we will discuss in detail in the following sections."},{"t":"p","c":"Through the above methods, you can implement flexible routing in the o-app application, allowing users to easily browse different page content."},{"t":"h","c":"Accessing Apps and Current Pages"},{"t":"p","c":"In various elements (including components) within the application, you can use the app attribute to access the o-app instance they belong to. This is very useful for operations that require interaction with the entire application."},{"t":"p","c":"You can retrieve the address of the currently active page module through the app.current property."},{"t":"p","c":"Here is an example of usage: "},0,{"t":"p","c":"In the example above, the app tag was retrieved using the selector .app, and then the current active page address was obtained by accessing the app.current attribute."},{"t":"h","c":"Tips: Pre-cache the next page"},{"t":"p","c":"In some scenarios, you may already know that the user is about to navigate to the next page. To enhance the user experience, you can pre-cache the page modules of the next page, so that they can be loaded immediately when the actual navigation occurs. This reduces the waiting time for users and makes their experience smoother."},{"t":"p","c":"In the JavaScript code of the current page, call the load method and pass in the module path of the next page. The module will be loaded and cached."},0],"subrouting":[{"t":"h","c":"Subroute Mode"},{"t":"p","c":"In ofa.js, setting up sub-routes is slightly different from other front-end frameworks. ofa.js uses a more intuitive approach by setting the parent page as a container on the page module to achieve the needs of sub-routes."},{"t":"h","c":"Set Parent Page Container"},{"t":"p","c":"To create a sub-route, first, the parent parameter needs to be set on the page module of the child page, specifying the page module address of the parent page. This way, when the child page is loaded, ofa.js will automatically wrap the child page in the container of the parent page."},0,{"t":"p","c":"In the above example, the page module of the subpage specifies the address of the parent page container through the parent parameter."},{"t":"h","c":"Parent Page Container Template Settings"},{"t":"p","c":"The template of the parent page container needs to set a <slot> element so that the child pages can be inserted into the specified position of the parent page. At the same time, make sure that the container element of the <slot> element is set to position: relative. This is very important because the child pages will be absolutely positioned within the parent page container."},{"t":"p","c":"The following is an example template of a parent page container:"},0,{"t":"p","c":"In the above example, by setting a container element with a slot, the subpage will be inserted into the container. Make sure the container element has relative positioning so that the subpage can be positioned relative to the container."},{"t":"p","c":"By using this approach, you can configure sub-routes more intuitively. By setting the association between the parent page container and the child pages, you can achieve the loading and rendering of the child pages."},{"t":"h","c":"Listening to Routes on the Parent Page"},{"t":"p","c":"In some cases, multiple pages share the same parent page as a container. When these pages navigate between each other, the parent page will not be refreshed. In this case, the parent page can still listen for changes in the route and perform corresponding operations without refreshing the page."},{"t":"h","c":"Listen to routing changes"},{"t":"p","c":"The parent page module can set a routerChange function to monitor the change of the route. When the page changes the route without refreshing the parent page, the routerChange event will be triggered. This event will pass the information of the current page and the navigation mode (type)."},{"t":"p","c":"Below is an example of a parent page module, demonstrating how to set up the routerChange function to listen for route changes:"},0,{"t":"p","c":"In the above example, the routerChange function receives two parameters. current represents the address of the current page, and type represents the type of navigation. When the page undergoes a router change, this function will be triggered and output the corresponding information."}],"o-router":[{"t":"h","c":"Usage of o-router component"},{"t":"p","c":"The o-router component is a component used to bind the routes within o-app to the current browser tab. It can help you manage page routes and display more conveniently."},{"t":"h","c":"Quoting the o-router component"},{"t":"p","c":"First, you need to import the o-router component in your page. You can import the router.mjs file using the following method: "},0,{"t":"h","c":"Using the o-router component"},{"t":"p","c":"Using the o-router component is achieved by wrapping it outside the o-app component. This allows binding the application's routes to the current browser tab."},0,{"t":"h","c":"fix-body attribute"},{"t":"p","c":"The o-router component also provides a fix-body attribute. When you set this attribute, the component will automatically add styles to the <html> tag so that the size of the application matches the size of the page, making the content of the application fill the entire window."},0],"scsr":[{"t":"h","c":"Static Client Side Rendering (SCSR)"},{"t":"h","c":"What is SCSR?"},{"t":"p","c":"SCSR, short for Static Client-Side Rendering, is also known as static client-side rendering. SCSR is a variant of CSR (Client-Side Rendering) that allows web pages to be crawled by search engines while maintaining the user experience of CSR in a static state."},{"t":"h","c":"How to Use SCSR"},{"t":"p","c":"You can reference the SCSR library using the following methods: "},0,{"t":"h","c":"The Working Principle of SCSR"},{"t":"p","c":"SCSR is a page module that runs in single-file mode without using the o-page tag, allowing rendering on the page. Specifically, the template code of the page module is directly placed within the o-app."},{"t":"p","c":"Below is an example of SCSR, which shows how to render the content of a page module directly on the page:"},0,{"t":"p","c":"Based on the example above, the content within the <scsr:module> tag will be rendered directly on the page when the module named \"example-module\" is loaded."},{"t":"p","c":"To use this feature, you need to have the appropriate module defined and registered in your SCSR framework. By using the module name as the value of the name attribute, you can easily embed the content within the module on any page."},0,{"t":"p","c":"Through SCSR, the content inside the template tag will be directly rendered on the page, and this part of the content is actually the page module in single-file mode."},{"t":"p","c":"Continuing with the example of the home.html page, let's create a help page:"},0,{"t":"p","c":"After clicking \"GO TO HELP\" on the home.html page, the smooth transition to the help.html page is achieved, realizing the smooth transition effect of client-side rendering."},{"t":"h","c":"Caveat"},{"t":"p","c":"All pages using the SCSR scheme must keep the referenced resources consistent, except for descriptive contents such as title, meta:description, keywords, and page template content, to ensure consistent experience after page navigation and refresh."},{"t":"h","c":"About SSR Solution"},{"t":"p","c":"The current SCSR solution is actually more similar to a SSG (Static Site Generation) solution because it pre-renders the pages into static content and then interacts with them through the client. ofa.js has provided a relatively independent component encapsulation solution, allowing frontend developers to encapsulate components and combine them with traditional backend rendering solutions (such as website rendering frameworks in languages like Node.js, Go, Java, PHP, etc.), enabling backend developers to quickly use these encapsulated components to build high-quality web pages."},{"t":"p","c":"We plan to provide a complete Server-Side Rendering (SSR) solution in the future. The principle of this solution is to first obtain the element content of the next page, and then compare it with the current page's tag content in order to dynamically add, delete, and modify attribute values. However, it is important to note that this SSR solution can be time-consuming because it involves complex element comparison and modification operations."},{"t":"p","c":"ofa.js is an emerging framework, and the author's limited spare time means that the SSR solution has not been fully developed yet. However, if ofa.js gains more users in the future and there is a strong demand for an SSR solution, the author will continue to improve and develop this solution. Currently, the author is focusing on the stability and feature expansion of the framework, and welcomes user feedback and suggestions to better meet user needs in the future."}]}},"others":{"data-sharing":[{"t":"h","c":"Data Sharing"},{"t":"p","c":"ofa.js is different from other third-party frameworks by not adopting a traditional state management pattern. The author believes that state updates should be seamless, meaning that changing the data should automatically trigger data updates."},{"t":"p","c":"ofa.js has excellent data sharing capabilities. Its instances are developed based on the data sharing library Stanz. The objects on the instances are all synchronous. If you want to achieve data sharing, you just need to create a separate Stanz object and let all components refer to it directly."},{"t":"p","c":"The following example demonstrates how to share data:"},0,0,0,0,{"t":"p","c":"In the above example, two components write data to themselves during the attached lifecycle. Then, the obj in the component becomes the shared data. After the detached lifecycle, the previously shared data is set to null to ensure data recycling."},{"t":"h","c":"Caveat"},{"t":"p","c":"Due to data sharing, it is necessary to ensure that data is recycled at the appropriate time to avoid memory leaks."},0],"about-micro-frontend":[{"t":"h","c":"About Micro Frontends"},{"t":"p","c":"Micro frontend is a frontend architectural pattern aimed at helping teams build and maintain large, complex frontend applications more effectively. It draws inspiration from the microservices architecture by breaking down the frontend application into smaller, independent parts that can be developed, tested, and deployed by different teams."},{"t":"p","c":"During the process of continuously expanding traditional monolithic front-end applications, they may become difficult to maintain and scale. The goal of micro frontends is to split the application into smaller and more manageable modules, enabling development teams to independently develop and deploy these modules, thereby improving team efficiency and application maintainability."},{"t":"p","c":"ofa.js has inherent micro front-end features. The key difference between it and other frameworks is that components, pages, and applications developed with ofa.js do not require pre-compilation. In comparison to frameworks like React, Vue, and Angular, which require a build step in a Node.js environment to generate client-side code, ofa.js allows development code to be directly hosted on a static server without additional build steps. This enables real-time viewing, usage, and execution."},{"t":"p","c":"ofa.js conforms to the characteristics of micro frontends:"},{"t":"l","c":"1. Independent Deployment: Each component and page can be developed, tested, and deployed independently, enabling teams to release new features and resolve issues more quickly.\n\n2. Integration: Applications developed based on ofa.js can combine different modules together. This can be achieved through sharing compositions via applications, pages, components, etc.\n\n3. Independent Teams: Each frontend module (component/page/application) can be developed and maintained by an independent team, encouraging autonomy and innovation within teams.\n\n4. Shared Resources: In the ofa.js project, there are usually shared resources such as styles, components, and pages to ensure consistency and efficiency.\n\n5. On-demand Loading: Applications in ofa.js can load modules as needed, enhancing application performance and loading speed."},{"t":"p","c":"Although ofa.js cannot directly develop components using frameworks such as Vue and React, components developed based on ofa.js can be used by Vue and React. This provides developers with different technology stacks with greater flexibility and extensibility."},{"t":"p","c":"Using Web Components in Vue:"},{"t":"l","c":"- Vue Web Component Wrapper\n- Integrating Vue with Web Components\n- How to Use Web Components in Vue"},{"t":"p","c":"Using Web Components in React:"},{"t":"l","c":"- Using Web Components with React\n- Using Web Components in React\n- Integrating Web Components into React"}]}}