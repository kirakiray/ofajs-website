{"cases":{"index":[0,{"t":"h1","c":"Quick Start"},{"t":"p","c":"To get started, simply integrate the ofajs project into your project by importing the CDN address:"},0,{"t":"p","c":"This is a simple example that demonstrates how to use ofa.js to modify the content of DOM elements:"},{"t":"h2","c":"Instructions"},{"t":"p","c":"After introducing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that meets the criteria, where xxx is the standard CSS selector content."},{"t":"p","c":"In the above example, we used the $ symbol to select three elements with different ids and modified their content by setting the text, html, and value attributes."},{"t":"p","c":"To learn more about available properties and methods, please refer to the API documentation."}],"event":[0,{"t":"h1","c":"Event Response"},{"t":"p","c":"You can use the on method to bind events. Events are the most fundamental concept in development. Applications rely on the triggering of events to generate feedback and achieve interactivity."},{"t":"p","c":"The following example demonstrates how to bind a click event:"},{"t":"p","c":"In this example, we selected the button element using $ and bound the click event using the on method. When the button is clicked, it triggers a callback function that changes the text content of the target element to \"Hello, world!\"."},{"t":"p","c":"If you want to learn more about the available event types, please refer to the Events documentation."}],"simple-component":[0,{"t":"h1","c":"Creating and Using Components"},{"t":"p","c":"Once the loading of ofa.js is completed, a global component named \"load-module\" will be registered. You can use the abbreviation \"l-m\" to refer to it. It is used in a similar way as the \"script\" tag, by using the \"src\" property to refer to the address of your developed component."},{"t":"p","c":"Now, let's start creating our own component. First, create an HTML file with the same name as the component."},{"t":"p","c":"In the component file, first add a template element and add the component property. Place the content that the component needs to render inside this template element. Finally, this content will be rendered into the component's Shadow DOM. Shadow DOM is isolated from the external environment to prevent contamination of the external environment."},{"t":"p","c":"Next, simply use the l-m component to reference the component you have developed. On the page, just use the tag of the component you defined."},{"t":"p","c":"The component name for registration can only use lowercase letters of the alphabet and hyphens (-), and must include at least one hyphen. This naming convention must be followed."},{"t":"p","c":"Through this example, you can learn how to create a component called my-comp and use it on another page. You can also set the style of the component by linking an external CSS file."}],"slot":[0,{"t":"h1","c":"Component Slot"},{"t":"p","c":"By adding the <slot></slot> tag in the template, you can place the content inside the corresponding component label's slot when using the component."},{"t":"p","c":"Custom components do not have a defined 'display' property by default, so it needs to be defined manually. In the component's style, the ':host' selector can be used to add styles specific to the component itself."},{"t":"p","c":"This example demonstrates how to create a component called simple-btn. The template of the component includes a slot where content can be inserted into the component. The component is styled by adding the :host selector to its styles. In another page, the simple-btn component is referenced using the l-m component and content is inserted into it."}],"render-text":[0,{"t":"h1","c":"Text rendering"},{"t":"p","c":"In the component file, you can add a script tag to write the logic code of the component. You can set component parameters through the exposed default object."},{"t":"p","c":"data parameter is used to define the default data for component elements. Once the instantiation is complete, you can use template syntax."},{"t":"p","c":"Text rendering is wrapped in double braces, that is {{xxx}}, where xxx represents the component's property name."},{"t":"p","c":"This case demonstrates how to render the val property of component elements."}],"get-set-comp":[0,{"t":"h1","c":"Get and Modify the Value of a Component Instance"},{"t":"p","c":"From the outside, you can also access or modify the data of the components."},{"t":"p","c":"The example demonstrates how to manipulate the data of a component externally."}],"attribute-transmission":[0,{"t":"h1","c":"property Propagation"},{"t":"p","c":"The attrs parameter and the data parameter are similar in function. The data set in attrs will be merged into data, but the data in attrs will be reflected in the characteristics of the component."},0,{"t":"p","c":"When using components externally, data can also be passed to the component internally through attributes. It should be noted that data passed through attributes can only be of string type."}],"property-transmission":[0,{"t":"h1","c":"Property Binding"},{"t":"p","c":"By using props binding in template syntax, you can apply component data to element attributes within the template."},{"t":"p","c":"The usage is to add the property :name=\"key\" to the element, where name is the property name to be set for the target element, and key is the property key that you want to pass in your custom component."},{"t":"p","c":"Previously, we mentioned using selectors to set properties, but here we introduce property passing syntax to set properties;"}],"bind-event":[0,{"t":"h1","c":"Event Binding"},{"t":"p","c":"In the component, you can use the on property to bind events and enable interactivity for the component. Here is a demonstration of how to bind events in a component to achieve interactive effects."},{"t":"p","c":"The proto parameter is used to define the methods of the component itself. These methods can be used internally within the component or can be executed externally after obtaining the component through a selector."},{"t":"p","c":"on:click=\"xxx\" can be followed by either a method name defined within the component or a function expression. If using a function expression, there is no need to explicitly write the this keyword, as the variable scope will automatically be bound to the component itself."},{"t":"p","c":"If you want to learn more about the available event types, please refer to the Events documentation."}],"inject-host":[0,{"t":"h1","c":"inject-host Component"},{"t":"p","c":"Given the isolation of Web Components, it is difficult to directly modify the styles of elements within component slots. To address this problem, ofa.js provides a component called inject-host; the inject-host component injects styles into the host layer, allowing for more flexible configuration of the component's appearance."},{"t":"p","c":"It should be noted that using this component may affect the styles of the host layer. Therefore, when intruding styles, naming conventions should be followed to avoid affecting the styles of the host."},{"t":"p","c":"In the example, we defined the comp-two component, which internally uses the inject-host component to inject styles. This allows us to style the elements inside the comp-two component using the injected styles without affecting other components."},{"t":"p","c":"At the same time, special attention should also be paid to the following content: "},{"t":"l","c":"- By adding <style> tags within inject-host, we can define specific styles for components. These styles will only affect the elements within the current component and will not extend to other components.\n- When injecting styles, it is important to avoid using common selectors that may affect the styles of other components. It is necessary to maintain the uniqueness and specificity of the selectors.\n- inject-host can also inject external stylesheet files using the <link rel=\"stylesheet\" href=\"target/style.css\"> format."},{"t":"p","c":"In the entire example, by using inject-host in the comp-two component, we can flexibly set and apply the styles within the component without breaking the styles of other components."}],"nested-component":[0,{"t":"h1","c":"Nested Components"},{"t":"p","c":"It is not a wise choice to put all excessive logic in one component; we can separate the logic into another component and import it in the current component using the l-m approach."},{"t":"p","c":"In the case, the nested component named CompTwo is imported using <l-m src=\"./comp-two.html\"></l-m>."},{"t":"p","c":"By using <comp-two :txt=\"val\"></comp-two>, a nested component is used and the val property of the current component is passed to the nested component as txt property. This way, the nested component can render using the passed data."},{"t":"p","c":"In <comp-two></comp-two>, we used nested components without passing any properties. The usage here depends on the logic and design of the nested component itself."},{"t":"p","c":"As long as a component is successfully loaded, it can be used anywhere with its corresponding name. Even if the \"l-m\" component is loaded multiple times in different places, it will not cause the component to be loaded multiple times. This mechanism ensures component reuse and consistency."}],"event-passing":[0,{"t":"h1","c":"Event Propagation"},{"t":"p","c":"Besides listening for native events, on can also be used to listen for custom events, which is very important for event communication between components. Custom events are triggered through the emit method. By triggering custom events, custom data can be passed to the receiving party."},{"t":"p","c":"If you need to cross Shadow DOM boundaries between components to trigger an event, you can add the composed property."},{"t":"p","c":"In the following example, we will learn how to use the emit method to pass events between nested components."}],"sync":[0,{"t":"h1","c":"Two-way Data Binding"},{"t":"p","c":"By using the sync syntax, you can establish real-time bidirectional associations between user interface interactive elements (such as input boxes or custom components) and data models."},{"t":"p","c":"The following example demonstrates how to use the sync property in a component to achieve two-way data binding between an input box and a data model:"},{"t":"l","c":"- In the data parameter, we defined a data called testText and set its initial value to \"I am testText\".\n- Using sync:value=\"testText\" represents a two-way data binding between the value of the input box and the testText data. Therefore, when the user enters content in the input box, the testText data will be updated in real time, and vice versa.\n- Similarly, using sync:txt=\"testText\" represents a two-way data binding between the txt property of the custom component and the testText data. When the txt property of the component changes, the testText data will be updated in real time, and vice versa."},{"t":"p","c":"Through two-way data binding, you can easily establish a connection between the user interface and the data model, so that changes in data can be automatically reflected in the interface, and user input on the interface can immediately affect the data model."},{"t":"p","c":"It is worth noting that data synchronization can only transmit strings or numbers, and cannot transmit other data types."}],"condition":[0,{"t":"h1","c":"Conditional Rendering"},{"t":"p","c":"In addition to template syntax, the template also includes template components."},0,{"t":"p","c":"Conditional rendering allows you to dynamically insert different content within a component based on specific conditions. Here is an example demonstrating how to use conditional rendering within a component."},{"t":"p","c":"In this example, we create a component called test-demo. The component contains a button that increments the count property. By using the x-if, x-else-if, and x-else tags, we implement the logic for conditional rendering."},{"t":"l","c":"- The x-if tag accepts a value property to define a condition. If the value of value is true, the content inside x-if will be rendered. In this example, if count is an even number, red text will be displayed.\n- The x-else-if tag also accepts a value property to define a condition. If the previous conditions are not met and the value of value is true, the content inside x-else-if will be rendered. In this example, if count is a multiple of 3, blue text will be displayed.\n- The x-else tag does not require a value property. It will render its content when none of the previous conditions are met. In this example, if count is neither an even number nor a multiple of 3, green text will be displayed. The x-else tag can also be placed immediately after x-if."},{"t":"p","c":"Through this method, you can dynamically render different content based on different conditions, achieving flexible interaction and display effects."}],"fill":[0,{"t":"h1","c":"Fill Rendering"},{"t":"p","c":"Fill rendering (x-fill) templates in front-end frameworks are similar to the concept of list rendering. It allows you to dynamically render a set of microcomponents based on a data collection."},{"t":"p","c":"During the filling and rendering process, you can use the following special variables: "},{"t":"l","c":"- $data: Represents the data of the fill item. By manipulating $data, you can obtain or modify the data of each fill item.\n- $index: Represents the index of the current data item in the data collection.\n- $host: Represents the current component itself. If you want to obtain the data of the component or call the component's methods, you need to use $host to access the component."}],"fill-temp":[0,{"t":"h1","c":"Recursive Filling and Rendering"},{"t":"p","c":"Filling rendering allows you to render data using independent templates, with the addition of the name property to the <template> element for naming purposes. This allows you to achieve data rendering with nested structures, thereby creating more complex components."},{"t":"p","c":"When using x-fill for template rendering, you just need to pass the corresponding template name to the name property, and the content of the independent template can be rendered. In addition, fill rendering also supports recursive filling, which means that the same template name can be used inside the template to achieve nested filling."},{"t":"p","c":"In the example, we defined a standalone template named \"item\" and passed the corresponding template name when using \"x-fill\". This way, each item in the data will be rendered using this template, and the template can be recursively filled with the same template name again. This approach allows you to flexibly handle data with nested structures and achieve more complex component rendering."}],"life-cycle":[0,{"t":"h1","c":"Lifecycle"},{"t":"p","c":"Lifecycle hooks provide an opportunity to execute code at different stages of a component. In ofa.js, there are five main lifecycle hooks, which are created, ready, watch, attached, and detached."},{"t":"l","c":"- created(): Called when the component is created, at this time the shadow root has not started rendering. You can perform some initialization settings here, but you cannot access the elements inside the shadow root.\n\n- ready(): Called after the shadow root has finished rendering, usually used for component initialization logic. At this stage, you can access and manipulate the elements inside the shadow root, as well as perform other operations that need to be executed after rendering is completed.\n\n- watch: Listen for changes in data by defining a watch object. After the ready event, the corresponding value on the data object will trigger a watch. Afterwards, whenever the value of the corresponding key changes, the corresponding function in the watch object will be triggered.\n\n- attached(): Called when the component is added to the document, at this time you can perform operations that interact with the external environment, such as obtaining the appearance of the component or initializing shared data.\n\n- detached(): Called when the component is removed from the document. At this stage, you can perform cleanup work, cancel interactions with the external environment, and release resources."}],"form-data":[0,{"t":"h1","c":"Form Data"},{"t":"p","c":"In many applications, handling form data is a common task. To simplify this process, ofa.js provides a secondary abstraction for handling form data, offering the formData method. With this method, you can easily map the values of form elements to an object, and automatically update the data of this object when the values of the form elements change, and vice versa."},{"t":"p","c":"By using the shadow property, you can access the content of the Shadow DOM root node of a component. This allows you to access and manipulate elements and styles within the Shadow DOM from inside the component."},{"t":"p","c":"In this example, we can see how to use the formData method to automatically map form data to the object fdata. This allows you to get or modify the values of form elements by manipulating the fdata object, and these changes will be automatically synchronized to the corresponding form elements."}],"custom-form-element":[0,{"t":"h1","c":"Custom Form Components"},{"t":"p","c":"Using ofa.js, you can easily develop custom form element components with standard form features. Just add the value property and set the name property to your custom component, and your homemade component can be used as a standard form element. By updating the value property of the component, you can interact with the form element."},{"t":"p","c":"When initializing formData, the selector features of custom components need to be added to the parameters (even though the default parameters for the formData method are \"input,select,textarea\"). This allows formData to be linked with custom components."},{"t":"p","c":"In this example, we implement an editable text input box using the custom component custom-input. This component is used as a form element and interacts with data using the value property. When using the formData method, we add \"input, custom-input\" as parameters to correctly initialize the form data."}],"use-page":[0,{"t":"h1","c":"Use Page Components"},{"t":"p","c":"Once ofa.js is loaded, a page component called o-page will be automatically added to the global scope. This component is used to load page modules, which are a special type of component module that is not registered as a custom tag, but loaded through the o-page component."},{"t":"p","c":"Page modules are similar to component modules, but with a few differences. Page modules use the page property to define templates instead of the component property. The development logic for page modules is the same as for component modules, using the same template syntax, template components, and so on. However, page modules cannot use the attrs feature because page parameters are usually passed via URL, not via data or attrs."},{"t":"p","c":"In the example, the o-page component is used to load the page.html page module. The template is defined in the page module using the page property, and then an object is returned through a JavaScript function to set the data. The query parameter count in the URL will be passed to the page module and used to initialize the data. Button click events within the page can update the data and render it in the page."}],"use-app":[0,{"t":"h1","c":"Using the app component"},{"t":"p","c":"In ofa.js, you can use the o-app component to create the layout structure of the entire application and load different page modules within it. By using the o-app component, o-page component, and page modules, you can build the page structure of the entire application and implement navigation between pages."},{"t":"p","c":"When the o-page component is inside o-app, you can use the <a> tag with the olink property to achieve page navigation. This navigation will not affect the current page, but will only navigate within o-app, similar to using an <iframe>."},{"t":"p","c":"If the o-page component is within o-app, you can also use the following method:"},{"t":"l","c":"- Use the goto method to navigate to another page.\n- Use the back method to return to the previous page.\n- Use the replace method for replacing the current page during navigation."},{"t":"p","c":"By using the o-app component, you can build the layout structure of the entire application and load different page modules in it. At the same time, the routing function provided by o-app makes it more convenient and flexible to navigate between pages."},{"t":"p","c":"In this example, we create an application layout using the o-app component and then load a page module page1.html within it."},{"t":"p","c":"In the page1.html page module, we defined a title and a button. Clicking the button will navigate to another page module page2.html. We also added a link with the olink attribute, and clicking the link will also navigate to page2.html."},{"t":"p","c":"In the page2.html module, we also defined a title and a button, clicking the button will go back to the previous page, implementing page navigation."}],"app-config":[0,{"t":"h1","c":"Configure app parameters"},{"t":"p","c":"You can configure the parameters of the application by setting external modules for the o-app tag."},{"t":"p","c":"These parameters are an ES module, and you can configure the following parameters:"},{"t":"l","c":"- home: The homepage of the application, which is the page displayed when it is initially loaded.\n- loading: The content displayed while modules are being loaded when navigating between pages in the application. You can provide a string as the loading content.\n- pageAnime: The animation effect used when navigating between pages, defined as an object with CSS style properties.\n  - current: Represents the style of the page when it is the current page.\n  - next: Represents the style of the page when it is entering.\n  - previous: Represents the style of the page when it is exiting."},{"t":"p","c":"Through this method, you can customize parameters such as the home page, loading style, and page transition animation according to the needs of the application, thus bringing a more personalized experience to the application."}],"app-loading":[0,{"t":"h1","c":"Customizing loading for the app"},{"t":"p","c":"The following is an example of customizing the loading of the o-app component. In this example, we have created a beautiful progress bar for loading, which will gradually grow during the page loading process and reach 100% directly after loading is complete, then delete the loading element."},{"t":"p","c":"You can copy and use the following code to customize the loading effect of your application:"},0,{"t":"p","c":"With this code snippet, you can add a unique loading effect to your application, providing users with a better experience during page transitions."}],"set404":[0,{"t":"h1","c":"Configuration 404 page"},{"t":"p","c":"In the configuration module of the application, customize the content displayed when the page fails to load by setting the fail function."},{"t":"p","c":"In this example, the first line of the error message that displays when the page fails to load will be shown;"},0],"nested-page":[0,{"t":"h1","c":"Nested Pages"},{"t":"p","c":"Some application UIs are composed of nested pages with multiple layers, such as a common top or side navigation. You can use the parent property to represent the parent page that the current page is nested in."},{"t":"p","c":"The production method of the parent page is similar to component development. You need to create a page that contains the entire framework layout, and then place the nested child pages in the slot."},{"t":"p","c":"This example demonstrates how to create nested pages, where page1.html and page2.html are subpages and layout.html is the parent page. The parent page layout.html contains the entire framework layout, while the subpages are linked to the parent page using the parent property, indicating that they should be nested within the parent page."},{"t":"p","c":"When switching pages, the \"routerChange\" event will be triggered. During page initialization and page switching, you can use the app.current property to get the current page address and adjust the activation status of the tabs in the page."}],"use-scsr":[0,{"t":"h1","c":"Using SCSR Solution"},{"t":"p","c":"In this example, please click the <span style='font-family: \"iconfont\"'>&#xe7cb;</span> button to open and try in a new page;"},{"t":"p","c":"SCSR, short for Static Client-Side Rendering, is also known as static client-side rendering. It is a variant of CSR (Client-Side Rendering) that preserves the user experience of CSR and allows web pages to be crawled by search engines while being in a static state."},{"t":"p","c":"The current website adopts the SCSR solution for construction."},{"t":"p","c":"SCSR achieves rendering on the page by directly running the single-file mode of the page module, without using the o-page tag. Specifically, the template code of the page module is directly nested inside the o-app."},{"t":"h2","c":"Caveat"},{"t":"p","c":"For all pages using the SCSR scheme, except for descriptive content such as title, meta:description, keywords, and page template content, all referenced resources must remain consistent to ensure a consistent user experience after page redirection and refresh."}],"use-hash-router":[0,{"t":"h1","c":"Use hash router"},{"t":"p","c":"Just use the o-router component to link the routing inside the app component to the current webpage. Once the page is bound to the router, the routing state of the page can be maintained even when the page is refreshed."},{"t":"p","c":"In this example, please click the <span style='font-family: \"iconfont\"'>&#xe7cb;</span> button to open and try in a new page."},0],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"By setting aliases, users can conveniently use shared resources, especially for making cross-domain shared components more easily access the same version of resources."},{"t":"p","c":"In this example, we set up an alias using the lm.config method, mapping the alias @obook to https://cdn.jsdelivr.net/npm/obook. Now, when we use @obook as a prefix, it will automatically map to the specified URL."},0,0,0,0,{"t":"p","c":"By using the alias @obook, we introduced the resource \"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\" in the l-m tag, which allows components from different domains to access shared resources more conveniently without needing to know the specific resource address. This enhances code maintainability and facilitates cross-domain resource sharing."},{"t":"h2","c":"Caveat"},{"t":"p","c":"When setting aliases, please keep the following points in mind:"},{"t":"l","c":"- Aliases keys must start with @, such as @example."},0,{"t":"l","c":"- Do not set aliases with the same name repeatedly, otherwise errors will occur."},0],"sync-state":[0,{"t":"h1","c":"State Synchronization"},{"t":"p","c":"Sometimes it is necessary for multiple component instances or pages to share the same piece of data, and this is where the functionality of state synchronization is needed."},{"t":"p","c":"Use the $.stanz method to create shareable data; if you need to share this data in a component, you should bind the data to the component in the attached method."},{"t":"p","c":"Note: It is necessary to clear the bound data during the detached cycle, otherwise there will be a memory leak."},{"t":"p","c":"In this example, we demonstrate how to use state synchronization to achieve the switch of dark mode. First, we use the $.stanz method to create a data object named isDark, which can be shared among multiple components. This allows different component instances to share data and achieve the switch of dark mode."}]},"docs":{"get-started":{"elements-and-events":[{"t":"h1","c":"Get Elements and Events Related"},{"t":"p","c":"This chapter aims to enhance understanding of the previous chapter, including selecting elements and event binding."},{"t":"h2","c":"Selecting Elements"},{"t":"p","c":"In the previous chapters, we have learned how to access a specific element from the global scope using the $ symbol. Next, we will introduce other methods of accessing elements."},{"t":"h3","c":"Look for an element within an element"},{"t":"h4","c":"Using $(\"xxx\").$('xxxx') method"},{"t":"p","c":"$(\"xxx\").$('xxxx') is a way to select a parent element first and then find the child element that meets the condition inside it. In this example, $(\"xxx\") selects a parent element, and then uses $('xxxx') to find the child element that meets the condition within that parent element."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the example above, first select the parent element with the parent class using $(\".parent\"), and then use $(\".child\") to search for the child element with the child class within this parent element. Then modify the text content of the child element to \"Modified child element\"."},{"t":"h3","c":"Using $('xxx xxxx') method"},{"t":"p","c":"$('xxx xxxx') is used to find elements that match the second selector condition within the global scope, and then search for elements that match the first selector condition within these elements. This approach allows for directly finding the desired child elements in one step."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the above example, you directly use $('div .child') to find the child elements with the child class and modify their text content to \"Modified child element\"."},{"t":"h3","c":"Selecting Multiple Elements"},{"t":"h4","c":"Use $.all('xxx') to search for global elements."},{"t":"p","c":"The $.all('xxx') method is used to find all elements on the page that meet the selector condition and return them as a collection of elements. This allows for batch operations on multiple elements in the page."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the example above, $.all(\"p\") is used to find all the p tag elements on the page and perform a batch operation on them, modifying their text content to \"Modified Paragraph 1\", \"Modified Paragraph 2\", and \"Modified Paragraph 3\"."},{"t":"h3","c":"Finding all elements that meet the conditions within an element"},{"t":"p","c":"In addition to searching for elements globally, you can also search for all matching child elements within a specific element using the following syntax: $('xxx').all('xxxx')."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the above example, first use $(\".container\") to find elements with the class container, then use .all(\".item\") to find all child elements with the class item within that container, and perform batch operations on them, modifying their text content to \"Modified Item 1\", \"Modified Item 2\", and \"Modified Item 3\"."},{"t":"h2","c":"Events"},{"t":"p","c":"We have already discussed the usage of on to bind events. Now let's introduce a few methods related to events."},{"t":"h3","c":"Usage documentation for the off method"},{"t":"p","c":"The off method is used to remove event handlers that have been bound using the on method. When a handler for a certain event is no longer needed, the off method can be used to remove it from the element, preventing it from being executed repeatedly or causing memory leaks."},{"t":"h4","c":"Syntax"},0,{"t":"l","c":"- selector: Select the element to remove the event handler from.\n- eventName: The name of the event to be removed.\n- eventHandler: The event handler to be removed."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the above example, when the button is clicked, a dialog displaying \"Button clicked!\" will pop up. However, after 5 seconds, the click event handler is removed using the off method, so the dialog will not pop up again when the button is clicked."},{"t":"h3","c":"Documentation for the use of the one method"},{"t":"p","c":"one method is used to bind event handlers, but this handler will only be executed once when the event is triggered for the first time. After being executed once, the event handler will be automatically removed to avoid repetitive triggering."},{"t":"h4","c":"Syntax"},0,{"t":"l","c":"- selector: Element to bind event handler to.\n- eventName: Event name to bind.\n- eventHandler: Event handling function to be executed."},{"t":"h4","c":"Example"},0,0,0,0,{"t":"p","c":"In the above example, when the button is clicked, a dialog box will appear displaying \"Button clicked once!\". However, after the first click, the event handler will be removed, so subsequent button clicks will not trigger the dialog box."},{"t":"h3","c":"Documentation for the emit method"},{"t":"p","c":"emit method is used to manually trigger a specific event bound to an element. By using the emit method, we can trigger the execution of event handling functions without performing any actual operations."},{"t":"h4","c":"Syntax"},0,{"t":"l","c":"- selector: Select the element to trigger the event.\n- eventName: The name of the event to trigger."},{"t":"h4","c":"Example"},0,{"t":"p","c":"In the example above, the emit method is used to manually trigger the button's click event. As a result, a dialog box will appear displaying \"Button clicked!\" even though the button was not actually clicked."},{"t":"p","c":"Note: Using the emit method does not simulate mouse clicks or other actual events. It simply directly calls the bound event handling function. Therefore, if you want to trigger the execution of an event under specific circumstances, you can use the emit method."},{"t":"p","c":"When you bind an event, sometimes you may want to stop the event from further propagation (bubbling) or cancel the default behavior of the event. Below, we will introduce how to prevent event propagation and cancel default events after the event is triggered."},{"t":"h3","c":"Stop Event Bubbling"},{"t":"p","c":"Event bubbling refers to the propagation of an event along the DOM tree when it is triggered on an element, sequentially triggering the same type of event on parent elements. If you want to stop the event from further bubbling after handling it on a specific element, you can use the event.stopPropagation() method."},{"t":"p","c":"Example code: "},0,{"t":"p","c":"In the example above, when you click the button \"Click Me\", it will display \"Button Clicked!\" but not trigger \"Inner Div Clicked!\" and \"Outer Div Clicked!\". This is because we called event.stopPropagation() in the button's click event handler, which prevents the event from further propagation."},{"t":"h3","c":"Cancel Default Behavior of an Event"},{"t":"p","c":"Some events on certain elements have default behaviors when triggered. For example, clicking a submit button will cause the form to be submitted, clicking a link will navigate to the link's address, and so on. If you want to prevent the default behavior of an event, you can use the event.preventDefault() method."},{"t":"p","c":"Example code: "},0,{"t":"p","c":"In the example above, when you click the \"Submit\" button, it will display \"Hello, {name}! Form submission prevented.\", but it will not trigger the \"Form Submitted!\" alert. This is because we called event.preventDefault() in the event handler for the submit button, preventing the form's default submission behavior."}],"hello-world":[{"t":"h1","c":"First Case"},{"t":"p","c":"Here is an example, when the button is clicked, change the text to \"Hello World\":"},0,0,0,0,{"t":"p","c":"When you click the button, the bold \"Hello World\" text will be displayed."},{"t":"p","c":"Now, let's explain the basic concepts in detail."},{"t":"h2","c":"Selectors"},{"t":"p","c":"After importing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that matches the specified condition, where xxx is a standard CSS Selector. You can click on the link to view the specific selector syntax."},{"t":"p","c":"Following is an example: "},0,0,0,0,{"t":"p","c":"In the example above, after one second of opening the page, the text content of the p tag, #desk, and .logger will be changed respectively."},{"t":"h2","c":"Event Binding"},{"t":"p","c":"Once you have successfully selected an element, you can bind events to it. As mentioned in the previous \"Hello World\" example, we bind a click event to the element with the ID \"btn\". When the button is clicked, the bound function will be executed."},{"t":"p","c":"You can click to jump and view example events section to learn some examples of event binding."},{"t":"p","c":"Refer to Web Events for a complete list of all available events."},{"t":"h2","c":"Properties"},{"t":"p","c":"In the above two examples, we have demonstrated the use of the html and text attributes."},{"t":"p","c":"You can also get the content of an element through the html or text attributes, as shown below:"},0,0,0,0,{"t":"p","c":"In this example, we assign the HTML content within the #t1 element to the #t2 and #t3 elements."}],"index":[{"t":"h1","c":"Getting Started"},{"t":"h2","c":"How to Use"},{"t":"h3","c":"Direct Quote"},{"t":"p","c":"You can directly reference ofa.js to your page by using the CDN address: "},0,{"t":"h3","c":"Install via npm"},{"t":"p","c":"First, install ofa.js in your project: "},0,{"t":"p","c":"Then import the ofa.js module into the project:"},0,{"t":"h3","c":"Use"},{"t":"p","c":"After referencing the resource, ofa.js will set a $ property on the global scope, and all functionalities are accessed through $. Its usage will be explained in detail in the following tutorials."},{"t":"p","c":"Usually, we recommend using the direct injection method to add ofa.js, while the npm method is used for compatibility with frameworks such as React and Vue."}],"basic-concept":[{"t":"h1","c":"Basic Concepts of Instances"},{"t":"p","c":"The $ instance encapsulates elements on the page and can be used to select existing elements as well as to create and manipulate new elements. In this chapter, we will introduce how to create new elements and perform some operations on the $ instance."},{"t":"h2","c":"Create New Elements"},{"t":"p","c":"Through $ examples, we can directly create new elements and manipulate them, for example: "},0,0,0,0,{"t":"p","c":"In the example above, we created a new div element using $('<div style=\"color:red\">I am text</div>') and added it to the body."},{"t":"h2","c":"Getting Child Elements"},{"t":"p","c":"For instances obtained through $, they do not have the children property like DOM elements. However, we can access the direct child elements of an instance through array indexing."},0,0,0,0,{"t":"p","c":"In the above example, we obtained the div element and accessed the first and second p elements using indexing. At the same time, we also used $div.length to get the number of child elements."},{"t":"h2","c":"Operating on Subelements"},{"t":"p","c":"Through the $ instance, we can also directly use array methods to manipulate child elements, such as push and pop:"},0,0,0,0,{"t":"p","c":"In the above example, we obtained instances of all p elements using $ and added a new div element as a child element using the push method. Then, we removed the last child element using the pop method."},{"t":"p","c":"Through the examples above, you can understand some basic operations of the $ instance, including creating new elements and accessing and manipulating child elements. The $ instance provides a convenient way to manipulate elements on the page."}],"common-properties":[{"t":"h1","c":"Common properties or methods"},{"t":"p","c":"In the $ instance, in addition to selecting elements with selectors, there are also some commonly used methods provided to facilitate element manipulation and searching."},{"t":"p","c":"You can take a brief look at it, and refer to the API documentation whenever needed in the future."},{"t":"h2","c":"Common Properties"},{"t":"l","c":"- tag: Get the tag name of the target.\n- ele: Get the actual native element of the instance.\n- index: Get the index of the target element within its parent element.\n- text: Get or set the text of the target element.\n- html: Get or set the HTML code of the target element.\n- css: Get or set the style of the target element.\n- style: Get the native style of the target element.\n- classList: Get the native class list of the target element.\n- data: Get the native dataset of the target element."},{"t":"h3","c":"Node Operations"},{"t":"l","c":"- before: Add an element before the target instance.\n- after: Add an element after the target instance.\n- remove: Remove the target element.\n- attr: Get or set the attributes of the target element."},{"t":"h2","c":"Key Features"},{"t":"l","c":"- Form Data: Conveniently bind and retrieve form data"},{"t":"p","c":"If you want to learn more about the API of ofa.js, you can refer to the API documentation."}]},"introduce":[{"t":"h1","c":"ofa.js - Progressive Front-end Framework"},{"t":"h2","c":"What is ofa.js"},{"t":"p","c":"ofa.js is a progressive front-end framework designed to allow developers to enter front-end development and usage processes at the lowest cost. It provides a series of simple yet powerful tools and APIs to make front-end development more efficient and convenient."},{"t":"h2","c":"Purpose of Existence"},{"t":"h3","c":"Replacing jQuery"},{"t":"p","c":"In many small projects, we may not need to introduce large frameworks like React and Vue, but prefer to use jQuery for simple front-end operations. ofa.js improves jQuery's API and replaces many of jQuery's methods with properties, making it more suitable to use ofa.js in many scenarios."},{"t":"h3","c":"Simplify Front-end Development and Usage Process"},{"t":"p","c":"The goal of ofa.js is to simplify the tedious front-end development process. It allows developers to build front-end applications faster without the need to learn complex tools such as Node.js, npm, and scaffolding. With ofa.js, you can go back to the experience of development with just importing a library."},{"t":"h3","c":"Become a silver bullet type front-end development framework."},{"t":"p","c":"ofa.js aims to be a \"silver bullet\" that can solve various frontend development problems and provide comprehensive solutions. It is not just a utility library, but a comprehensive frontend development framework."},{"t":"h2","c":"Features"},{"t":"h3","c":"Easy-to-use Component Development"},{"t":"p","c":"The components developed using ofa.js have almost no learning cost. ofa.js provides a concise and intuitive API, allowing developers to quickly create and integrate components while keeping the code clean and easy to maintain."},{"t":"h3","c":"Built-in modular, state update, and application integration solutions"},{"t":"p","c":"The ofa.js has already integrated solutions such as modularity, state update, and application integration, allowing developers to complete complex front-end development tasks without the need to search for third-party libraries or tools."},{"t":"h3","c":"Officially provided routing and SSG (Static Site Generation) solutions"},{"t":"p","c":"ofa.js also provides official solutions for routing and SSG, helping developers better manage frontend routing and generating static websites to improve application performance and SEO friendliness."},{"t":"h3","c":"Compact code size"},{"t":"p","c":"The code of ofa.js has been carefully optimized, and the size of the compressed .min file is only 38kb (14kb under gzip). This makes ofa.js an efficient front-end framework that can be quickly loaded and used in various network environments."}],"create-component":{"index":[{"t":"h1","c":"Creating and Using Components"},{"t":"p","c":"ofa.js uses basic HTML and JavaScript files to define components, avoiding the introduction of new file types to reduce learning costs. As long as you have a certain understanding of HTML, you can quickly develop and use ofa.js components."},{"t":"h2","c":"Steps before creating a component"},{"t":"p","c":"Before starting to create components, there are some preparations that need to be done. Since creating components involves browser resource requests, if you only double-click to open an HTML file for viewing, it will be viewed under the \"file\" protocol. Under the \"file\" protocol, the loading of JavaScript modules may result in errors. Therefore, you need to prepare a static server to correctly view the components."},{"t":"p","c":"If you are using Visual Studio Code editor, you can simply install a plugin that supports a static server. We recommend using the Live Server plugin."},{"t":"p","c":"After installing the plugin, simply right-click on the demo.html file and select \"Open with Live Server\". The plugin will automatically open the file in static server mode."},{"t":"p","c":"If you are using a different editor, you can also create an Nginx or Apache server as long as it can support static HTML viewing. Doing so will ensure that you can preview and develop your components properly."},{"t":"h2","c":"Create a button component"},{"t":"p","c":"Below, we will create a simple button component named simple-button, which will have a more stylish appearance than native buttons."},{"t":"p","c":"First, create a file named 'simple-button.html' that uses the 'template' tag and add the 'component' property to identify it as a component."},{"t":"p","c":"Then, write the template code for the component in the template. Next, below the template content, add a script tag and put the component's JavaScript code inside it."},0,{"t":"p","c":"After successfully introducing ofa.js, the load-module component will be automatically registered. This is a component used to declaratively reference modules, similar to the script tag. This component will proxy load the specified src modules and preprocess the modules that need to be loaded. In this case, templates will be loaded and the simple-button component will be registered."},{"t":"p","c":"The load-module component can also be abbreviated as l-m to reduce code size."},0,{"t":"p","c":"load-module component is a customized declarative loader library that provides powerful functionality to extend support for various types of files or to perform intermediate processing on JavaScript modules. It has been split into a separate project, and the specific usage documentation can be found at https://github.com/kirakiray/drill.js."},{"t":"h3","c":"Dual File Mode"},{"t":"p","c":"Dual-file mode separates static templates and logic code, making components more clear."},{"t":"p","c":"The logic code is put in a js file, and this js file needs to indicate export const type = $.COMP; to notify the page that it is a component module. In this split mode, the module code can use standard syntax like import in ES Module."},{"t":"p","c":"Button component consists of two files:"},{"t":"l","c":"1. simple-button.html: HTML template and style for the button component."},0,{"t":"l","c":"2. simple-button.mjs: Registration code for the button component."},0,{"t":"p","c":"In the places where this component is needed, use l-m to import this module. Here is an example page using simple-button (dual-file mode)."},0],"parameter-description":[{"t":"h1","c":"Explanation of registration parameters for components"},{"t":"p","c":"In ofa.js, you can define certain specific registration parameters in the component module to configure the component more flexibly. The following explains each registration parameter in detail, accompanied by corresponding examples for demonstration."},{"t":"h2","c":"Basic Parameters"},{"t":"p","c":"Basic parameters are the most basic configuration for registering a component, which includes the following attributes:"},{"t":"h3","c":"tag"},{"t":"p","c":"tag represents the registered component name. When the tag property is not defined, the registered component name remains the same as the file name."},{"t":"p","c":"Example: "},0,{"t":"h3","c":"data"},{"t":"p","c":"data is an object-type property used to add default custom data to the generated component."},{"t":"p","c":"Example: "},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs is an object type attribute, which is also data, but this data is reflected in the attributes of the element, and changes in the attributes are dynamically changed in the data of the component. When there is an uppercase key, the response to the component property is named with a - hump."},{"t":"p","c":"Example: "},0,{"t":"h3","c":"proto"},{"t":"p","c":"In the registration parameter of the component, you can add a proto object to define the methods that need to be added to the component prototype. In this way, when creating an instance of the component, these properties and methods will be added to the prototype of the instance, so that all instances can access and share these methods."},0,{"t":"h3","c":"watch"},{"t":"p","c":"watch is an object type property used to listen to the changes of data. The listener function is placed here. After being successfully registered, the value being listened to will be executed immediately."},{"t":"l","c":"- The function registered with watch will only be triggered once during a single-threaded change. Therefore, even if the value being listened to is modified multiple times within a single thread, it will only be triggered once.\n- The first parameter is the current value.\n- The second parameter is an object that contains the watchers data set. In general, there will only be one object on watchers, and you can obtain the oldValue from this object. When the value being listened to in a single thread is changed multiple times, this data set will record the changes multiple times."},{"t":"p","c":"Example: "},0,{"t":"h3","c":"temp"},{"t":"p","c":"Usually, there is no need to set this variable. It is mainly used in separation mode to specify the address of the component template. When temp is not defined, the HTML file with the same name as the current module will be loaded by default, and this file should be located in the same directory."},{"t":"h2","c":"Merge Variables into Default"},{"t":"p","c":"You can write all exported variables onto default so that it is easier to write."},0,{"t":"h2","c":"Example code"},{"t":"p","c":"The following is a complete example code, including the definition of basic parameters and component templates."},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"You can also use asynchronous functions to define the default data, in order to dynamically return the registration parameters of the component."},{"t":"p","c":"The function function will bring an object containing load, url, and query:"},{"t":"l","c":"- The load method is an asynchronous loading function, used in the same way as asynchronous import loading. You can use const data = await load(xxx) to load asynchronous modules.\n- Modules loaded through load have the same effect as modules loaded through load-module. The load method is a function version of the load-module component. For specific usage, you can refer to the documentation of https://github.com/kirakiray/drill.js.\n- url is the file name of the current module.\n- query is an object converted from the URL parameters when loading this module."},{"t":"p","c":"Below are examples of using default:"},0,{"t":"p","c":"In this example, we demonstrate how to customize the behavior of components using the registration parameters of ofa.js. By configuring these parameters appropriately, you can better adapt to different component requirements and achieve more flexible component development."}],"life-cycle":[{"t":"h1","c":"The Lifecycle of Components"},{"t":"p","c":"In ofa.js, the component lifecycle is triggered by specific hooks at certain points in time. These hooks allow you to have more precise control and interaction. ofa.js has five key lifecycle hooks: created, ready, watch, loaded, attached, and detached, which are triggered at different times."},{"t":"h2","c":"Lifecycle Hooks"},{"t":"h3","c":"Created"},{"t":"p","c":"created lifecycle hook is triggered when a component is created. At this stage, the component's data has not been initialized and the template content has not been rendered. You can perform some initialization operations at this stage or prepare data to be used in later stages."},{"t":"h3","c":"ready"},{"t":"p","c":"ready lifecycle hook is triggered after the component's data and template are initialized, indicating that the component is ready. At this stage, you can access the component's data, and the template has been rendered, allowing you to perform some interactive operations related to the interface."},{"t":"p","c":"If the component template relies on other components, this stage will not wait for the dependencies to be loaded. Therefore, this stage is suitable for adding loading styles to the component, but it is important to wait for the dependencies to be loaded before performing related operations."},{"t":"h3","c":"watch"},{"t":"p","c":"Once the ready stage is completed, the listening function in the associated watch object will be triggered once. Afterwards, when a value of the data changes, the corresponding key's listening function will be triggered again."},{"t":"h3","c":"loaded"},{"t":"p","c":"The loaded lifecycle hook is triggered after all dependencies in the component template have been loaded. This stage ensures that all dependencies are loaded before rendering the component. This is a good time to remove the Loading style added during the ready stage."},{"t":"h3","c":"attached"},{"t":"p","c":"attached lifecycle hook is triggered when the component is added to the document. At this stage, it is suitable for obtaining size-related information of the elements within the component, performing data binding, and global event operations."},{"t":"h3","c":"detached"},{"t":"p","c":"detached lifecycle hook is triggered when a component is removed from the document. During this stage, you can perform some cleanup operations, such as unregistering event listeners or releasing resources, to prevent memory leaks."},{"t":"h2","c":"Examples and Demonstrations"},{"t":"p","c":"The following is an example demonstrating how to use these lifecycle hooks:"},0,{"t":"h2","c":"Lifecycle Flowchart"},0],"web-components":[{"t":"h1","c":"Conventional Knowledge of Web Components"},{"t":"p","c":"ofa.js is a wrapper library based on Web Components technology, aiming to simplify and accelerate the component development process. By hiding complex technical details behind the scenes, it allows developers to focus more on building high-quality components and applications."},{"t":"p","c":"In order to develop components better, it is necessary to learn some knowledge about Web Components. The knowledge points introduced below can not only be applied in ofa.js, but also benefit you when using other frameworks that use Web Components."},{"t":"h2","c":"Shadow DOM Container"},{"t":"p","c":"In Web Components, Shadow DOM provides an isolated container for encapsulating the styles and structure of a component. This means that the styles and DOM structure inside the component will not interfere with the external styles and structure, ensuring the predictability and maintainability of the component."},{"t":"p","c":"In ofa.js, each component has a Shadow DOM container to isolate the internal content of the component. The template content is rendered into this container. The component instance obtained through $ can also access the Shadow DOM container within the component by using the shadow property, thereby achieving manipulation and access to the internal elements of the component."},0,{"t":"h2","c":"Common CSS Selectors in Web Components"},{"t":"p","c":"Web Components provides special CSS selectors for selecting and styling different parts within a component. Here are some commonly used selectors:"},{"t":"h3","c":":host Selector"},{"t":"p","c":"The :host selector is used to select the outer container of the component itself. This selector can be used to define the style of the component."},0,{"t":"h3","c":"::slotted() Selector"},{"t":"p","c":"::slotted() selector is used to select elements that are wrapped by slotted content. This selector can be used in the styles of a component to style the slotted content."},0,{"t":"h2","c":"How to Use Slots"},{"t":"p","c":"Slots are the mechanism in Web Components used to embed external content inside a component. Slots allow developers to pass custom content into the component, enabling more flexible component structures."},{"t":"h3","c":"Single Slot"},{"t":"p","c":"In component templates, <slot> element can be used to define slots. Contents passed from the outside will be inserted into the slots."},0,0,{"t":"h3","c":"Multiple Named Slots"},{"t":"p","c":"Except for the default slot, multiple named slots can also be defined. Named slots allow developers to insert different content into different slot positions."},0,0,{"t":"h2","c":"Usage of the \"slotchange\" event"},{"t":"p","c":"The slotchange event is triggered when the content of a slot changes. You can listen to this event to perform operations related to the content of the slot."},0],"template-syntax":[{"t":"h1","c":"Template Syntax"},{"t":"p","c":"ofa.js provides a series of powerful template syntax that allows you to manipulate component's interface elements and data more flexibly. These template syntax can help you achieve rich interface effects and interactive experiences."},{"t":"l","c":"- Text Rendering: Quickly render text on template files\n- Class: Quickly render class names on template files\n- Sync: Quickly sync data to template files\n- Conditional Rendering: Render content on template files as needed\n- List Rendering: Quickly render array data on template files"}]},"create-app":{"index":[{"t":"h1","c":"Introduction"},{"t":"p","c":"Apart from developing components, ofa.js can also be used to develop fully functional applications."},{"t":"p","c":"ofa.js integrates applications as an o-app component, allowing you to quickly create applications by directly using this tag. This approach simplifies and streamlines the process of application creation."},{"t":"p","c":"In addition, the official ofa.js also provides a complete routing and SSG (Static Site Generation) solution to help developers build more robust applications. These features can speed up the development process, allowing you to focus on the logic and user experience of your application without worrying too much about the underlying details."},0,{"t":"p","c":"Above is a simple application tutorial code example. The development process of the application will be explained step by step."}],"page":[{"t":"h1","c":"Using the o-page component"},{"t":"p","c":"In ofa.js, we have built a custom component called o-page to provide convenience for page development. This component plays a crucial role in application development. When you want to use component template syntax but don't want to create a completely new component, o-page component will be your best choice."},{"t":"h2","c":"Page Modules"},{"t":"p","c":"When creating a single file page module, it is similar to creating a component module. Use the template tag to wrap the template code of the page and add the page property. Inside this tag, you can freely use template syntax to interact with other components or page modules."},0,{"t":"p","c":"In HTML files, use the src property of the o-page tag to specify the file path of the page module. The page content will be rendered inside this component."},0,{"t":"h2","c":"Dual File Mode"},{"t":"p","c":"Dual file mode separates static templates and logic code to make the content of the web page clearer."},{"t":"p","c":"Here are the steps to use the o-page component and page modules:"},{"t":"p","c":"Creating page module: ."},{"t":"p","c":"Similar to creating a component module, create a page module but set the type property to $.PAGE. The available parameters for a page module include temp, data, proto, and watch."},0,{"t":"p","c":"Create page template: "},{"t":"p","c":"In the same directory as the page module, create a page template file named my-page-template.html. In this template file, you can use template syntax for interaction, which is similar to the component template syntax mentioned earlier."},0,{"t":"p","c":"In your HTML file, use the <o-page> tag to use the o-page component, and reference the file path of the page module through the src property. The content of the page will be rendered inside this component."},0,{"t":"p","c":"In this way, when you open the page, the o-page component will dynamically load the my-page.mjs page module and render the page content based on the templates and data in the module. The lifecycle and template syntax of the page module are consistent with the component module, making page development and management more unified and flexible."}],"app":[{"t":"h1","c":"Use o-app Component"},{"t":"p","c":"Using the o-app tag allows you to easily create a complete application window. Here is the step-by-step process for creating an application and configuring it:"},{"t":"p","c":"The text appears to be somewhat dry. We recommend that you go to Application Case Demonstrations for a practical experience."},{"t":"h2","c":"Basic code"},{"t":"p","c":"Create an HTML file and set the 'o-app' tag as the display window for the application. Make sure to set the 'o-app' tag to full screen style so that the application occupies the entire viewport."},0,{"t":"l","c":"2. Create an ES module to set up the configuration data for the application. The configuration data includes the following options:\n\n   - home: String type, the page module address of the application's homepage.\n   - loading: Function type, this function will be executed when the application is loading a new page. The content obtained will be inserted into the application as a loading prompt. After the page is loaded, this loading element will be automatically removed.\n   - fail: Function type, this function will be executed when the application fails to load a page. The value returned will be displayed in the application as a loading failure prompt. The function will have the src address of the failed page and the error object.\n   - pageAnime: Animation configuration for page transitions."},{"t":"p","c":"The following is an example of the configuration data for the application:"},0,{"t":"l","c":"3. Use the o-app tag in HTML files and reference the configuration data es module through the src property."},0,{"t":"p","c":"By following the steps above, you have successfully created an application window using the o-app component. The o-app component will load the page based on the settings in the configuration data, display a loading prompt or a loading failure prompt, and support page transition animations. This way, you can quickly build a fully functional and interactive application."},{"t":"h2","c":"Route Jump"},{"t":"p","c":"In the o-app application, you can easily achieve route navigation, jumping from one page module to another page module. Below are several different ways to perform route navigation."},{"t":"h3","c":"Use <a> tag for route navigation"},{"t":"p","c":"You can use the <a> tag in the HTML of the page to implement routing. You need to specify the href property as the path of the target page module and add the olink property to inform the o-app component that this is a routing link."},0,{"t":"h3","c":"goto"},{"t":"p","c":"You can use the on:click property in the page template to bind a click event and call the goto method on the module for routing."},0,{"t":"p","c":"Uninstall the target element directly."},0,{"t":"h3","c":"Replace Jump and Return Pages"},{"t":"p","c":"Besides the goto method, o-app also supports the replace and back methods."},{"t":"l","c":"- The replace method is used to replace navigation, it replaces the current page's route with the route of the new page."},0,{"t":"l","c":"- The back method is used to go back to the previous page."},0,{"t":"p","c":"It should be noted that the application will maintain the routing state of the components, but the routing data will not be bound to the current browser tab. In this way, you can easily implement page transitions and navigation between pages in the application."},{"t":"p","c":"If you want to bind routes and pages, you can use the o-router component, which we will discuss in detail in the following sections."},{"t":"p","c":"Through the above methods, you can implement flexible routing in the o-app application, allowing users to easily browse different page content."},{"t":"h2","c":"Accessing Apps and Current Pages"},{"t":"p","c":"In various elements (including components) within the application, you can use the app property to access the o-app instance they belong to. This is very useful for operations that require interaction with the entire application."},{"t":"p","c":"You can retrieve the address of the currently active page module through the app.current property."},{"t":"p","c":"Here is an example of usage: "},0,{"t":"p","c":"In the example above, the app tag was retrieved using the selector .app, and then the current active page address was obtained by accessing the app.current property."},{"t":"h2","c":"Tips: Pre-cache the next page"},{"t":"p","c":"In some scenarios, you may already know that the user is about to navigate to the next page. To enhance the user experience, you can pre-cache the page modules of the next page, so that they can be loaded immediately when the actual navigation occurs. This reduces the waiting time for users and makes their experience smoother."},{"t":"p","c":"In the JavaScript code of the current page, call the load method and pass in the module path of the next page. The module will be loaded and cached."},0],"subrouting":[{"t":"h1","c":"Subroute Mode"},{"t":"p","c":"In ofa.js, setting up sub-routes is slightly different from other front-end frameworks. ofa.js uses a more intuitive approach by setting the parent page as a container on the page module to achieve the needs of sub-routes."},{"t":"h2","c":"Set Parent Page Container"},{"t":"p","c":"To create a sub-route, first, the parent parameter needs to be set on the page module of the child page, specifying the page module address of the parent page. This way, when the child page is loaded, ofa.js will automatically wrap the child page in the container of the parent page."},0,{"t":"p","c":"In the above example, the page module of the subpage specifies the address of the parent page container through the parent parameter."},{"t":"h2","c":"Parent Page Container Template Settings"},{"t":"p","c":"The template of the parent page container needs to set a <slot> element so that the child pages can be inserted into the specified position of the parent page. At the same time, make sure that the container element of the <slot> element is set to position: relative. This is very important because the child pages will be absolutely positioned within the parent page container."},{"t":"p","c":"The following is an example template of a parent page container:"},0,{"t":"p","c":"In the above example, by setting a container element with a slot, the subpage will be inserted into the container. Make sure the container element has relative positioning so that the subpage can be positioned relative to the container."},{"t":"p","c":"By using this approach, you can configure sub-routes more intuitively. By setting the association between the parent page container and the child pages, you can achieve the loading and rendering of the child pages."},{"t":"h2","c":"Listening to Routes on the Parent Page"},{"t":"p","c":"In some cases, multiple pages share the same parent page as a container. When these pages navigate between each other, the parent page will not be refreshed. In this case, the parent page can still listen for changes in the route and perform corresponding operations without refreshing the page."},{"t":"h3","c":"Listen to routing changes"},{"t":"p","c":"The parent page module can set a routerChange function to monitor the change of the route. When the page changes the route without refreshing the parent page, the routerChange event will be triggered. This event will pass the information of the current page and the navigation mode (type)."},{"t":"p","c":"Below is an example of a parent page module, demonstrating how to set up the routerChange function to listen for route changes:"},0,{"t":"p","c":"In the above example, the routerChange function receives two parameters. current represents the address of the current page, and type represents the type of navigation. When the page undergoes a router change, this function will be triggered and output the corresponding information."}],"o-router":[{"t":"h1","c":"Usage of o-router component"},{"t":"p","c":"The o-router component is a component used to bind the routes within o-app to the current browser tab. It can help you manage page routes and display more conveniently."},{"t":"h2","c":"Quoting the o-router component"},{"t":"p","c":"First, you need to import the o-router component in your page. You can import the router.mjs file using the following method: "},0,{"t":"h2","c":"Using the o-router component"},{"t":"p","c":"Using the o-router component is achieved by wrapping it outside the o-app component. This allows binding the application's routes to the current browser tab."},0,{"t":"h2","c":"fix-body attribute"},{"t":"p","c":"The o-router component also provides a fix-body property. When you set this property, the component will automatically add styles to the <html> tag so that the size of the application matches the size of the page, making the content of the application fill the entire window."},0],"scsr":[{"t":"h1","c":"Static Client Side Rendering (SCSR)"},{"t":"h2","c":"What is SCSR?"},{"t":"p","c":"SCSR, short for Static Client-Side Rendering, is also known as static client-side rendering. SCSR is a variant of CSR (Client-Side Rendering) that allows web pages to be crawled by search engines while maintaining the user experience of CSR in a static state."},{"t":"h2","c":"How to Use SCSR"},{"t":"p","c":"You can reference the SCSR library using the following methods: "},0,{"t":"h2","c":"The Working Principle of SCSR"},{"t":"p","c":"SCSR is a page module that runs in single-file mode without using the o-page tag, allowing rendering on the page. Specifically, the template code of the page module is directly placed within the o-app."},{"t":"p","c":"Below is an example of SCSR, which shows how to render the content of a page module directly on the page:"},0,{"t":"p","c":"Through SCSR, the content inside the template tag will be directly rendered on the page, and this part of the content is actually the page module in single-file mode."},{"t":"p","c":"Continuing with the example of the home.html page, let's create a help page:"},0,{"t":"p","c":"After clicking \"GO TO HELP\" on the home.html page, the smooth transition to the help.html page is achieved, realizing the smooth transition effect of client-side rendering."},{"t":"h2","c":"Caveat"},{"t":"p","c":"All pages using the SCSR scheme must keep the referenced resources consistent, except for descriptive contents such as title, meta:description, keywords, and page template content, to ensure consistent experience after page navigation and refresh."},{"t":"h2","c":"About SSR Solution"},{"t":"p","c":"The current SCSR solution is actually more similar to a SSG (Static Site Generation) solution because it pre-renders the pages into static content and then interacts with them through the client. ofa.js has provided a relatively independent component encapsulation solution, allowing frontend developers to encapsulate components and combine them with traditional backend rendering solutions (such as website rendering frameworks in languages like Node.js, Go, Java, PHP, etc.), enabling backend developers to quickly use these encapsulated components to build high-quality web pages."},{"t":"p","c":"We plan to provide a complete Server-Side Rendering (SSR) solution in the future. The principle of this solution is to first obtain the element content of the next page, and then compare it with the current page's tag content in order to dynamically add, delete, and modify property values. However, it is important to note that this SSR solution can be time-consuming because it involves complex element comparison and modification operations."},{"t":"p","c":"ofa.js is an emerging framework, and the author's limited spare time means that the SSR solution has not been fully developed yet. However, if ofa.js gains more users in the future and there is a strong demand for an SSR solution, the author will continue to improve and develop this solution. Currently, the author is focusing on the stability and feature expansion of the framework, and welcomes user feedback and suggestions to better meet user needs in the future."}]},"others":{"data-sharing":[{"t":"h1","c":"Data Sharing"},{"t":"p","c":"ofa.js is different from other third-party frameworks by not adopting a traditional state management pattern. The author believes that state updates should be seamless, meaning that changing the data should automatically trigger data updates."},{"t":"p","c":"ofa.js has excellent data sharing capabilities. Its instances are developed based on the data sharing library Stanz. The objects on the instances are all synchronous. If you want to achieve data sharing, you just need to create a separate Stanz object and let all components refer to it directly."},{"t":"p","c":"The following example demonstrates how to share data:"},0,0,0,0,{"t":"p","c":"In the above example, two components write data to themselves during the attached lifecycle. Then, the obj in the component becomes the shared data. After the detached lifecycle, the previously shared data is set to null to ensure data recycling."},{"t":"h2","c":"Caveat"},{"t":"p","c":"Due to data sharing, it is necessary to ensure that data is recycled at the appropriate time to avoid memory leaks."},0],"about-micro-frontend":[{"t":"h1","c":"About Micro Frontends"},{"t":"p","c":"Micro frontend is a frontend architectural pattern aimed at helping teams build and maintain large, complex frontend applications more effectively. It draws inspiration from the microservices architecture by breaking down the frontend application into smaller, independent parts that can be developed, tested, and deployed by different teams."},{"t":"p","c":"During the process of continuously expanding traditional monolithic front-end applications, they may become difficult to maintain and scale. The goal of micro frontends is to split the application into smaller and more manageable modules, enabling development teams to independently develop and deploy these modules, thereby improving team efficiency and application maintainability."},{"t":"p","c":"ofa.js has inherent micro front-end features. The key difference between it and other frameworks is that components, pages, and applications developed with ofa.js do not require pre-compilation. In comparison to frameworks like React, Vue, and Angular, which require a build step in a Node.js environment to generate client-side code, ofa.js allows development code to be directly hosted on a static server without additional build steps. This enables real-time viewing, usage, and execution."},{"t":"p","c":"ofa.js conforms to the characteristics of micro frontends:"},{"t":"l","c":"1. Independent Deployment: Each component and page can be developed, tested, and deployed independently, enabling teams to release new features and resolve issues more quickly.\n\n2. Integration: Applications developed based on ofa.js can combine different modules together. This can be achieved through sharing compositions via applications, pages, components, etc.\n\n3. Independent Teams: Each frontend module (component/page/application) can be developed and maintained by an independent team, encouraging autonomy and innovation within teams.\n\n4. Shared Resources: In the ofa.js project, there are usually shared resources such as styles, components, and pages to ensure consistency and efficiency.\n\n5. On-demand Loading: Applications in ofa.js can load modules as needed, enhancing application performance and loading speed."},{"t":"p","c":"Although ofa.js cannot directly develop components using frameworks such as Vue and React, components developed based on ofa.js can be used by Vue and React. This provides developers with different technology stacks with greater flexibility and extensibility."},{"t":"p","c":"Using Web Components in Vue:"},{"t":"l","c":"- Vue Web Component Wrapper\n- Integrating Vue with Web Components\n- How to Use Web Components in Vue"},{"t":"p","c":"Using Web Components in React:"},{"t":"l","c":"- Using Web Components with React\n- Using Web Components in React\n- Integrating Web Components into React"}]}},"api":{"index":[{"t":"h1","c":"API Introduction"},{"t":"p","c":"Below is an overview of the ofa.js API. You can have a quick look now and refer to the detailed documentation when needed:"},{"t":"h2","c":"Related to examples"},{"t":"l","c":"- $: Used primarily to obtain instance methods.\n- all: Get all relevant instances.\n- prev: Get the previous instance of the target element.\n- prevs: Get all instances before the target element.\n- next: Get the next instance of the target element.\n- nexts: Get all instances after the target element.\n- siblings: Get all adjacent element instances of the target element.\n- parent: Get the parent element instance.\n- parents: Get a collection of all parent element instances.\n- clone: Method to clone an instance.\n- ele: Get the actual native element of an instance.\n- shadow: Get the shadow root node of a custom component.\n- root: Get the root node of the target instance.\n- Children: Get child elements directly by their index.\n- host: Get the app element instance of the target."},{"t":"h2","c":"Node Operations"},{"t":"l","c":"- Add or remove child nodes\n- before: Add elements before the target instance\n- after: Add elements after the target instance\n- remove: Remove the target element\n- wrap: Wrap the target element with another element\n- unwrap: Remove the wrapping element from the target element"},{"t":"h2","c":"property Operations"},{"t":"l","c":"- text: Get or set the text content of the target element\n- html: Get or set the HTML content of the target element\n- attr: Get or set the attributes of the target element, attributes\n- css: Get or set the style of the target element\n- style: Get the native style of the target element\n- classList: Get the native class list of the target element\n- data: Get the native dataset of the target element"},{"t":"h2","c":"Event-related"},{"t":"l","c":"- on: Bind an event to the target element\n- one: Bind an event to the target element only once\n- emit: Trigger an event manually\n- off: Unbind the bound event"},{"t":"h2","c":"Template Syntax"},{"t":"l","c":"- Text Rendering: Quickly render text on template files\n- Class: Quickly render class names on template files\n- Sync: Quickly sync data to template files\n- Conditional Rendering: Render content on template files based on conditions\n- List Rendering: Quickly render array data on template files"},{"t":"h2","c":"Lifecycle"},{"t":"l","c":"- created: Triggered when the component is created but before the content is rendered.\n- ready: Triggered when the component is created and the content has been rendered.\n- watch: Triggered after the component is initialized and when the value is changed.\n- loaded: Triggered after the embedded resources of the component have finished loading.\n- attached: Triggered after the component is added to the document.\n- detached: Triggered after the component is removed from the document.\n- routerChange: Triggered when the nested parent page experiences a change in the application route."},{"t":"h2","c":"Others"},{"t":"l","c":"- Box Model: Retrieves all size-related data of the target element.\n- formData: Conveniently binds and retrieves form data.\n- tag: Retrieves the tag name of the target.\n- index: Retrieves the position of the target element within its parent element.\n- is: Checks whether the target element matches a CSS selector expression.\n- refresh: Actively refreshes the component's interface.\n- PATH: Retrieves the registration file address of a component or page.\n- extend: Extends the data or methods of an instance; extends the data or methods of the underlying ofa.js.\n- Instance Data Features: Introduces the characteristics of sub-object data in instance data and how to listen for changes in data."}],"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"The $ method is a core function in ofa.js that is used to manipulate instances of DOM elements. Below will introduce the main functions of $:"},{"t":"h2","c":"Get element instance"},{"t":"p","c":"Through the $ method, you can get the first element instance on the page that matches the CSS selector and manipulate it. Here is an example:"},0,0,0,0,{"t":"p","c":"In the example above, we use the $ symbol to select the element instance with the id of \"target1\", and modify its text content by setting the text property."},{"t":"h2","c":"Searching for Child Elements Example"},{"t":"p","c":"Instances also have the $ method, which allows you to retrieve the first child element instance that matches a certain condition by calling the $ method on the instance."},0,0,0,0,{"t":"h2","c":"Element Instance Characteristics"},{"t":"p","c":"Please do not directly insert the acquired element instance into other places, as this operation will affect the original element. If you need to create a copy, you can use the clone method."},0,0,0,0,{"t":"h2","c":"Get child elements within a shadow node"},{"t":"p","c":"You can obtain the instance through the shadow property and then use the $ method to obtain the desired element."},0,{"t":"h2","c":"Instantiate elements directly"},{"t":"p","c":"You can directly initialize native elements as $ instance objects using the following methods:"},0,0,{"t":"p","c":"This way, you can easily convert existing HTML elements into $ instances for manipulation and processing using the functionality provided by $."},{"t":"h2","c":"Generating Element Instances"},{"t":"p","c":"In addition to accessing existing element instances, $ can also be used to create new element instances and add them to the page."},{"t":"h3","c":"Generate a string"},{"t":"p","c":"You can use the $ function to create new element instances from strings, as shown below:"},0,0,0,0,{"t":"p","c":"In this example, we use the $ function to create a new element instance with specified styles and text content, and add it to the existing element instance with id \"target1\"."},{"t":"h3","c":"Generate through Objects"},{"t":"p","c":"You can also use the $ function to generate new element instances through object-oriented approach, as shown below:"},0,0,0,0,{"t":"p","c":"In this example, we use the $ function to define a new element instance using an object format, including the tag type, text content, and style attributes, and add it to an existing element instance with the id \"target1\"."}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"Using the all method, you can get all elements on the page that match the CSS selector, and return an array containing these elements."},0,0,0,0,{"t":"h2","c":"Getting Child Elements"},{"t":"p","c":"Instances also have an all method, which can be used to select and retrieve child elements on the instance."},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"Using the prev property, you can get the previous adjacent element instance of an element."},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"By using the prevs property, you can easily access all the previous adjacent element instances of the current element, which will be returned in the form of an array."},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"By using the next property, you can obtain the next adjacent element instance of an element."},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"Using the siblings property, you can easily retrieve all the adjacent element instances of the current element, which will be returned as an array."},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"Using the nexts property, you can easily get all the adjacent element instances that come after the current element, and these elements will be returned as an array."},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"Using the parent property, you can obtain the parent element instance of an instance."},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"Using the parents property, you can easily get all parent element instances of the current element, which will be returned as an array."},0,0,0,0],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"Using the clone method, you can clone and generate a copy of an element instance;"},0,0,0,0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"Through the ele property, you can access the actual element of the instance and use native properties or methods."},0,0,0,0,{"t":"p","c":"In the example above, we used the ele property to access an element and modified its inner HTML content, as well as the tagName of the element for recording purposes. This allows you to perform more complex operations on elements using native JavaScript methods."}],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"Using the shadow property, you can obtain the shadow root instance of an element."},0,0,0,{"t":"p","c":"It is important to avoid directly modifying elements inside shadow nodes that have template syntax, in order to ensure consistency and maintainability of the operation."},{"t":"h2","c":"Get instances of elements inside the shadow DOM of a component from the outside"},{"t":"p","c":"You can also obtain custom element instances from the external and access elements within the shadow tree through the shadow property as shown below:"},0],"root":[{"t":"h1","c":"root"},{"t":"p","c":"Using the root property to access the root node of an element."},{"t":"p","c":"On a webpage, the root node of ordinary elements is an instance of document."},0,0,0,0,{"t":"h2","c":"Elements Inside Shadow DOM"},{"t":"p","c":"Because the elements inside a component are isolated from the external environment, the root property of the elements inside the shadow node is the shadow root node."},0,0,0],"children":[{"t":"h1","c":"Subelements"},{"t":"p","c":"Accessing child element instances is very simple. You just need to treat the instance as an array and access its child element instance by using indexes."},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"Get the number of child elements of the target element; an example is shown above;"},0],"host":[{"t":"h1","c":"host"},{"t":"p","c":"Using the host property, you can obtain the instance of the host component for an element. This is very useful for accessing the data and methods of the host component from within the component."},{"t":"p","c":"Here is an example demonstrating how to use the host property to obtain an instance of the host component:"},0,0,0,{"t":"p","c":"In this example, we created a custom component host-demo and accessed its host component instance inside the component, and then compared if they are equal."},{"t":"p","c":"If the element is not inside a component, the value of host will be null. For example:"},0,0,0,0,{"t":"p","c":"In this example, the #target element is under the body, not inside any component or page, so the value of $(\"#target\").host is null."}],"app":[{"t":"h1","c":"app"},{"t":"p","c":"In the elements within o-app, including the elements within the shadow tree of o-page inside o-app, or the internal child components, their app property points to the element instance of this o-app."},{"t":"p","c":"The following is an example demonstrating how to access the app property within an element in o-app:"},0,{"t":"p","c":"The code is as follows: ."},0,0,0,{"t":"p","c":"In the above example, the app property of the o-app element contains the elements within the o-page element and the test-comp custom component. This means that they can both access the data and methods of the o-app element through the app property."}]},"operation":{"array-like":[{"t":"h1","c":"Adding or Removing Child Elements"},{"t":"p","c":"Element instances have array-like properties, adding or deleting nodes can be done using only the array methods; when using the push, unshift, pop, shift, and splice methods, the $ method initialization will be performed internally, so you can fill in the specific element strings or objects directly."},{"t":"p","c":"Similarly, you can also use other array methods such as forEach, map, some, and so on."},{"t":"p","c":"Please note, do not add or remove child elements on elements with template syntax."},{"t":"h2","c":"push"},{"t":"p","c":"Adding child elements from the end."},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"Add a subelement to the beginning of the array. Here is an example:"},0,0,0,0,{"t":"h2","c":"Pop"},{"t":"p","c":"Remove child elements from the end."},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"Remove sub-elements at the beginning of an array."},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"You can delete or replace existing child elements, and you can also add new child elements. Its usage is similar to the splice method of an array. Here is an example:"},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"The before method is used to add elements before the target element. Prior to executing the before operation, the initialization operation of the $ method is automatically performed, so you can directly fill in specific element strings or objects."},{"t":"p","c":"Please note, do not manipulate elements with template syntax."},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"The \"after\" method is used to add elements after the target element. Before executing the \"after\" operation, the initialization operation of the $ method will be automatically performed, so you can directly fill in the specific element string or object."},{"t":"p","c":"Please note, do not manipulate elements with template syntax."},0,0,0,0],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"Delete target node"},{"t":"p","c":"Please note, do not manipulate elements with template syntax."},0,0,0,0],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"The unwrap method is used to remove one layer of external wrapping elements from the target element."},{"t":"p","c":"Below is an example: "},0,0,0,0,{"t":"h2","c":"Caveat"},{"t":"p","c":"The target element must have a parent node, otherwise the wrapping operation will fail."},0,{"t":"p","c":"When there are other sibling elements, unwrap cannot be executed."},0,{"t":"p","c":"Please note, do not manipulate elements with template syntax."}],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"wrap method is used to wrap an element with another element. Before executing the wrap operation, it automatically performs the initialization operation of the $ method, so you can directly fill in the specific element string or object."},{"t":"p","c":"Below is an example: "},0,0,0,0,{"t":"h2","c":"Caveat"},{"t":"p","c":"The target element must have a parent node, otherwise the wrapping operation will fail."},0,{"t":"p","c":"Please note, do not manipulate elements with template syntax."}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"The text method is used to get or set the text content of an element."},{"t":"h2","c":"Direct Use"},{"t":"p","c":"You can directly get or set the text content of an element. Here is an example:"},0,0,0,0,{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use the :text property in the template to set the corresponding property value for the target element. This is particularly useful in component rendering. Here is an example:"},0,0,0],"html":[{"t":"h1","c":"html"},{"t":"p","c":"Setting the html code within the target."},0,0,0,0,{"t":"h2","c":"Caveat"},{"t":"p","c":"html is a rather dangerous method. When it is injected with script, the internal javascript code will automatically execute. When using it, pay attention to preventing XSS."},{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use the :html property in the template to set corresponding property values for the target element. This is particularly useful in component rendering. Here is an example: "},0,0,0],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"The attr method is used to get or set the attributes of an element."},{"t":"h2","c":"Direct Use"},{"t":"p","c":"You can directly use the attr method to get or set the attributes of an element. Here is an example:"},0,0,0,0,{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use the attr:aaa=\"bbb\" syntax in the template to set the property aaa of the target element to the value of component bbb. This method is particularly useful for component rendering. Here is an example:"},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"The CSS method is used to get or set the style of the target element."},{"t":"h2","c":"Direct Use"},{"t":"p","c":"You can directly use the css method to get or set the style of an element. Here is an example:"},0,0,0,0,{"t":"h2","c":"Full settings"},{"t":"p","c":"Through the obtained css object, you can get the style value directly set on the element. Here is an example: "},0,0,0,0,{"t":"p","c":"Using the features of the css object, you can quickly adjust the style of the target element."},{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use template syntax to set the style of the target element. Here is an example: "},0,0,0,{"t":"h2","c":"Tips for Setting CSS"},{"t":"p","c":"You can modify a specific style property of an element by using $ele.css = {...$ele.css, color:'red'}, without affecting other style properties. This method allows you to modify only one property without rewriting the entire style."},{"t":"h3","c":"Example"},0,{"t":"p","c":"In the example above, by using { ...myElement.css, color: 'red' }, we only modified the color style of the element, while keeping other style properties unchanged. This is a convenient trick that allows flexible modifications of the element's style."}],"style":[{"t":"h1","c":"style"},{"t":"p","c":"Use the style property to remain consistent with native."},{"t":"p","c":"Please note that the style property cannot retrieve the actual value of a style but only the value set on the style property. Although the style method is similar to the css method, it cannot override all styles. Compared to css, the style method has a higher internal execution efficiency."},{"t":"p","c":"Here is an example that demonstrates how to use style: "},0,0,0,0,{"t":"p","c":"Please note that the style method only gets and sets values on the style property, not the actual computed style."}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"classList property remains consistent with the native."},{"t":"p","c":"Below is an example demonstrating how to use classList:"},0,0,0,0,{"t":"p","c":"The classList property allows you to easily add, remove, and toggle class names to dynamically change an element's style. For more information on how to use it, please refer to classList."}],"data":[{"t":"h1","c":"data"},{"t":"p","c":"Obtain the dataset of an element, use the data property to maintain consistency with the native dataset."},0,0,0,0]},"event":{"one":[{"t":"h1","c":"one"},{"t":"p","c":"Using the one method, you can register a one-time event handler for the target element, which means the event handler will automatically be unbound after the first trigger and will not be triggered again."},{"t":"p","c":"Here is an example demonstrating how to use the one method to register a click event handler for a button element:"},0,0,0,0,{"t":"p","c":"In this example, we use the one method to add a click event handler to a button element. When the user clicks the button, the event handler is triggered, but it will not be triggered again afterwards because it has been unbound."},{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use template syntax to bind one-time event handlers for target elements. Here is an example: "},0,0,0,{"t":"p","c":"In this example, we use one:click to bind a method called addCount to the button element. When the user clicks the button, this method will be called, but it will not be triggered again afterwards because it is a one-time event handler."}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"Using the emit method, you can actively trigger events, and the triggered events have a bubbling mechanism. The bubbling mechanism means that the event bubbles from the inner element to the outer element, triggering events from the innermost to the outermost hierarchy."},{"t":"p","c":"The following is an example demonstrating how to use the emit method to trigger custom events and utilize the bubbling mechanism to pass events to external elements:"},0,0,0,0,{"t":"p","c":"In this example, we registered the same custom event handler \"custom-event\" for both the <ul> element and the <li> element. When we use the emit method to trigger the event, the event bubbles from the <li> element to the <ul> element, triggering both event handlers."},{"t":"h2","c":"Custom Data"},{"t":"p","c":"Through the use of the data parameter, you can pass custom data to event handlers."},0,0,0,0,{"t":"p","c":"In this example, we pass custom data to the event handler through the data parameter. The event handler can access the passed data through event.data."},{"t":"h2","c":"No bubble-triggered events"},{"t":"p","c":"If you do not want the event to bubble, you can include the bubbles: false parameter when triggering the event:"},0,0,0,0,{"t":"p","c":"In this example, we use the bubbles: false parameter to trigger a custom event. This event does not bubble up to the parent elements, so only the event handler of the <li> element is triggered."},{"t":"h2","c":"Penetrate the root node"},{"t":"p","c":"By default, events do not penetrate the shadow DOM of custom components. However, you can enable event penetration through the root node and trigger elements outside the root node by setting composed: true."},0,0,0,0,0,{"t":"p","c":"In this example, we create a custom component composed-test that includes an element in the shadow DOM and a button that triggers an event. By default, the event does not penetrate the shadow DOM to the root node. However, by using the composed: true parameter when triggering the event, we allow the event to penetrate to the root node, triggering elements outside of the root node."}],"off":[{"t":"h1","c":"off"},{"t":"p","c":"By using the off method, you can unregister the registered event handler to stop listening for the event."},{"t":"p","c":"Here is an example demonstrating how to use the off method to remove event listeners:"},0,0,0,0,{"t":"p","c":"In this example, we registered a click event handler f. When the button is clicked, the event handler will display the click count in #logger. Using the off method, we cancelled the event listener when the click count reaches 3."}],"on":[{"t":"h1","c":"on"},{"t":"p","c":"Using the on method, you can register event handlers for target elements. This allows you to easily capture and respond to user interaction."},{"t":"p","c":"Here is an example demonstrating how to use the on method to register a click event handler for a button element:"},0,0,0,0,{"t":"p","c":"In this example, we use the on method to add a click event handler for the button element. When the user clicks the button, the event handler is triggered, the counter will increment, and the result will be displayed on the page."},{"t":"h2","c":"Template Syntax Usage"},{"t":"p","c":"You can also use template syntax to bind methods to target elements. Here is an example:"},0,0,0,{"t":"p","c":"In this example, we use the on:click binding on a button element to bind a method called addCount. When the user clicks the button, this method will be called, the counter value will increase and be displayed on the page. This allows you to associate event handlers with component methods, enabling more complex interactions."},{"t":"h2","c":"event"},{"t":"p","c":"After registration time, the triggered function will be passed with event, consistent with the native."},0,0,0,0]},"temp-syntax":{"text-render":[{"t":"h1","c":"Text rendering"},{"t":"p","c":"You can use double curly braces {{xxx}} within the template to render text, where xxx is the property of a component or page itself. This allows you to directly render the value of the property onto the page."},{"t":"p","c":"The following is an example that demonstrates how to render text in a template: ."},0,0,0,{"t":"p","c":"In this example, {{txt}} will be replaced by the value of the txt property and finally rendered on the page."}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"You can quickly switch the class name inside the template using the class syntax. In class:aaa=\"bbb\", the aaa className will be added to the target element when the bbb expression (or the bbb property of the component itself) is true."},{"t":"p","c":"Please note that the className cannot contain uppercase letters. Please use \"-\" as a separator."},{"t":"p","c":"The following is an example demonstrating how to use the class syntax to switch the class name of an element in a template:"},0,0,0,{"t":"h2","c":"Using classes directly"},{"t":"p","c":"You can use the class method to directly manipulate the className of an element. In the example below, it demonstrates how to dynamically add and remove class names using the class method:"},0,0,0,0,{"t":"p","c":"In this example, we first use the class method to add the color-red class to the element, then remove it after one second, and add the color-blue class to the element after half a second. This will dynamically change the style of the target element."},{"t":"p","c":"We recommend using the classList property to manipulate class names, as it is a more common and standard method."}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"Bidirectional data binding of components via sync syntax"},0,0,0,{"t":"p","c":"sync can also be bound to the instance properties of embedded components. For examples, please refer to the two-way data binding case."}],"condition":[{"t":"h1","c":"Conditional Rendering"},{"t":"p","c":"Conditional rendering is achieved through three conditional components:"},{"t":"h2","c":"x-if"},{"t":"p","c":"x-if is the main conditional component that requires the value to be set. If the conditions for value are met, it will display the wrapped content."},{"t":"h2","c":"x-if-else"},{"t":"p","c":"x-if-else can be used after x-if or x-if-else, and it needs a value to be set. If the preceding conditional components are not met and its own value is true, it will display the wrapped content."},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else can be used after x-if or x-if-else, and it should be placed at the end. If none of the previous conditions are met, it will display the content wrapped by itself. No value value needs to be set."},{"t":"h2","c":"Example"},0,0,0,{"t":"p","c":"In the example, these conditional rendering components are used to select the content to be displayed based on the value of count. When count is divisible by 3, the x-if condition is satisfied and displays red text; when (count + 1) is divisible by 3, the x-if-else condition is satisfied and displays green text; otherwise, blue text is displayed."}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"Use the x-fill component for list rendering; set the value property to populate the array data."},{"t":"p","c":"In x-fill, you can use special variables $index to represent the index of the current list item, and $data to represent the data of the list item itself."},{"t":"p","c":"Here is an example that demonstrates how to use x-fill to render an array:"},0,0,0,{"t":"p","c":"In this example, we use the x-fill component to render the array arr and display the index and data in each list item."},{"t":"h2","c":"Template List Rendering"},{"t":"p","c":"You can use the template element and add the name property to customize temporary templates within a component. When using x-fill, use the name property to specify the template name to be filled."},{"t":"p","c":"Here is an example demonstrating how to use template list rendering:"},0,0,0,{"t":"p","c":"In this example, we created a template called \"easyLi\", and then used x-fill to populate the data of the array arr, displaying the index and name of the data in each list item."},{"t":"h2","c":"Nested List Rendering"},{"t":"p","c":"When rendering nested lists, starting from the second level, templates must be used to fill in the content. This design is to avoid the nested list rendering code becoming complex."},{"t":"p","c":"Here is an example demonstrating how to perform nested list rendering:"},0,0,0,{"t":"p","c":"In this example, we have an array arr that contains two objects. Each object has a name property and a childs property that may contain nested sub-items. We use x-fill to populate the list and render the sub-items using the template \"easyLi\". If an item has sub-items, we use x-if to check and create a nested list."},{"t":"h2","c":"Recursive List Rendering"},{"t":"p","c":"Template rendering can also be done recursively, which is very useful for building tree-like structured lists."},{"t":"p","c":"The following is an example of how to perform recursive list rendering:"},0,0,0,{"t":"p","c":"In this example, we have an array arr that contains two objects. Each object has a name property and a childs property that may contain nested sub-items. We use x-fill to populate the list and use the template \"easyLi\" to render the sub-items. If an item has sub-items, we use x-fill to recursively render the child list, achieving recursive list rendering."},{"t":"h2","c":"replace-temp"},{"t":"p","c":"Sometimes, when we try to render a list into a select or table, the browser may automatically remove the <x-fill> element, which prevents the list from being rendered correctly. In this case, you can use the \"replace-temp\" method for rendering. The way to use \"replace-temp\" is to set is=\"replace-temp\" in a <template> tag and place this template inside an element that the browser will automatically fix."},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created lifecycle hook is triggered when a component is created. At this stage, the component's data has not been initialized and the template content has not been rendered. You can perform some initialization operations at this stage or prepare data to be used in later stages."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"ready lifecycle hook is triggered after the component's data and template are initialized, indicating that the component is ready. At this stage, you can access the component's data, and the template has been rendered, allowing you to perform some interactive operations related to the interface."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"Once the ready stage is completed, the listening function in the associated watch object will be triggered once. Afterwards, when a value of the data changes, the corresponding key's listening function will be triggered again."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"The loaded lifecycle hook is triggered after all dependencies in the component template have been loaded. This stage ensures that all dependencies are loaded before rendering the component. This is a good time to remove the Loading style added during the ready stage."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"attached lifecycle hook is triggered when the component is added to the document. At this stage, it is suitable for obtaining size-related information of the elements within the component, performing data binding, and global event operations."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"detached lifecycle hook is triggered when a component is removed from the document. During this stage, you can perform some cleanup operations, such as unregistering event listeners or releasing resources, to prevent memory leaks."},{"t":"h2","c":"Example code"},0,0,0,0,0,{"t":"h2","c":"Lifecycle Flowchart"},0],"router-change":[{"t":"h1","c":"routerChange event"},{"t":"p","c":"routerChange event is an event specific to the o-page element, and it is only triggered on the nested parent page of o-page. This event is triggered when the application's router changes, whether it is navigating to a new page or returning to a previous page."},{"t":"p","c":"It provides a way to listen and respond to changes in the application's routing, typically used in the parent page of nested pages. When the route changes, you can listen for the routerChange event to perform corresponding actions, such as updating page content or navigation status."},{"t":"p","c":"This event is very useful for building applications with multiple nested pages, making navigation and communication between pages easier."},{"t":"h2","c":"Example"},{"t":"p","c":"Jump to nested page to view;"}]},"others":{"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app is one of the core components in ofa.js, used for configuring and managing the entire application. Here are some key properties and methods of app:"},{"t":"h2","c":"src"},{"t":"p","c":"The src property is used to specify the specific address of the application parameter configuration module. For detailed examples, please refer to the case."},0,{"t":"h2","c":"current"},{"t":"p","c":"The current property is used to obtain the currently displayed page instance. This can help you access and manipulate the currently displayed page, such as updating its content or performing specific operations."},0,{"t":"h2","c":"goto"},{"t":"p","c":"The goto method is used to navigate to a specific page. You can pass the address of the target page, and the application will load and display that page. This is an important method for application navigation."},0,{"t":"h2","c":"replace"},{"t":"p","c":"replace method is similar to goto, but it is used to replace the current page instead of adding a new page to the stack. This can be used to implement page replacement instead of stack navigation."},0,{"t":"h2","c":"back"},{"t":"p","c":"The back method is used to go back to the previous page, implementing the back navigation operation for page navigation. This will navigate the user back to the previous page."},0,{"t":"h2","c":"routers"},{"t":"p","c":"The routers property contains the routing configuration information for the application. This is an important property that defines the routing rules and mapping for the various pages in the application. The routing configuration determines the navigation between pages and how URL is handled."},0],"page":[{"t":"h1","c":"o-page component"},{"t":"p","c":"o-page is one of the core components in ofa.js, representing an independent page or page module. The following are some key properties and methods of o-page:"},{"t":"h2","c":"src attribute"},{"t":"p","c":"src property is used to specify the specific address of a page module. This is a crucial property that specifies the content and behavior of a page, telling the application where to load the content of a specific page from."},0,{"t":"h2","c":"goto method"},{"t":"p","c":"goto method is used to navigate from the current page to another page. Unlike the goto method of app, the goto method of page can navigate to other pages using relative addresses."},0,{"t":"h2","c":"replace method"},{"t":"p","c":"The replace method is used to replace the current page with another page. This is similar to the replace method of app, but it performs the replacement operation within the page."},0,{"t":"h2","c":"back method"},{"t":"p","c":"The back method is used to go back to the previous page. This navigates the user back to the previous page, similar to the browser's back operation."},0],"box":[{"t":"h1","c":"Box Model"},{"t":"p","c":"In web development, the size of an element is an important concept, which includes the content area, padding, border, and margin. The following are some related properties that represent the size of an element:"},{"t":"h2","c":"width"},{"t":"p","c":"width represents the width of the content area of an element, excluding the padding, border, and margin."},{"t":"h2","c":"height"},{"t":"p","c":"height represents the height of an element's content area, excluding padding, border, and margin."},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidth represents the width of the visible content area of an element, including padding but excluding borders and margins."},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeight represents the height of the visible content area of an element, including padding but excluding borders and margins."},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"offsetWidth represents the overall width of an element, including the content area, padding, border, and margin."},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"offsetHeight represents the overall height of an element, including the content area, padding, border, and margin."},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidth represents the overall width of an element, including the content area."},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"formData method is used to generate object data that is bound to form elements, making it easier and more efficient to handle form elements. This method will generate an object that contains the values of all form elements within the target element, and this object will reflect any changes made to the form elements in real-time."},{"t":"p","c":"In the following example, we demonstrate how to use the formData method to generate object data that is bound to form elements:"},0,0,0,0,{"t":"p","c":"In this example, we created a form that includes text input boxes, radio buttons, and a text area. We used the formData method to create an object called data, which contains the values of these form elements. We also used the watch method to monitor changes in the data and display the data on the page in real-time. When users modify the values of the form elements, the data object will be updated accordingly, making data processing simple and efficient."},{"t":"h2","c":"Reverse Data Binding"},{"t":"p","c":"The generated object data also has the ability to bind in reverse, which means that when you modify the properties of an object, the corresponding form element values will also be automatically updated. This is very useful when handling form data because you can easily achieve two-way data binding."},{"t":"p","c":"In the following example, we demonstrate how to use the object data generated by the formData method and how to perform reverse data binding:"},0,0,0,0,{"t":"p","c":"In this example, we first created a form that includes a text input box, radio buttons, and a text area. Then we used the formData method to generate a data object called data. Afterwards, by modifying the properties of the data object, we achieved two-way data binding, which means the values of the form elements will automatically update as the object properties change. This two-way data binding feature makes interacting with form data more convenient."},{"t":"h2","c":"Listen for a specific form"},{"t":"p","c":"By default, the formData() method will listen to all input, select, and textarea elements inside the target element. However, if you only want to listen to specific form elements, you can achieve it by passing a CSS selector."},{"t":"p","c":"In the example below, we demonstrate how to listen for specific form elements by passing a CSS selector:"},0,0,0,0,{"t":"p","c":"In this example, we only want to listen to form elements with the class of \"use-it\", so we pass \".use-it\" as an argument to the formData() method. This way, only form elements with that class name will be listened to and included in the generated data object. This is useful for selectively listening to form elements in order to manage your form data more precisely."},{"t":"h2","c":"Custom Form"},{"t":"p","c":"Using custom form components is very simple, just add a value property and set the name attribute for the custom component."},{"t":"p","c":"In the example below, we create a custom form component called \"custom-input\". This component is an editable text box that updates its value property in real-time when the text changes."},0,0,0,0,{"t":"p","c":"When you use a custom form component, you simply add it to your form and set the desired name property:"},0,{"t":"p","c":"In the above example, we use custom form components by adding the <custom-input> element and setting the name property. Then, we use the formData() method to listen to the values of input elements and custom components, in order to retrieve and process the form data in real-time. This approach allows you to easily extend your form to include custom form components, meeting your specific needs."},{"t":"h2","c":"Using Form Data in Components or Pages"},{"t":"p","c":"Sometimes, you may need to use form data within a component or page, and you need to generate the data during the ready lifecycle and bind it to the component."},{"t":"p","c":"In the following example, we demonstrate how to use form data within a custom component. This component includes a text input field that updates the data in the log in real-time when you input content."},0,0,0,{"t":"p","c":"Through the ready lifecycle, after the component is ready, we use the this.shadow.formData() method to generate the form data object fdata. Then, we use watch to listen for changes in fdata, and when the data changes, we convert it to a JSON string and update logtext to achieve real-time display of form data."}],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"The tag property is used to get the tag of an element, returning a lowercase string."},{"t":"p","c":"In the example below, we demonstrate how to use the tag method to retrieve the tag of an element:"},0,0,0,0],"index":[{"t":"h1","c":"index"},{"t":"p","c":"index property is used to obtain the position of an element relative to its parent element. This position is counted starting from 0, which means the position of the first element is 0, the second is 1, and so on."},{"t":"p","c":"In the example below, we demonstrate how to use the index property to obtain the position of an element within its parent element:"},0,0,0,0,{"t":"p","c":"In this example, we first select an <li> element with an id of \"target\". Then, we use the index property to get the position of this element under its parent <ul>, which is the second element, so the value of index is 1. Then, we display this value in a <div> element with an id of \"logger\"."}],"is":[{"t":"h1","c":"is"},{"t":"p","c":"Used to check whether elements conform to an expression;"},0,0,0,0],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"To refresh the rendering view of a component, sometimes you can use this method when the data on the component is not updated."},0,0,0],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"The PATH property is usually used for custom components or page components to obtain the file address of the registered component. This can help you understand the source of the component during development, especially when you need to reference or load other resource files. You can use the PATH property to construct the file path."},{"t":"p","c":"Here is a simple example that demonstrates how to use the PATH property in a custom component:"},0,{"t":"p","c":"In this example, we selected a my-comp element with an id of \"myCustomComponent\" and then obtained the file path of the custom component by using the PATH property. You can use the componentPath variable in the script section as needed, such as using it to construct paths for other resource files or perform other operations."}],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extend is a higher-order function used to extend properties or methods of an instance;"},0,0,0,0,{"t":"h2","c":"Extending $ Underlying"},{"t":"p","c":"Like jQuery, you can also extend the properties or methods of the underlying instance through fn.extend; properties or methods extended from fn will be applied to all instances;"},0,0,0,0],"stanz":[{"t":"h1","c":"Instance Data Features"},{"t":"p","c":"The instance objects obtained or created through $ have complete stanz data features because the $ instance inherits from stanz. This means that you can use the data manipulation methods and features provided by stanz to manipulate and listen to the data of the instance objects."},0,{"t":"h2","c":"watch"},{"t":"p","c":"Instances can be monitored for value changes using the watch method. Even if the values of the object's child objects are modified, the changes can still be detected through the object's watch method."},{"t":"p","c":"Here is an example demonstrating how to use the $ instance and watch method:"},0,0,0,0,{"t":"p","c":"In this example, we first create a $ instance object called target, and then use the watch method to listen for changes in it. Even if we modify the value of a sub-object of the object, such as target.bbb.child.val, these changes can be detected and the content of the logger element will be updated in the watch method. This demonstrates the powerful features of the $ instance object, allowing you to easily monitor changes in objects."},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick is similar to the watch method, but it includes throttling internally. It executes only once on a single thread, so it can be more effective in listening for data changes in scenarios with higher performance requirements."},{"t":"p","c":"Here is an example demonstrating how to use the watchTick method of the $ instance:"},0,0,0,0,{"t":"p","c":"In this example, we first create a $ instance object called target. Then, we use the watch method and the watchTick method to listen for changes in the object. The watch method runs immediately when the data changes, while the watchTick method only executes once in a single thread, limiting the frequency of listening operations. You can choose to use either the watch or watchTick method depending on your needs to monitor data changes."},{"t":"h2","c":"unwatch"},{"t":"p","c":"The unwatch function is used to cancel the monitoring of data, and can revoke the previously registered watch or watchTick monitoring."},{"t":"p","c":"Below is an example demonstrating how to use the unwatch method of the $ instance:"},0,0,0,0,{"t":"p","c":"In this example, we first create a $ instance object called target, and then register two listeners using the watch method and watchTick method respectively. Afterwards, we use the unwatch method to revoke these two listeners by passing in the saved return values tid1 and tid2. This means that the property changes in the first setTimeout will not trigger any listeners because they have been revoked."},{"t":"h2","c":"Values that cannot be monitored"},{"t":"p","c":"In the $ instance, using property names starting with the underscore _ means that these values will not be watched by the watch or watchTick methods. This is useful for some temporary or private properties, as you can freely change them without triggering the listeners."},{"t":"p","c":"Here is an example demonstrating how to use underscore-prefixed property values to avoid being monitored:"},0,0,0,0,{"t":"p","c":"In this example, we create a $ instance object called target, and then use the watch method to listen for changes in the property values. In the setTimeout, we attempt to change the _aaa property value, but this change will not trigger the listener. This is very useful for situations where you need to update property values without triggering the listener."},{"t":"h2","c":"Basic Features"},{"t":"p","c":"The object data set on the instance will be converted to a Stanz instance, which allows for monitoring."},0,{"t":"p","c":"We can also use $.stanz to create a Stanz data without being bound to an instance."},0,{"t":"p","c":"These examples demonstrate the basic features of setting object data as a Stanz instance for monitoring."},{"t":"p","c":"For more complete features, please refer to stanz;"}]}}}