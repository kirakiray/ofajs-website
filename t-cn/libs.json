{"cases":{"index":[0,{"t":"h1","c":"快速開始"},{"t":"p","c":"要開始使用，只需通過引入 CDN 地址將項目 ofajs 集成到你的項目中："},0,{"t":"p","c":"這是一個簡單的示例，演示了如何使用 ofa.js 修改 DOM 元素的內容："},{"t":"h2","c":"使用方法"},{"t":"p","c":"引入了 ofa.js 後，全局作用域中將注冊 $ 符號。通過 $('xxx') 來選擇符合條件的第一個元素，其中 xxx 是標準的 CSS 選擇器 內容。"},{"t":"p","c":"在上述示例中，我們使用了 $ 符號來選擇三個具有不同 id 的元素，並通過設置 text 、 html 和 value 屬性來修改其內容。"},{"t":"p","c":"要了解更多可用的屬性和方法，請查閱 API 文檔。"}],"event":[0,{"t":"h1","c":"事件響應"},{"t":"p","c":"您可以使用 on 方法來綁定事件。事件 是開發中最基礎的概念，應用通過事件的觸發才能產生反饋，從而實現互動性。"},{"t":"p","c":"以下示例演示了如何綁定點擊事件："},{"t":"p","c":"在這個示例中，我們通過使用 $ 選擇了 button 元素，並使用 on 方法綁定了 click 事件。當按鈕被點擊時，會觸發回調函數，將 target 元素的文本內容更改為 \"你好，世界！\"。"},{"t":"p","c":"如果您想了解更多可用的事件類型，請參考 Events 文檔。"}],"simple-component":[0,{"t":"h1","c":"組件的創建和使用"},{"t":"p","c":"一旦完成對 ofa.js 的加載，全局會注冊一個名為 load-module 的組件，你可以使用縮寫 l-m 來引用它。其使用方式類似於 script 標簽，通過 src 屬性來引用你開發好的組件地址。"},{"t":"p","c":"現在，讓我們開始制作自己的組件。首先，創建一個 HTML 文件，文件名需要與組件名保持一致。"},{"t":"p","c":"在組件文件中，首先添加一個 template 元素，並添加 component屬性。將組件需要渲染的內容放置在這個 template 元素內。最終，這些內容將被渲染到組件的 Shadow DOM 內，Shadow DOM 與外部環境隔離，以防止汙染外部環境。"},{"t":"p","c":"接下來，只需使用 l-m 組件來引用你開發好的組件。在頁面上，直接使用你定義的組件標簽即可。"},{"t":"p","c":"需要注意的是，注冊的組件名只能使用小寫英文字母和 - 符號，並且必須包含至少一個 -。這個命名規則需要遵循。"},{"t":"p","c":"通過本示例，你可以了解如何創建一個名為 my-comp 的組件，並在另一個頁面中使用它。同時可以通過鏈接外部的 CSS 文件來設置組件的樣式。"}],"slot":[0,{"t":"h1","c":"組件插槽"},{"t":"p","c":"通過在模板中添加 <slot></slot> 標簽，可以在使用組件時，將內容放置在對應組件標簽內的插槽中。"},{"t":"p","c":"自定義的組件在默認情況下沒有定義 display 屬性，因此需要手動為組件定義。在組件的樣式中，可以使用 :host 選擇器來添加組件自身的樣式。"},{"t":"p","c":"這個示例展示了如何創建一個名為 simple-btn 的組件。組件的模板中包含一個插槽，可以將內容插入到組件中。通過為組件的樣式添加 :host 選擇器，為組件添加樣式。在另一個頁面中，使用 l-m 組件引用 simple-btn 組件，並在其中插入內容。"}],"render-text":[0,{"t":"h1","c":"文本渲染"},{"t":"p","c":"在組件文件中，你可以添加一個 script 標簽來編寫組件的邏輯代碼。通過暴露的 default 對象，可以設置組件參數。"},{"t":"p","c":"其中，data 參數用於定義組件元素的默認數據。一旦實例化完成，你就可以使用模板語法。"},{"t":"p","c":"文本渲染采用雙大括號進行包裹，即 {{xxx}}，其中的 xxx 表示組件的屬性名；"},{"t":"p","c":"案例演示了如何渲染組件元素的 val 屬性："}],"attribute-transmission":[0,{"t":"h1","c":"特性傳遞"},{"t":"p","c":"attrs 參數和 data 參數在功能上類似，設置在 attrs 中的數據會合並到 data 中，但是 attrs 上的數據會體現在組件自身的特性上。"},0,{"t":"p","c":"在外部使用組件時，也可以通過特性將數據傳遞到組件內部。需要注意的是，通過特性傳遞的數據只能是字符串類型。"}],"get-set-comp":[0,{"t":"h1","c":"獲取和修改組件實例的值"},{"t":"p","c":"從外部也可以獲取或修改組件的數據。"},{"t":"p","c":"示例展示了如何在外部操作組件的數據；"}],"property-transmission":[0,{"t":"h1","c":"屬性傳遞"},{"t":"p","c":"通過使用屬性傳遞的模板語法，您可以將組件的數據應用於模板內的元素屬性。"},{"t":"p","c":"使用方法是在元素上添加特性 :name=\"key\"，其中 name 為目標元素要設置的屬性名，key 則為您自定義組件中要傳遞的屬性鍵名。"},{"t":"p","c":"之前在提到了使用選擇器的方式來設置屬性，而這裏介紹的是屬性傳遞語法設置屬性；"}],"bind-event":[0,{"t":"h1","c":"事件綁定"},{"t":"p","c":"在組件內部，您可以通過 on 屬性來綁定事件，讓組件具備交互能力。這裏演示了如何在組件中綁定事件以實現交互效果。"},{"t":"p","c":"proto 參數用於定義組件自身的方法，這些方法可以在組件內部使用，也可以在外部通過選擇器獲取組件後運行。"},{"t":"p","c":"on:click=\"xxx\" 後面可以是組件內部定義的方法名，也可以是函數表達式。如果使用函數表達式，無需顯式寫出 this 關鍵字，變量的作用域會自動綁定到組件自身；"},{"t":"p","c":"如果您想了解更多可用的事件類型，請參考 Events 文檔。"}],"nested-component":[0,{"t":"h1","c":"嵌套組件"},{"t":"p","c":"全部過多的邏輯放到一個組件上，不是一個明智的選擇；我們可以將邏輯分到另外的組件，在通過 l-m 方式導入另一個組件來使用；"},{"t":"p","c":"案例中通過 <l-m src=\"./comp-two.html\"></l-m> 引入了名為 CompTwo 的嵌套組件。"},{"t":"p","c":"通過 <comp-two :txt=\"val\"></comp-two> 使用了嵌套組件，並將當前組件的 val 屬性作為 txt 屬性傳遞給嵌套組件。這樣，嵌套組件可以使用傳遞過來的數據進行渲染。"},{"t":"p","c":"在 <comp-two></comp-two> 中，我們在不傳遞任何屬性的情況下使用了嵌套組件。這裏的使用方式取決於嵌套組件本身的邏輯和設計。"},{"t":"p","c":"只要一個組件加載成功，無論在何處，都可以使用相應名稱的組件。即使在多個地方多次使用 l-m 組件加載相同的組件，也不會導致組件被多次加載。這種機制保證了組件的重用和一致性。"}],"inject-host":[0,{"t":"h1","c":"inject-host 組件"},{"t":"p","c":"鑒於 Web Components 的隔離性，很難直接修改組件插槽內元素的樣式。為了應對這個問題，ofa.js 提供了一個名為 inject-host 的組件；inject-host 組件會向宿主層注入樣式，從而更靈活地配置組件的外觀。"},{"t":"p","c":"需要注意的是，使用此組件可能會影響宿主層的樣式。因此，在侵入樣式時應保持命名的規範性，以避免影響宿主的樣式。"},{"t":"p","c":"示例中，我們定義了 comp-two 組件，內部使用了 inject-host 組件來注入樣式。這使得我們可以通過注入的樣式對 comp-two 組件內的元素進行樣式設置，而不會影響到其他組件。"},{"t":"p","c":"同時，以下內容也需要特別注意："},{"t":"l","c":"- 通過在 inject-host 內添加 <style> 標簽，我們可以定義組件內的特定樣式。這些樣式只會影響到當前組件的元素，而不會波及到其他組件。\n- 在注入樣式時，應當避免使用過於普通的選擇器，以免影響到其他組件的樣式。需要保持選擇器的唯一性和特定性。\n- inject-host 也可以注入外部的樣式表文件，通過 <link rel=\"stylesheet\" href=\"target/style.css\"> 的方式。"},{"t":"p","c":"在整個示例中，通過使用 comp-two 組件內的 inject-host，我們可以在不破壞其他組件樣式的情況下，靈活地設置並應用組件內部的樣式。"}],"event-passing":[0,{"t":"h1","c":"事件傳遞"},{"t":"p","c":"除了監聽原生事件，on 還可以用於監聽自定義事件，這在組件間實現事件通信時非常重要。自定義事件通過 emit 方法來觸發。通過觸發自定義事件，可以將自定義數據傳遞給接收方。"},{"t":"p","c":"如果需要跨越組件的 Shadow DOM 邊界，以觸發事件，可以添加 composed 屬性。"},{"t":"p","c":"在下面的案例中，我們將學習如何使用 emit 方法在嵌套的組件之間進行事件傳遞。"}],"sync":[0,{"t":"h1","c":"雙向數據綁定"},{"t":"p","c":"通過使用 sync 語法，您可以在用戶界面的交互元素（例如輸入框或自定義組件）與數據模型之間建立實時的雙向關聯。"},{"t":"p","c":"以下示例演示了如何在組件中使用 sync 屬性來實現輸入框與數據模型之間的雙向數據綁定："},{"t":"l","c":"- 在 data 參數中，我們定義了名為 testText 的數據，並為其設置初始值為 \"I am testText\"。\n- 使用 sync:value=\"testText\" 表示輸入框的值與 testText 數據之間建立了雙向數據綁定。因此，當用戶在輸入框中輸入內容時，testText 數據會實時更新，反之亦然。\n- 同樣，使用 sync:txt=\"testText\" 表示自定義組件的 txt 屬性與 testText 數據之間建立了雙向數據綁定。組件的 txt 屬性發生變化時，testText 數據會實時更新，反之亦然。"},{"t":"p","c":"通過雙向數據綁定，您可以輕松地在用戶界面和數據模型之間建立聯系，使得數據的變化能夠自動反映在界面上，同時用戶在界面上的輸入也能立即影響到數據模型。"},{"t":"p","c":"值得注意的是，數據同步只能傳遞 字符串 或 數字，無法傳遞其他數據類型。"}],"condition":[0,{"t":"h1","c":"條件渲染"},{"t":"p","c":"模板內除了有模板語法，也有模板組件；"},0,{"t":"p","c":"條件渲染允許您在特定條件下，動態地在組件中插入不同的內容。以下是一個演示如何在組件內使用條件渲染的示例。"},{"t":"p","c":"在這個示例中，我們創建了一個名為 test-demo 的組件。組件內包含一個按鈕，點擊按鈕會使 count 屬性自增。通過 x-if、x-else-if 和 x-else 標簽，我們實現了條件渲染的邏輯。"},{"t":"l","c":"- x-if 標簽接受一個 value 屬性，用於定義條件。如果 value 的值為 true，則渲染 x-if 內部的內容。在這個示例中，如果 count 為偶數，將顯示紅色文本。\n- x-else-if 標簽也接受一個 value 屬性，用於定義條件。如果前面的條件不滿足且 value 的值為 true，則渲染 x-else-if 內部的內容。在這個示例中，如果 count 為 3 的倍數，將顯示藍色文本。\n- x-else 標簽不需要 value 屬性，它會在前面的條件都不滿足時渲染其內部的內容。在這個示例中，如果 count 既不是偶數也不是 3 的倍數，將顯示綠色文本。使用 x-else 時也可以緊跟在 x-if 後面；"},{"t":"p","c":"通過這種方式，您可以根據不同的條件動態地渲染不同的內容，實現靈活的交互和展示效果。"}],"fill":[0,{"t":"h1","c":"填充渲染"},{"t":"p","c":"填充渲染（x-fill）模板在前端框架中類似於列表渲染的概念，它允許您根據數據集合動態地渲染一組微型組件。"},{"t":"p","c":"在填充渲染過程中，您可以使用以下特殊變量："},{"t":"l","c":"- $data：代表填充項的數據。通過操作 $data，您可以獲取或修改每個填充項的數據。\n- $index：代表當前數據項在數據集合中的索引。\n- $host：代表當前組件自身。如果您想要獲取組件的數據或調用組件的方法，需要使用 $host 來訪問組件。"}],"life-cycle":[0,{"t":"h1","c":"生命周期"},{"t":"p","c":"生命周期鉤子函數提供了在組件不同階段執行代碼的機會。在 ofa.js 中，有五個主要的生命周期鉤子函數，它們分別是：created、ready、watch、attached 和 detached。"},{"t":"l","c":"- created(): 在組件被創建時調用，此時 shadow root 尚未開始渲染。可以在這裏執行一些初始化設置，但不能訪問 shadow root 中的元素。\n  \n- ready(): 在 shadow root 渲染完成後調用，一般用於組件的初始化邏輯。在這個階段，您可以訪問並操作 shadow root 內的元素，以及執行其他需要在渲染完成後執行的操作。\n\n- watch: 通過定義 watch 對象來監聽數據的變化。在 ready 完成後，會觸發一次 watch，對應著 data 上的值。之後，每次對應的鍵的值發生變動後，都會觸發 watch 內對應的函數。\n\n- attached(): 當組件被添加到 document 中時調用，此時可以進行與外部環境交互的操作，如獲取組件外觀或初始化共享數據的邏輯。\n\n- detached(): 當組件從 document 中移除時調用。在這個階段，您可以執行清理工作，取消與外部環境的交互，並釋放資源。"}],"fill-temp":[0,{"t":"h1","c":"遞歸填充渲染"},{"t":"p","c":"填充渲染允許您使用獨立的模板來渲染數據，並通過 <template> 元素添加 name 屬性進行命名。這種方式使得您可以實現嵌套結構的數據渲染，從而創建更復雜的組件。"},{"t":"p","c":"在使用 x-fill 進行填充渲染時，只需將對應的模板名稱傳遞給 name 屬性，即可渲染獨立模板的內容。此外，填充渲染還支持遞歸填充，即在模板內部可以繼續使用相同的模板名稱，實現嵌套填充。"},{"t":"p","c":"在示例中，我們定義了一個名為 item 的獨立模板，並在 x-fill 使用時傳遞了相應的模板名稱。這樣，數據中的每個項都將使用這個模板進行渲染，而且模板內部可以再次使用相同的模板名稱進行遞歸填充。這種方式使得您可以靈活地處理具有嵌套結構的數據，實現更加復雜的組件渲染。"}],"form-data":[0,{"t":"h1","c":"表單數據"},{"t":"p","c":"在許多應用中，處理表單數據是一項常見的任務。為了簡化這個過程，ofa.js 對表單數據的處理進行了二次抽象，提供了 formData 方法。通過這個方法，您可以輕松地將表單元素的值映射到一個對象上，並且在表單元素的值發生變化時，自動更新這個對象的數據，反之亦然。"},{"t":"p","c":"通過使用 shadow 屬性，您可以獲取到組件的 Shadow DOM 根節點的內容。這可以讓您在組件內部訪問和操作 Shadow DOM 中的元素和樣式。"},{"t":"p","c":"在這個示例中，我們可以看到如何利用 formData 方法將表單數據自動映射到對象 fdata 上。這使得您可以通過操作 fdata 對象來獲取或修改表單元素的值，而這些變動也會自動同步到對應的表單元素上。"}],"use-page":[0,{"t":"h1","c":"使用頁面組件"},{"t":"p","c":"一旦加載了 ofa.js，全局會自動添加一個名為 o-page 的頁面組件。這個組件用於加載頁面模塊，頁面模塊是一種特殊的組件模塊，不會注冊為自定義標簽，而是通過 o-page 組件來加載。"},{"t":"p","c":"頁面模塊類似於組件模塊，但是有一些不同之處。頁面模塊使用 page 屬性來定義模板，而不是 component 屬性。頁面模塊的開發邏輯和組件模塊一樣，使用相同的模板語法和模板組件等。然而，頁面模塊不能使用 attrs 特性，因為頁面的參數通常通過 URL 傳遞，而不是通過 data 或 attrs。"},{"t":"p","c":"在示例中，o-page 組件用於加載 page.html 頁面模塊。頁面模塊中使用 page 屬性定義模板，然後通過 JavaScript 函數返回一個對象來設置數據。URL 中的查詢參數 count 會被傳遞到頁面模塊中，並被用於初始化數據。頁面內的按鈕點擊事件可以更新數據並在頁面中呈現。"}],"custom-form-element":[0,{"t":"h1","c":"自定義表單組件"},{"t":"p","c":"使用 ofa.js，您可以輕松地開發自定義的表單元素組件，使其具有標準的表單特性。只需要為自定義組件添加 value 屬性並設置 name 特性，您的自制組件就能夠作為標準表單元素來使用。通過更新組件的 value 屬性，您就能實現與表單元素的交互。"},{"t":"p","c":"初始化 formData 時，需要將自定義組件的選擇器特征添加到參數中（盡管 formData 方法默認的參數為 \"input,select,textarea\"）。這樣，formData 就能夠與自定義組件進行聯動。"},{"t":"p","c":"在這個示例中，我們通過自定義組件 custom-input 來實現一個可編輯的文本輸入框。該組件被用作表單元素，並使用 value 屬性進行數據交互。使用 formData 方法時，我們將 \"input,custom-input\" 添加為參數，以便正確地初始化表單數據。"}],"use-app":[0,{"t":"h1","c":"使用 app 組件"},{"t":"p","c":"在 ofa.js 中，您可以使用 o-app 組件來創建整個應用的布局結構，並在其中加載不同的頁面模塊。通過使用 o-app 組件、o-page 組件和頁面模塊，您可以構建整個應用的頁面結構，並實現頁面之間的導航"},{"t":"p","c":"當 o-page 組件位於 o-app 內部時，您可以使用帶有 olink 屬性的 <a> 標簽來實現頁面跳轉。這種跳轉不會影響當前頁面，而是只會在 o-app 內部進行跳轉，類似於使用 <iframe>。"},{"t":"p","c":"如果 o-page 組件在 o-app 內部，您還可以使用以下方法："},{"t":"l","c":"- goto 方法來進行頁面跳轉\n- back 方法返回上一頁\n- replace 方法進行當前頁面的替換式跳轉"},{"t":"p","c":"通過使用 o-app 組件，您可以構建整個應用的布局結構，並在其中加載不同的頁面模塊。同時，o-app 提供的路由功能使得頁面之間的跳轉變得更加方便和靈活。"},{"t":"p","c":"在這個示例中，我們通過 o-app 組件創建了一個應用布局，然後在其中加載了一個頁面模塊 page1.html。"},{"t":"p","c":"在 page1.html 頁面模塊中，我們定義了一個標題和一個按鈕，點擊按鈕會跳轉到另一個頁面模塊 page2.html。我們還添加了一個帶有 olink 屬性的鏈接，點擊鏈接同樣會導航到 page2.html。"},{"t":"p","c":"在 page2.html 頁面模塊中，我們同樣定義了一個標題和一個按鈕，點擊按鈕會返回上一頁，實現頁面導航。"}],"app-config":[0,{"t":"h1","c":"配置 app 參數"},{"t":"p","c":"您可以通過為 o-app 標簽單獨設置外部模塊來配置應用的參數。"},{"t":"p","c":"這些參數是一個 ES 模塊，您可以配置以下參數："},{"t":"l","c":"- home: 應用的首頁，即初始加載時顯示的頁面。\n- loading: 在應用頁面點擊跳轉時，在未完成模塊加載前，顯示的加載中內容。您可以通過返回一個字符串作為 loading 內容。\n- pageAnime: 頁面跳轉時的動畫效果，使用的是一個包含 CSS 樣式屬性的對象。\n  - current: 表示頁面處於當前頁時的樣式。\n  - next: 表示頁面在未進場時的樣式。\n  - previous: 表示頁面在要退出時的樣式。"},{"t":"p","c":"通過這種方式，您可以根據應用的需要，自定義首頁、加載中樣式和頁面跳轉動畫等參數，從而為應用帶來更加個性化的體驗。"}],"nested-page":[0,{"t":"h1","c":"嵌套頁面"},{"t":"p","c":"一些應用程序的 UI 由多層嵌套的頁面組成，例如公用頂部或側邊的導航。你可以使用 parent 屬性來表示嵌套當前頁的父頁面。"},{"t":"p","c":"父頁面的制作方式類似於組件開發，你需要創建一個包含整個框架布局的頁面，然後將嵌套到內部的子頁面放到 slot 中。"},{"t":"p","c":"這個示例演示了如何創建嵌套頁面，其中 page1.html 和 page2.html 是子頁面，而 layout.html 是父頁面。父頁面 layout.html 包含了整個框架布局，而子頁面則通過 parent 屬性指向父頁面，表示它們應該嵌套在父頁面內。"},{"t":"p","c":"當切換頁面時，會觸發 routerChange 事件。在頁面初始化和切換頁面時，你可以使用 app.current 屬性來獲取當前頁地址，並在頁面中修正標簽頁的激活狀態。"}],"app-loading":[0,{"t":"h1","c":"為 app 定制 loading"},{"t":"p","c":"以下是一個為 o-app 組件定制 loading 的示例。在這個示例中，我們為 loading 創建了一個漂亮的進度條，它會在頁面加載期間逐漸增長，加載完成後會直接到達 100%，然後將 loading 元素刪除。"},{"t":"p","c":"您可以將以下代碼復制並用於定制您的應用的 loading 效果："},0,{"t":"p","c":"通過這段代碼，您可以為您的應用添加一個獨特的加載效果，讓用戶在頁面切換過程中有更好的體驗。"}],"set404":[0,{"t":"h1","c":"配置404頁面"},{"t":"p","c":"在應用的配置模塊中，通過設置 fail 函數，以自定義在頁面加載失敗時所展示的內容；"},{"t":"p","c":"在這個示例中，當頁面加載失敗時，將顯示加載錯誤信息的第一行內容；"},0],"multi-nested":[0,{"t":"h1","c":"多級嵌套頁面"},{"t":"p","c":"要使用多層嵌套頁面功能，只需在父層的嵌套頁面模塊上設置\"parent\"屬性，並將其值設為要嵌套頁面模塊的地址。"},{"t":"p","c":"更詳細的信息，請參閱之前的文章，其中提供了與嵌套相關的參數和方法。"}],"use-hash-router":[0,{"t":"h1","c":"使用 hash router"},{"t":"p","c":"只需使用 o-router 組件，即可將 app 組件內的路由與當前網頁關聯起來。一旦頁面與路由綁定，即使進行頁面刷新，也能保持頁面的路由狀態。"},{"t":"p","c":"在這個示例中，請點擊  <span style='font-family: \"iconfont\"'>&#xe7cb;</span>  按鈕，以新頁面的方式打開並嘗試。"},0],"sync-state":[0,{"t":"h1","c":"狀態同步"},{"t":"p","c":"有時候需要多個組件實例或頁面共享一份數據，這時候就需要狀態同步的功能。"},{"t":"p","c":"使用 $.stanz 方法創建可共享的數據；如果需要在組件中分享此數據，應在組件的 attached 時將數據綁定到組件上。"},{"t":"p","c":"注意：需要在 detached 周期將綁定的數據清除，不然會內存泄露。"},{"t":"p","c":"在這個示例中，我們演示了如何使用狀態同步功能來實現暗黑模式的切換。首先，我們使用 $.stanz 方法創建了一個名為 isDark 的數據對象，該對象可以在多個組件間共享。使不同組件實例能夠共享數據，實現暗黑模式的切換。"}],"use-scsr":[0,{"t":"h1","c":"使用 SCSR 方案"},{"t":"p","c":"在這個示例中，請點擊 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 按鈕，以新頁面的方式打開並嘗試；"},{"t":"p","c":"SCSR 的全稱是 Static Client-Side Rendering，又稱為靜態客戶端渲染。它是 CSR（Client-Side Rendering）的一種變種，在保留了 CSR 用戶體驗的基礎上，還能夠讓頁面在靜態狀態下被搜索引擎爬取。"},{"t":"p","c":"當前網站采用的正是 SCSR 方案構建；"},{"t":"p","c":"SCSR 通過直接運行單文件模式的頁面模塊，無需使用 o-page 標簽，實現在頁面上進行渲染。具體而言，就是將頁面模塊的模板代碼直接嵌套在 o-app 內。"},{"t":"h2","c":"注意事項"},{"t":"p","c":"對於所有采用 SCSR 方案的頁面，除了頁面描述性的內容（如 title、meta:description、keywords）和頁面模板內容外，其他引用的資源必須保持一致，以確保在頁面跳轉和刷新後的用戶體驗一致。"}],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"通過設置別名（alias），使用者能夠更方便地使用共享的資源，特別適用於使跨域名的共享組件更方便地享用同一版本的資源。"},{"t":"p","c":"在這個示例中，我們通過 lm.config 方法設置了別名，將 @obook 別名映射到 https://cdn.jsdelivr.net/npm/obook。現在，當我們使用 @obook 作為前綴時，它將自動映射到指定的 URL。"},0,0,0,0,{"t":"p","c":"通過使用別名 @obook，我們在 l-m 標簽中引入了 \"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\" 這個資源，使得跨域名的組件可以更方便地訪問共享資源，而無需知曉詳細的資源地址。這增強了代碼的可維護性和跨域名資源共享的便捷性。"},{"t":"h2","c":"注意事項"},{"t":"p","c":"在設置別名時，請注意以下幾點："},{"t":"l","c":"- 別名的鍵必須以 @ 開頭，如 @example。"},0,{"t":"l","c":"- 不要重復設置相同名稱的別名，否則會引發錯誤。"},0]},"docs":{"introduce":[{"t":"h1","c":"ofa.js - 漸進式前端框架"},{"t":"h2","c":"什麽是 ofa.js"},{"t":"p","c":"ofa.js是一個漸進式前端框架，旨在讓開發者以最低成本進入前端開發和使用流程。它提供了一系列簡單而強大的工具和API，讓前端開發變得更加高效和便捷。"},{"t":"h2","c":"存在目的"},{"t":"h3","c":"取代 jQuery"},{"t":"p","c":"在許多小型項目中，我們可能並不需要引入像React和Vue這樣的大型框架，而是傾向於使用jQuery進行簡單的前端操作。ofa.js改進了jQuery的API，並將jQuery的許多方法替代為屬性，使得使用ofa.js在很多場景下更為合適。"},{"t":"h3","c":"簡化前端開發和使用流程"},{"t":"p","c":"ofa.js的目標是簡化繁瑣的前端開發流程。它允許開發者無需學習復雜的Node.js、npm和腳手架等工具，從而更快地搭建前端應用。使用它，你可以回歸到只需引入一個庫即可進行開發的體驗。"},{"t":"h3","c":"成為銀彈型前端開發框架"},{"t":"p","c":"ofa.js旨在成為一種\"銀彈\"，即能夠解決多種前端開發問題，並提供全面的解決方案。它不僅僅是一個工具庫，更是一種全面的前端開發框架。"},{"t":"h2","c":"特點"},{"t":"h3","c":"易上手的組件開發"},{"t":"p","c":"使用ofa.js開發的組件幾乎沒有學習成本。ofa.js提供了簡潔而直觀的API，讓開發者可以快速創建和集成組件，同時保持代碼的整潔和易於維護。"},{"t":"h3","c":"內置模塊化、狀態更新和應用集成方案"},{"t":"p","c":"ofa.js內部已經集成了模塊化、狀態更新和應用集成等解決方案，使得開發者無需額外尋找第三方庫或工具，就可以完成復雜的前端開發任務。"},{"t":"h3","c":"官方提供路由和 SSG（靜態站點生成）方案"},{"t":"p","c":"ofa.js還為路由和SSG提供了官方解決方案，幫助開發者更好地管理前端路由和生成靜態站點，提高應用性能和SEO友好度。"},{"t":"h3","c":"精簡的代碼體積"},{"t":"p","c":"ofa.js的代碼經過精心優化，壓縮後的.min文件大小只有38kb(gzip下只有14kb)。這使得ofa.js成為一個高效的前端框架，可以在各種網絡環境下快速加載和使用。"}],"get-started":{"index":[{"t":"h1","c":"上手使用"},{"t":"h2","c":"如何使用"},{"t":"h3","c":"直接引用"},{"t":"p","c":"你可以通過 CDN 的地址直接將 ofa.js 引用到你的頁面上："},0,{"t":"h3","c":"通過 npm 安裝"},{"t":"p","c":"首先，在你的項目中安裝 ofa.js："},0,{"t":"p","c":"然後在項目中引入 ofa.js 模塊："},0,{"t":"h3","c":"使用"},{"t":"p","c":"在引用資源後，ofa.js 將在全局作用域上設置一個 $ 屬性，所有的功能都在 $ 上，後面的教程會詳細講解其用法；"},{"t":"p","c":"通常情況下，我們建議采用直接引用的方式添加 ofa.js，而使用 npm 的方式則用於與類似 React 和 Vue 等框架進行兼容。"},{"t":"h3","c":"調試模式"},{"t":"p","c":"你可以通過在引用 ofa.js 的 script 標簽上添加 debug 屬性來開啟調試模式。在調試模式下，加載的組件模塊或頁面模塊將啟用 sourceMap 功能，允許你直接從源文件進行調試。"},0,{"t":"p","c":"開啟調試模式後，你將能夠更方便地追蹤和調試你的組件代碼。這對於開發過程中的錯誤排查和代碼調試非常有幫助。"}],"hello-world":[{"t":"h1","c":"第一個案例"},{"t":"p","c":"以下是一個案例，點擊按鈕後將文本更改為 \"Hello World\"："},0,0,0,0,{"t":"p","c":"當點擊按鈕後，將會顯示加粗的 \"Hello World\" 文本。"},{"t":"p","c":"現在，讓我們詳細解釋一下基礎概念。"},{"t":"h2","c":"選擇器"},{"t":"p","c":"引用了 ofa.js 後，$ 符號將被注冊到全局作用域中。通過 $('xxx') 來選擇符合條件的第一個 元素，其中 xxx 是標準的 CSS Selector  內容。你可以點擊鏈接查看具體的選擇器內容。"},{"t":"p","c":"以下是一個例子："},0,0,0,0,{"t":"p","c":"在上面的案例中，打開頁面一秒後，會分別改變 p標簽 、#desk 和 .logger  的文本內容。"},{"t":"h2","c":"事件綁定"},{"t":"p","c":"選擇元素成功後，你可以為元素綁定事件。就像前面提到的 \"Hello World\" 案例中，我們給 id 為 \"btn\" 的元素綁定了點擊事件。當點擊按鈕後，綁定的函數會被執行。"},{"t":"p","c":"你可以點擊跳轉查看 事件示例  章節，了解一些事件綁定的案例；"},{"t":"p","c":"所有可用的事件，可以參考 Web Events 來了解完整的事件列表。"},{"t":"h2","c":"屬性"},{"t":"p","c":"在上面的兩個案例中，我們分別展示了 html 和 text 屬性的使用。"},{"t":"p","c":"你還可以通過 html 或 text 屬性來獲取元素的內容，如下所示："},0,0,0,0,{"t":"p","c":"這個例子中，我們將 #t1 元素內的 HTML 內容賦值給了 #t2 和 #t3 元素。"}],"elements-and-events":[{"t":"h1","c":"獲取元素和事件相關"},{"t":"p","c":"該章節旨在加強對上一章內容的理解，包括選擇元素 和 事件綁定。"},{"t":"h2","c":"選擇元素"},{"t":"p","c":"在之前的章節中，我們已經了解了通過 $ 符號從全局獲取某個元素的方法。接下來，我們將介紹其他獲取元素的方法。"},{"t":"h3","c":"從元素內查找某個元素"},{"t":"h4","c":"使用 $(\"xxx\").$('xxxx') 的方式"},{"t":"p","c":"$(\"xxx\").$('xxxx') 是通過先選擇一個父元素，然後在其內部查找符合條件的子元素的方式。其中，$(\"xxx\") 選擇了一個父元素，然後使用 $('xxxx') 在該父元素內查找符合條件的子元素。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，首先通過 $(\".parent\") 選擇了具有 parent 類的父元素，然後使用 $(\".child\") 在該父元素內查找具有 child 類的子元素。然後修改了子元素的文本內容為 \"Modified child element\"。"},{"t":"h3","c":"使用 $('xxx xxxx') 的方式"},{"t":"p","c":"$('xxx xxxx') 是通過在全局範圍內查找符合第二個選擇器條件的元素，然後在這些元素內部查找符合第一個選擇器條件的元素。這種方式可以直接一步到位地查找到符合條件的子元素。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，直接使用 $('div .child') 查找到具有 child 類的子元素，並修改了子元素的文本內容為 \"Modified child element\"。"},{"t":"h3","c":"選擇多個元素"},{"t":"h4","c":"使用 $.all('xxx') 查找全局的元素"},{"t":"p","c":"$.all('xxx') 方法用於查找頁面中所有符合選擇器條件的元素，並將它們作為一個元素集合返回。這樣可以選擇頁面中的多個元素進行批量操作。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，使用 $.all(\"p\") 查找到頁面中的所有 p 標簽元素，並對它們進行了批量操作，將文本內容修改為 \"Modified Paragraph 1\"、\"Modified Paragraph 2\" 和 \"Modified Paragraph 3\"。"},{"t":"h3","c":"從元素內查找所有符合條件的元素"},{"t":"p","c":"除了可以在全局範圍內查找元素，還可以從某個元素內查找所有符合條件的子元素，使用方式為：$('xxx').all('xxxx')。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，首先使用 $(\".container\") 查找到具有 container 類的元素，然後通過 .all(\".item\") 在該容器內查找所有帶有 item 類的子元素，並對它們進行了批量操作，將文本內容修改為 \"Modified Item 1\"、\"Modified Item 2\" 和 \"Modified Item 3\"。"},{"t":"h2","c":"事件"},{"t":"p","c":"前面已經講過 on 綁定事件的使用方法，後面介紹幾個和事件相關的方法；"},{"t":"h3","c":"off 方法的使用文檔"},{"t":"p","c":"off 方法用於移除通過 on 方法綁定的事件處理函數。當不再需要某個事件的處理函數時，可以使用 off 方法將其從元素上移除，以避免重復執行或內存泄漏。"},{"t":"h4","c":"語法"},0,{"t":"l","c":"- selector: 選擇要移除事件處理函數的元素。 \n- eventName: 要移除的事件名稱。 \n- eventHandler: 要移除的事件處理函數。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，當點擊按鈕時，會彈出一個對話框顯示 \"Button clicked!\"。但是在5秒後，通過 off 方法移除了點擊事件處理函數，所以按鈕再次點擊時不會觸發彈出對話框。"},{"t":"h3","c":"one 方法的使用文檔"},{"t":"p","c":"one 方法用於綁定事件處理函數，但該處理函數只會在第一次觸發事件時執行一次。在執行一次後，事件處理函數會被自動移除，避免重復觸發。"},{"t":"h4","c":"語法"},0,{"t":"l","c":"- selector: 選擇要綁定事件處理函數的元素。 \n- eventName: 要綁定的事件名稱。 \n- eventHandler: 要執行的事件處理函數。"},{"t":"h4","c":"示例"},0,0,0,0,{"t":"p","c":"在上面的示例中，當點擊按鈕時，會彈出一個對話框顯示 \"Button clicked once!\"。但是在第一次點擊後，事件處理函數就會被移除，所以後續點擊按鈕不會再觸發彈出對話框。"},{"t":"h3","c":"emit 方法的使用文檔"},{"t":"p","c":"emit 方法用於手動觸發元素上綁定的特定事件。通過 emit 方法可以在不進行實際操作的情況下觸發事件處理函數的執行。"},{"t":"h4","c":"語法"},0,{"t":"l","c":"- selector: 選擇要觸發事件的元素。 \n- eventName: 要觸發的事件名稱。"},{"t":"h4","c":"示例"},0,{"t":"p","c":"在上面的示例中，通過 emit 方法手動觸發了按鈕的點擊事件，結果會彈出一個對話框顯示 \"Button clicked!\"，盡管沒有實際點擊按鈕。"},{"t":"p","c":"注意：使用 emit 方法不會模擬鼠標點擊或其他實際事件，它只會直接調用已綁定的事件處理函數。所以，如果你希望在特定情況下觸發事件的執行，可以使用 emit 方法。"},{"t":"p","c":"當你綁定事件後，有時你可能希望阻止事件的進一步傳播（冒泡）或取消事件的默認行為。下面將介紹如何在事件觸發後禁止冒泡和取消默認事件。"},{"t":"h3","c":"禁止事件冒泡"},{"t":"p","c":"事件冒泡是指當一個元素上的事件被觸發時，它會沿著 DOM 樹向上冒泡，依次觸發父元素上的同類型事件。如果你希望在特定元素上處理事件後阻止其繼續冒泡，可以使用 event.stopPropagation() 方法。"},{"t":"p","c":"示例代碼："},0,{"t":"p","c":"在上面的示例中，當你點擊按鈕 \"Click Me\" 後，它會顯示 \"Button Clicked!\"，但不會觸發 \"Inner Div Clicked!\" 和 \"Outer Div Clicked!\"。這是因為我們在按鈕的點擊事件處理程序中調用了 event.stopPropagation()，阻止了事件的進一步傳播。"},{"t":"h3","c":"取消事件的默認行為"},{"t":"p","c":"有些元素上的事件在觸發時會有默認的行為。例如，點擊提交按鈕會導致表單提交，點擊鏈接會跳轉到鏈接的地址等。如果你希望阻止事件的默認行為，可以使用 event.preventDefault() 方法。"},{"t":"p","c":"示例代碼："},0,{"t":"p","c":"在上面的示例中，當你點擊提交按鈕 \"Submit\" 後，它會顯示 \"Hello, {name}! Form submission prevented.\"，但不會觸發 \"Form Submitted!\" 的警報。這是因為我們在提交按鈕的點擊事件處理程序中調用了 event.preventDefault()，阻止了表單的提交默認行為。"}],"basic-concept":[{"t":"h1","c":"實例的基礎概念"},{"t":"p","c":"$ 實例是對頁面上元素的封裝，除了用於選擇現有的元素外，它還可以直接創建新元素並進行操作。在本章中，我們將介紹如何創建新元素以及對 $ 實例的一些操作。"},{"t":"h2","c":"創建新元素"},{"t":"p","c":"通過 $ 實例，我們可以直接創建新的元素並進行操作，例如："},0,0,0,0,{"t":"p","c":"在上面的例子中，我們通過 $('<div style=\"color:red\">I am text</div>') 創建了一個新的 div 元素，並將其添加到了 body 中。"},{"t":"h2","c":"獲取子元素"},{"t":"p","c":"通過 $ 獲取的實例，並不像 DOM 元素那樣擁有 children 屬性。但是我們可以通過數組索引來訪問實例的直接子元素："},0,0,0,0,{"t":"p","c":"在上面的例子中，我們獲取了 div 元素，並通過索引來訪問第一個和第二個 p 元素。同時，我們還使用了 $div.length 獲取了子元素的數量。"},{"t":"h2","c":"操作子元素"},{"t":"p","c":"通過 $ 實例，我們還可以直接使用數組的方法來操作子元素，例如 push 和 pop："},0,0,0,0,{"t":"p","c":"在上面的例子中，我們獲取了所有 p 元素的 $ 實例，並使用 push 方法添加了一個新的 div 元素作為子元素，然後使用 pop 方法移除了最後一個子元素。"},{"t":"p","c":"通過上述示例，你可以了解 $ 實例的一些基本操作，包括創建新元素和對子元素的訪問與操作。 $ 實例提供了簡便的方法來操作頁面上的元素。"}],"common-properties":[{"t":"h1","c":"常用屬性或方法"},{"t":"p","c":"在 $ 實例中，除了可以通過選擇器選擇元素外，還提供了一些常用的來方便元素的操作和查找。"},{"t":"p","c":"可以稍微瀏覽一下，將來在需要時，可以隨時參考 API 文檔。"},{"t":"h2","c":"常用的屬性"},{"t":"l","c":"- tag：獲取目標的標簽名\n- ele：獲取實例的實際原生元素\n- index：獲取目標元素在其父元素下的排序\n- text：獲取或設置目標元素的文本\n- html：獲取或設置目標元素的 HTML 代碼\n- css：獲取或設置目標元素的樣式\n- style：獲取目標元素的原生樣式\n- classList：獲取目標元素的原生 class 列表\n- data：獲取目標元素的原生數據集"},{"t":"h3","c":"節點操作"},{"t":"l","c":"- before：在目標實例的前面添加元素\n- after：在目標實例的後面添加元素\n- remove：刪除目標元素\n- attr：獲取或設置目標元素的 attributes"},{"t":"h2","c":"重要特性"},{"t":"l","c":"- 表單數據：方便地綁定和獲取表單數據"},{"t":"p","c":"如果還想更深入了解 ofa.js 的 api，可以參考 API 文檔；"}]},"create-component":{"index":[{"t":"h1","c":"制作和使用組件"},{"t":"p","c":"ofa.js 使用基礎的 HTML 和 JavaScript 文件來定義組件，避免引入新的文件類型以減少學習成本。只要你對 HTML 有一定的了解，就能夠快速開發和使用 ofa.js 組件。"},{"t":"h2","c":"準備創建組件前的步驟"},{"t":"p","c":"在開始創建組件之前，需要注意一些準備工作。由於創建組件涉及到瀏覽器請求資源的操作，如果你僅僅是雙擊打開 HTML 文件來查看，會在 \"file\" 協議下進行查看。在 \"file\" 協議下，JavaScript 模塊的加載可能會報錯。因此，你需要準備一個靜態服務器來正確查看組件。"},{"t":"p","c":"如果你使用的是 Visual Studio Code 編輯器，你可以簡單地安裝一個支持靜態服務器的插件。我們推薦使用 Live Server 插件。"},{"t":"p","c":"安裝插件後，只需在 demo.html 文件上右鍵點擊，選擇 \"Open with Live Server\"，插件將會自動以靜態服務器模式打開文件。"},{"t":"p","c":"如果你使用的是其他編輯器，你也可以創建一個 Nginx 或 Apache 服務器，只要能夠支持靜態 HTML 查看即可。這樣做可以確保你能夠正常預覽和開發你的組件。"},{"t":"h2","c":"創建一個按鈕組件"},{"t":"p","c":"下面，我們將創建一個簡單的按鈕組件，命名為 simple-button，它將具有比原生按鈕更美觀的樣式。"},{"t":"p","c":"首先，創建一個名為 simple-button.html 的文件，其中使用 template 標簽，並添加 component 屬性以標識為組件。"},{"t":"p","c":"然後，在 template 內部編寫組件的模板代碼。接著，在模板內容下方，添加一個 script 標簽，將組件的 JavaScript 代碼放入其中。"},0,{"t":"p","c":"在成功引入 ofa.js 後，會自動注冊 load-module 組件，這是一個用於聲明式引用模塊的組件，類似於 script 標簽。該組件會代理加載指定 src 的模塊，並對需要加載的模塊進行預處理。在本案例中，會加載模板並注冊 simple-button 組件。"},{"t":"p","c":"load-module 組件還可以使用縮寫 l-m，以減少代碼量。"},0,{"t":"p","c":"load-module 組件是一個定制的聲明式加載器庫，提供了強大的功能，可以擴展支持各種類型的文件，或者對 JavaScript 模塊進行中轉處理。它已經拆分成了一個獨立的項目，具體的使用文檔在 https://github.com/kirakiray/drill.js。"},{"t":"h3","c":"雙文件模式"},{"t":"p","c":"雙文件模式將 靜態模板 和 邏輯代碼 分開，使組件更加清晰。"},{"t":"p","c":"邏輯代碼放在 js 文件內，這個 js 需要標識 export const type = $.COMP;，以通知頁面這是一個組件模塊。在這種拆分模式下，模塊代碼可以使用 import 等 ES Module 的標準語法。"},{"t":"p","c":"按鈕組件由兩個文件組成："},{"t":"l","c":"1. simple-button.html：按鈕組件的 HTML 模板和樣式。"},0,{"t":"l","c":"2. simple-button.mjs：按鈕組件的注冊代碼。"},0,{"t":"p","c":"在需要使用該組件的地方，使用 l-m 引入這個模塊。以下是使用 simple-button 的案例頁面（雙文件模式）。"},0],"life-cycle":[{"t":"h1","c":"組件的生命周期"},{"t":"p","c":"在 ofa.js 中，組件生命周期是在特定時間點觸發的鉤子函數。這些鉤子函數讓你能更精細地控制和交互，ofa.js 有五個關鍵生命周期鉤子：created、ready、watch、loaded、attached 和 detached，分別在不同時刻觸發。"},{"t":"h2","c":"生命周期鉤子"},{"t":"h3","c":"created"},{"t":"p","c":"created 生命周期鉤子在組件創建時被觸發。在此階段，組件的數據尚未被初始化，模板內容也未被渲染。你可以在這個階段執行一些初始化操作，或者準備在後續階段使用的數據。"},{"t":"h3","c":"ready"},{"t":"p","c":"ready 生命周期鉤子會在組件的數據和模板剛被初始化後觸發，表示組件已經準備就緒。在這個階段，你可以訪問組件的數據，並且模板已經渲染完成，可以執行一些與界面交互相關的操作。"},{"t":"p","c":"如果組件模板存在對其他組件的依賴，這個階段不會等待依賴加載完成。因此，這個階段適合為組件添加Loading樣式，但需要注意等待依賴加載完成後再執行相關操作。"},{"t":"h3","c":"watch"},{"t":"p","c":"一旦 ready 階段完成，與之關聯的 watch 對象中的監聽函數會被觸發一次。隨後，當數據的某個值發生變動時，會再次觸發相應鍵（key）的監聽函數。"},{"t":"h3","c":"loaded"},{"t":"p","c":"loaded 生命周期鉤子在組件模板內的所有依賴都加載完成後觸發。這個階段確保在渲染組件之前，所有的依賴都已經加載完畢。這個時候適合去除在 ready 階段添加的Loading樣式。"},{"t":"h3","c":"attached"},{"t":"p","c":"attached 生命周期鉤子會在組件被添加到文檔中時觸發。在這個階段，適合獲取組件內元素的尺寸相關信息，進行數據綁定和全局事件的操作。"},{"t":"h3","c":"detached"},{"t":"p","c":"detached 生命周期鉤子會在組件從文檔中移除時觸發。在這個階段，你可以執行一些清理操作，比如取消事件監聽或者釋放資源，以防止內存泄漏。"},{"t":"h2","c":"示例演示"},{"t":"p","c":"以下是一個示例，展示了如何使用這些生命周期鉤子："},0,{"t":"h2","c":"生命周期流程圖"},0],"parameter-description":[{"t":"h1","c":"組件的注冊參數詳解"},{"t":"p","c":"在 ofa.js 中，你可以在組件模塊中定義一些特定的注冊參數，以便更靈活地配置組件。下面詳細說明了每個注冊參數，並附帶了相應的示例演示。"},{"t":"h2","c":"基礎參數"},{"t":"p","c":"基礎參數是注冊組件的最基本配置，包含以下幾個屬性："},{"t":"h3","c":"tag"},{"t":"p","c":"tag 代表注冊的組件名。當沒有定義 tag 屬性時，注冊的組件名與文件名保持一致。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"data"},{"t":"p","c":"data 是對象類型屬性，用於生成組件後，默認添加的自定義數據。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs 是對象類型屬性，也屬於 data，但是這個數據會反映到 element 的 attributes 上，attributes 上的改動也會動態改動到組件的 data 上。當出現大寫的 key 時，反應到組件 property 會變成 - 駝峰的命名。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"proto"},{"t":"p","c":"在組件的注冊參數中，你可以添加一個 proto 對象，用於定義需要添加到組件原型上的方法。這樣，在創建組件的實例時，這些屬性和方法就會被添加到實例的原型上，從而所有實例都可以訪問和共享這些方法。"},0,{"t":"h3","c":"watch"},{"t":"p","c":"watch 是對象類型屬性，用於監聽 data 變化的監聽函數放在這裏。注冊成功後，監聽的值會被立刻執行一次。"},{"t":"l","c":"- watch 注冊的函數在單次線程改動中，只會被觸發一次。因此，在一次線程中，即使多次修改這個監聽的值，也只會被觸發一次。\n- 第一個參數為當前值。\n- 第二個參數是對象，會帶有 watchers 數據集，一般情況下 watchers 上只會有一個對象，可以從這個對象上獲取到 oldValue。當單次線程的這個被監聽的值被改動過多次，這個數據集會記錄多次的變化。"},{"t":"p","c":"示例："},0,{"t":"h3","c":"temp"},{"t":"p","c":"通常情況下，不需要設置這個變量，它主要在分離模式下使用，用於指定組件模板的地址。當未定義 temp 時，默認會加載與當前模塊同名的 HTML 文件，該文件應位於相同目錄中。"},{"t":"h2","c":"合並變量到 default"},{"t":"p","c":"可以將所有的導出變量寫到 default 上，這樣寫起來更方便；"},0,{"t":"h2","c":"示例代碼"},{"t":"p","c":"以下為一個完整的示例代碼，包括基礎參數的定義和組件模板。"},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"你還可以使用異步函數來定義 default 數據，以便動態地返回組件的注冊參數。"},{"t":"p","c":"函數的 function 會帶來一個對象，包含 load、url 和 query："},{"t":"l","c":"- load 方法是異步加載函數，使用方法和異步 import 加載一致，可以通過 const data = await load(xxx) 加載異步模塊。\n- 通過 load 加載的模塊，會有和 load-module 加載一樣的效果。load 方法相當於 load-module 組件的函數版，具體使用方法可以查閱https://github.com/kirakiray/drill.js的文檔。\n- url 是當前模塊的文件名。\n- query 是加載這個模塊時的 URL 參數轉成的對象。"},{"t":"p","c":"以下是使用 default 的示例："},0,{"t":"p","c":"在這個示例中，我們演示了如何使用 ofa.js 的注冊參數來定制化組件的行為。通過合理地配置這些參數，你可以更好地適應不同的組件需求，實現更靈活的組件開發。"}],"web-components":[{"t":"h1","c":"組件化常規知識"},{"t":"p","c":"ofa.js 是一個基於 Web Components 技術的封裝庫，旨在簡化和加速組件開發過程。它通過將復雜的技術細節隱藏在背後，讓開發者能夠更專注地構建高質量的組件和應用。"},{"t":"p","c":"為了更好地開發組件，有必要學習一些 Web Components 的知識。下面介紹的知識點不僅可以在 ofa.js 中應用，還可以讓你在其他使用 Web Components 的框架上同樣受益。"},{"t":"h2","c":"Shadow DOM 容器"},{"t":"p","c":"在 Web Components 中，Shadow DOM 提供了一種隔離的容器，用於封裝組件內部的樣式和結構。這意味著組件內部的樣式和 DOM 結構不會與外部的樣式和結構相互幹擾，從而確保組件的可預測性和可維護性。"},{"t":"p","c":"在 ofa.js 中，每個組件都有一個 Shadow DOM 容器，用於隔離組件的內部內容。模板內容就是被渲染到這個容器內。通過 $ 獲取的組件實例，也可以使用 shadow 屬性訪問組件內部的 Shadow DOM 容器，從而實現對組件內部元素的操作和訪問。"},0,{"t":"h2","c":"Web Components 中的常用 CSS 選擇器"},{"t":"p","c":"Web Components 提供了一些特殊的 CSS 選擇器，用於選擇和樣式化組件內部的不同部分。以下是一些常用的選擇器："},{"t":"h3","c":":host 選擇器"},{"t":"p","c":":host 選擇器用於選擇組件自身的外部容器。可以通過這個選擇器來定義組件的樣式。"},0,{"t":"h3","c":"::slotted() 選擇器"},{"t":"p","c":"::slotted() 選擇器用於選擇被插槽內容包裹的元素。可以在組件內部的樣式中使用這個選擇器來樣式化被插槽的內容。"},0,{"t":"h2","c":"插槽（Slot）的使用"},{"t":"p","c":"插槽是 Web Components 中用於在組件內部嵌入外部內容的機制。插槽允許開發者將自定義的內容傳遞到組件內部，實現更靈活的組件結構。"},{"t":"h3","c":"單個插槽"},{"t":"p","c":"在組件模板中，可以使用 <slot> 元素來定義插槽。外部傳入的內容會被插入到插槽內部。"},0,0,{"t":"h3","c":"多個命名插槽"},{"t":"p","c":"除了默認插槽外，還可以定義多個命名插槽。命名插槽允許開發者將不同的內容插入到不同的插槽位置。"},0,0,{"t":"h2","c":"slotchange 事件的使用"},{"t":"p","c":"slotchange 事件在插槽內容變化時觸發。可以通過監聽這個事件來執行一些與插槽內容相關的操作。"},0],"template-syntax":[{"t":"h1","c":"模板語法"},{"t":"p","c":"ofa.js 提供了一系列強大的模板語法，使你能夠更靈活地操作組件的界面元素和數據。這些模板語法能夠幫助你實現豐富的界面效果和交互體驗。"},{"t":"l","c":"- 文本渲染：快速在模板文件上渲染文本\n- class：快速在模板文件上渲染類名\n- sync：快速同步數據到模板文件\n- 條件渲染：按需在模板文件上渲染內容\n- 列表渲染：在模板文件上快速渲染數組數據"}]},"create-app":{"index":[{"t":"h1","c":"介紹"},{"t":"p","c":"除了可以開發組件，ofa.js 還可以用於開發功能完整的應用程序。"},{"t":"p","c":"ofa.js 將應用程序集成為一個 o-app 組件，通過直接使用這個標簽，你就能夠快速創建應用程序。這種方式使應用的創建變得簡單且高效。"},{"t":"p","c":"此外，ofa.js 官方還提供了完整的 路由 和 SSG（靜態頁面生成） 方案，幫助開發者構建更健全的應用程序。這些功能能夠加速開發流程，讓你能夠專注於應用程序的邏輯和用戶體驗，而不必過多擔心底層細節。"},0,{"t":"p","c":"上面是一個簡單的應用教程代碼示例，接下來會逐步講解應用的開發過程。"}],"page":[{"t":"h1","c":"使用 o-page 組件"},{"t":"p","c":"在 ofa.js 內部，我們構建了一個名為 o-page 的自定義組件，旨在為頁面的開發提供便利。這個組件在應用開發中扮演著關鍵的角色。當你想要使用組件的模板語法，但又不想創建全新的組件時，o-page 組件將成為你的最佳選擇。"},{"t":"h2","c":"頁面模塊"},{"t":"p","c":"創建一個單文件頁面模塊時，類似於創建組件模塊。使用 template 標簽來包裹頁面的模板代碼，並添加 page 屬性。在該標簽內部，可以自由使用模板語法與其他組件或頁面模塊進行交互。"},0,{"t":"p","c":"在 HTML 文件中，使用 o-page 標簽的 src 屬性指定頁面模塊的文件路徑。頁面內容將在該組件內部進行渲染。"},0,{"t":"h2","c":"雙文件模式"},{"t":"p","c":"雙文件模式將 靜態模板 和 邏輯代碼 分開，使頁面的內容更加清晰。"},{"t":"p","c":"以下是使用 o-page 組件和頁面模塊的步驟："},{"t":"l","c":"1. 創建頁面模塊："},{"t":"p","c":"與創建組件模塊類似，創建一個頁面模塊，但將 type 屬性設置為 $.PAGE。頁面模塊可用的參數包括 temp、data、proto 和 watch。"},0,{"t":"l","c":"2. 創建頁面模板："},{"t":"p","c":"在與頁面模塊相同的目錄下，創建一個名為 my-page-template.html 的頁面模板文件。在這個模板文件中，你可以使用模板語法進行交互，用法與前面提到的組件模板語法類似。"},0,{"t":"p","c":"在你的 HTML 文件中，通過 <o-page> 標簽來使用 o-page 組件，通過 src 屬性引用頁面模塊的文件路徑。頁面的內容將會在這個組件內部渲染。"},0,{"t":"p","c":"這樣，當你打開頁面時，o-page 組件會動態加載 my-page.mjs 這個頁面模塊，並根據模塊中的模板和數據渲染頁面內容。頁面模塊的生命周期和模板語法與組件模塊保持一致，使得頁面的開發和管理變得更加統一和靈活。"}],"subrouting":[{"t":"h1","c":"子路由模式"},{"t":"p","c":"在 ofa.js 中，設置子路由與一些前端框架的做法略有不同。ofa.js 使用一種更加直觀的方式，通過在頁面模塊上設置父頁面來作為容器，從而實現子路由的需求。"},{"t":"h2","c":"設置父頁面容器"},{"t":"p","c":"要創建子路由，首先需要在子頁面的頁面模塊上設置 parent 參數，指定父頁面的頁面模塊地址。這樣，在子頁面加載時，ofa.js 會自動將子頁面包裹在父頁面容器中。"},0,{"t":"p","c":"在上述示例中，子頁面的頁面模塊通過 parent 參數指定了父頁面容器的地址。"},{"t":"h2","c":"父頁面容器模板設置"},{"t":"p","c":"父頁面容器的模板需要設置一個 <slot> 元素，以便子頁面能夠插入到父頁面的指定位置。同時，確保 <slot> 元素的容器元素設置為 position: relative，這是非常重要的，因為子頁面會在父頁面容器中絕對定位。"},{"t":"p","c":"以下是一個父頁面容器的示例模板："},0,{"t":"p","c":"在上述示例中，通過設置一個帶有 slot 的容器元素，子頁面會被插入到該容器中。確保容器元素具有相對定位，這樣子頁面可以根據容器定位。"},{"t":"p","c":"通過使用這種方式，你可以更直觀地配置子路由，通過設置父頁面容器和子頁面的關聯，來實現子頁面的加載和渲染。"},{"t":"h2","c":"父頁面的路由監聽"},{"t":"p","c":"在某些情況下，多個頁面共用同一個父頁面作為容器，當這些頁面之間進行跳轉時，父頁面不會被刷新。這種情況下，父頁面仍然可以監聽路由的變動，以便在不刷新頁面的情況下執行相應的操作。"},{"t":"h3","c":"監聽路由變動"},{"t":"p","c":"父頁面模塊可以設置一個 routerChange 函數，用於監聽路由的變動。當頁面發生路由切換且不刷新父頁面時，將觸發 routerChange 事件。這個事件會傳遞當前頁面的信息，以及跳轉的方式（type）。"},{"t":"p","c":"以下是一個父頁面模塊的示例，展示了如何設置 routerChange 函數來監聽路由變動："},0,{"t":"p","c":"在上述示例中，routerChange 函數接收兩個參數，current 表示當前頁面的地址，type 表示跳轉的方式。當頁面發生路由切換時，該函數會被觸發，並輸出相應的信息。"}],"o-router":[{"t":"h1","c":"o-router 組件的使用"},{"t":"p","c":"o-router 組件是一個用於將 o-app 內的路由綁定到當前瀏覽器標簽頁的組件，它能夠幫助你更方便地管理頁面路由和展示。"},{"t":"h2","c":"加載 o-router 組件"},{"t":"p","c":"首先，你需要在頁面中引用 o-router 組件。你可以通過以下方式引用 router.mjs 文件："},0,{"t":"h2","c":"使用 o-router 組件"},{"t":"p","c":"使用 o-router 組件是通過將其包裹在 o-app 組件外部來實現的。這樣可以將應用內的路由綁定到當前瀏覽器標簽上。"},0,{"t":"h2","c":"fix-body 屬性"},{"t":"p","c":"o-router 組件還提供了 fix-body 屬性，當你設置了該屬性後，組件會自動為 <html> 標簽添加樣式，使應用的尺寸等於頁面的大小，從而讓應用的內容充滿整個窗口。"},0],"app":[{"t":"h1","c":"使用 o-app 組件"},{"t":"p","c":"使用 o-app 標簽可以輕松地創建一個完整的應用程序窗口。下面是如何制作一個應用並配置它的步驟："},{"t":"p","c":"文字顯得略顯枯燥，我們建議您前往 應用案例演示 進行實際嘗試；"},{"t":"h2","c":"基礎代碼"},{"t":"l","c":"1. 創建一個 HTML 文件，設置 o-app 標簽為應用的顯示窗口。確保為 o-app 設置全屏的樣式，以使應用占據整個視口。"},0,{"t":"l","c":"2. 創建一個 es 模塊，用於設置應用的配置數據。配置數據包括以下選項：\n\n   - home：字符串類型，應用的首頁的頁面模塊地址。\n   - loading：函數類型，應用在加載新頁面時，會運行這個函數，得到的內容會插入到應用中，作為加載時的提示，等到頁面加載完成後，會自動去除這個 loading 元素。\n   - fail：函數類型，應用加載頁面失敗時，會運行這個函數，返回得到的值會顯示在應用中作為加載失敗的提示。函數會帶有加載失敗頁面的 src 地址和錯誤報錯對象。\n   - pageAnime：頁面之間切換時的動畫配置。"},{"t":"p","c":"下面是應用的配置數據示例："},0,{"t":"l","c":"3. 在 HTML 文件中使用 o-app 標簽，並通過 src 屬性引用配置數據的 es 模塊。"},0,{"t":"p","c":"通過以上步驟，你已經成功制作了一個使用 o-app 組件的應用程序窗口。o-app 組件會根據配置數據中的設置加載頁面，展示加載中的提示或加載失敗的提示，並支持頁面切換動畫。這樣，你可以快速搭建一個功能完整且具有交互性的應用程序。"},{"t":"h2","c":"路由跳轉"},{"t":"p","c":"在 o-app 應用中，你可以輕松地實現路由跳轉，從一個頁面模塊跳轉到另一個頁面模塊。下面介紹幾種不同的方式來進行路由跳轉。"},{"t":"h3","c":"使用 <a> 標簽進行路由跳轉"},{"t":"p","c":"你可以在頁面的 HTML 中使用 <a> 標簽來實現路由跳轉。需要將 href 屬性指定為目標頁面模塊的路徑，並添加 olink 屬性，以告知 o-app 組件這是一個路由鏈接。"},0,{"t":"h3","c":"goto"},{"t":"p","c":"你可以在頁面模板中使用 on:click 屬性來綁定點擊事件，並調用模塊上的 goto 方法進行路由跳轉。"},0,{"t":"p","c":"又或者直接卸載目標元素上："},0,{"t":"h3","c":"替換跳轉和返回頁面"},{"t":"p","c":"除了 goto 方法外，o-app 還支持 replace 和 back 方法。"},{"t":"l","c":"- replace 方法用於替換跳轉，它會取代當前頁面的路由，使新頁面成為當前頁面的路由。"},0,{"t":"l","c":"- back 方法用於返回到前一個頁面。"},0,{"t":"p","c":"需要注意的是，應用內會保持組件的路由狀態，但路由數據不會綁定到當前瀏覽器標簽上。這樣，你可以方便地在應用中實現頁面之間的跳轉和導航。"},{"t":"p","c":"如果你想實現路由和頁面的綁定，可以使用 o-router 組件，我們將在後面的章節中詳細介紹。"},{"t":"p","c":"通過以上方法，你可以在 o-app 應用中實現靈活的路由跳轉，讓用戶能夠方便地瀏覽不同的頁面內容。"},{"t":"h2","c":"訪問應用和當前頁面"},{"t":"p","c":"在應用內的各個元素（包括組件），你通過 app 屬性來獲取它們所在的 o-app 實例。這對於需要與整個應用進行交互的操作非常有用。"},{"t":"p","c":"通過 app.current 屬性，你可以獲取當前激活的頁面模塊的地址。"},{"t":"p","c":"以下是一個使用示例："},0,{"t":"p","c":"在上面的示例中，通過選擇器 .app 獲取了應用標簽，然後通過訪問 app.current 屬性獲取了當前激活的頁面地址。"},{"t":"h2","c":"使用技巧：提前緩存下一頁"},{"t":"p","c":"在一些場景下，你可能已經預知用戶即將跳轉到下一頁。為了提高用戶體驗，你可以提前緩存下一頁的頁面模塊，這樣在實際跳轉時可以立即加載，減少用戶等待的時間，讓用戶體驗更加流暢。。"},{"t":"p","c":"在當前頁面的 JavaScript 代碼中，調用 load 方法並傳入下一頁的模塊路徑，該模塊將被加載並緩存。"},0],"scsr":[{"t":"h1","c":"靜態客戶端渲染(SCSR)"},{"t":"h2","c":"什麽是 SCSR？"},{"t":"p","c":"SCSR 全名 Static Client-Side Rendering，稱為靜態客戶端渲染；靜態客戶端渲染（SCSR）是 CSR（Client-Side Rendering）的一種變種，它在保留了 CSR 用戶體驗的基礎上，還能夠讓頁面在靜態狀態下被爬蟲獲取。"},{"t":"h2","c":"如何使用 SCSR"},{"t":"p","c":"你可以通過以下方式引用 SCSR 庫："},0,{"t":"h2","c":"SCSR 的工作原理"},{"t":"p","c":"SCSR 是通過直接運行單文件模式的頁面模塊，而無需使用 o-page 標簽，從而實現在頁面上進行渲染。具體來說，就是將頁面模塊的模板代碼直接放在 o-app 內。"},{"t":"p","c":"以下是一個 SCSR 示例，展示了如何在頁面上直接渲染頁面模塊的內容："},0,{"t":"p","c":"通過 SCSR，template 標簽內的內容會被直接渲染到頁面上，而這部分內容實際上就是單文件模式的頁面模塊。"},{"t":"p","c":"繼續以上面的 home.html 頁面為例，我們創建一個 help 頁面："},0,{"t":"p","c":"在 home.html 頁面中點擊 \"GO TO HELP\" 後，將平滑跳轉到 help.html 頁面，實現了客戶端渲染的平滑跳轉效果。"},{"t":"h2","c":"注意事項"},{"t":"p","c":"所有采用 SCSR 方案的頁面，除頁面描述性的內容（如 title、meta:description、keywords）和頁面模板內容外，其他引用資源必須保持一致，以確保在頁面跳轉和刷新後的體驗一致。"},{"t":"h2","c":"關於 SSR 方案"},{"t":"p","c":"當前的 SCSR 方案實際上更類似於一種 SSG（Static Site Generation）方案，因為它將頁面預先渲染成靜態內容，然後再通過客戶端進行交互。ofa.js 已經提供了相對獨立的組件封裝方案，使得前端開發人員可以將組件封裝好，然後結合傳統的後端渲染頁面方案（如 Node.js、Go、Java、PHP 等語言的網站渲染框架），後端開發人員可以快速使用這些封裝好的組件來構建優質的網頁。"},{"t":"p","c":"我們計劃在未來提供一個完整的 SSR（Server-Side Rendering）方案。這個方案的原理大致是先獲取下一頁的元素內容，然後與當前頁的標簽內容進行對比，從而進行動態的增加、刪除和修改屬性值等操作。不過需要注意的是，這個 SSR 方案會比較耗費時間，因為這個過程涉及到復雜的元素比較和修改操作。"},{"t":"p","c":"ofa.js 是一個新興的框架，而且作者的業余時間也有限，暫時還沒有完整開發出這個 SSR 方案。但如果未來 ofa.js 能夠得到更多的用戶使用，並且出現了對於 SSR 方案的強烈需求時，作者會繼續完善並開發這個方案。目前，作者會專注於框架的穩定性和功能擴展，同時也歡迎用戶的反饋和建議，以便未來更好地滿足用戶的需求。"}]},"others":{"data-sharing":[{"t":"h1","c":"數據共享"},{"t":"p","c":"ofa.js與其他第三方框架不同，不采用傳統的狀態管理模式。作者認為狀態更新應該是無感知的，即改變數據後應自動觸發數據更新。"},{"t":"p","c":"ofa.js天生就具備出色的數據共享能力，它的實例基於數據共享庫 Stanz 進行開發。實例上的對象都是可同步的。如果要實現數據共享，只需創建一個獨立的 Stanz 對象，然後讓所有組件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享數據："},0,0,0,0,{"t":"p","c":"在上述示例中，兩個組件在 attached 生命周期時，將數據寫入到組件本身。然後，組件的 obj 就成為共享數據。在 detached 生命周期後，將之前共享的數據設置為 null，以確保數據得到回收。"},{"t":"h2","c":"注意事項"},{"t":"p","c":"由於數據是共享的，務必要確保在適當的時候回收數據，以避免內存泄漏。"},0],"about-micro-frontend":[{"t":"h1","c":"關於微前端"},{"t":"p","c":"微前端是一種前端架構模式，旨在幫助團隊更好地構建和維護大型、復雜的前端應用程序。它借鑒了微服務架構的思想，將前端應用程序拆分為更小的獨立部分，每個部分都可以由不同的團隊開發、測試和部署。"},{"t":"p","c":"在傳統的單體前端應用不斷擴展的過程中，可能會變得難以維護和擴展。微前端的目標是通過將應用拆分成更小、更可管理的模塊，使得開發團隊能夠獨立地開發和部署這些模塊，從而提高團隊的效率和應用的可維護性。"},{"t":"p","c":"ofa.js 天生具備微前端的特性，它與其它框架的不同之處在於，基於 ofa.js 開發的組件、頁面和應用無需預編譯。相比於一些框架如 React、Vue 和 Angular 等，它們需要在 Node.js 環境下進行一次構建，生成用於客戶端的代碼。然而，ofa.js 的開發代碼可以直接放置在靜態服務器上，無需額外的構建步驟，就能實時查看、使用和運行。"},{"t":"p","c":"ofa.js 符合了微前端的特點："},{"t":"l","c":"1. 獨立部署：每個組件和頁面都可以獨立地開發、測試和部署，這使得團隊能夠更迅速地發布新功能和解決問題。\n\n2. 集成：基於 ofa.js 開發的應用，可以將不同的模塊組合在一起。這可以通過應用、頁面、組件等方式共享組合。\n\n3. 獨立團隊：每個前端模塊（組件/頁面/應用）可以由獨立的團隊進行開發和維護，從而鼓勵團隊的自主性和創新。\n\n4. 共享資源：在 ofa.js 項目中，通常會存在一些共享的資源，如樣式、組件、頁面等，以確保一致性和效率。\n\n5. 按需加載：ofa.js 的應用可以根據需要加載模塊，從而提升應用的性能和加載速度。"},{"t":"p","c":"盡管 ofa.js 無法直接使用 Vue 和 React 等框架開發的組件，但基於 ofa.js 開發的組件可以被 Vue 和 React 使用，這為不同技術棧的開發人員提供了更強的靈活性和擴展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 將 Vue 與 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 與 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 將 Web Components 集成到 React 中"}],"coexist-with-jquery":[{"t":"h1","c":"和 jQuery 共存"},{"t":"p","c":"在使用 ofa.js(≥4.3.40) 的同時，你可以與 jQuery 共存。你有兩種主要的選擇："},{"t":"h2","c":"1. 使用 noConflict"},{"t":"p","c":"你可以在引入 jQuery 後調用 noConflict 方法，這樣就會釋放 $ 變量，避免沖突。"},0,{"t":"h2","c":"2. 按順序引入庫"},{"t":"p","c":"另一種方法是按順序引入庫，後引入的庫將占用 $ 變量。這種情況下，你可以使用全局變量 ofa 代替原本的 $。"},0,{"t":"p","c":"使用這兩種方法之一，你可以確保 ofa.js 和 jQuery 在同一頁面上共存而不會發生沖突。"}]}},"api":{"index":[{"t":"h1","c":"API 介紹"},{"t":"p","c":"以下是 ofa.js API 的概覽，你可以先瀏覽一遍，以備將來需要時再來查閱詳細文檔："},{"t":"h2","c":"實例相關"},{"t":"l","c":"- $：主要用於獲取實例的方法\n- all：獲取所有相關實例\n- prev：獲取目標元素的前一個實例\n- prevs：獲取目標元素前面的所有實例\n- next：獲取目標元素的後一個實例\n- nexts：獲取目標元素後面的所有實例\n- siblings：獲取目標元素的所有相鄰元素實例\n- parent：獲取父元素實例\n- parents：獲取所有父元素的實例集\n- clone：克隆實例的方法\n- ele：獲取實例的實際原生元素\n- shadow：獲取自定義組件的影子根節點\n- root：獲取目標實例的根節點\n- 子元素：通過數字直接獲取子元素\n- host：獲取目標的 app 元素實例"},{"t":"h2","c":"節點操作"},{"t":"l","c":"- 添加或刪除子節點\n- before：在目標實例的前面添加元素\n- after：在目標實例的後面添加元素\n- remove：刪除目標元素\n- wrap：將目標元素上包裹一層元素\n- unwrap：將目標元素去除包裹的元素"},{"t":"h2","c":"屬性操作"},{"t":"l","c":"- text：獲取或設置目標元素的文本\n- html：獲取或設置目標元素的 HTML 代碼\n- attr：獲取或設置目標元素的 attributes\n- css：獲取或設置目標元素的樣式\n- style：獲取目標元素的原生樣式\n- classList：獲取目標元素的原生 class 列表\n- data：獲取目標元素的原生數據集"},{"t":"h2","c":"事件相關"},{"t":"l","c":"- on：綁定事件到目標元素\n- one：一次性綁定事件到目標元素\n- emit：主動觸發事件\n- off：解除綁定的事件"},{"t":"h2","c":"模板語法"},{"t":"l","c":"- 文本渲染：快速在模板文件上渲染文本\n- class：快速在模板文件上渲染類名\n- sync：快速同步數據到模板文件\n- 條件渲染：按需在模板文件上渲染內容\n- 列表渲染：在模板文件上快速渲染數組數據"},{"t":"h2","c":"生命周期"},{"t":"l","c":"- created：組件被創建，但未渲染內容時觸發\n- ready：組件被創建，內容被渲染後觸發\n- watch：組件初始化完成後和值被改變後觸發\n- loaded：組件內嵌資源被加載完成後觸發\n- attached：組件被添加到 document 後觸發\n- detached： 組件從 document 被移除後觸發\n- routerChange：內嵌的父頁面在應用路由改變時觸發"},{"t":"h2","c":"其他"},{"t":"l","c":"- 盒模型：獲取目標元素的所有尺寸相關的數據\n- formData：方便地綁定和獲取表單數據\n- tag：獲取目標的標簽名\n- index：獲取目標元素在其父元素下的排序\n- is：判斷目標元素是否匹配 CSS 選擇器表達式\n- refresh：主動刷新組件的界面\n- PATH：獲取組件或頁面的注冊文件地址\n- extend：擴展實例的數據或方法；擴展 ofa.js 底層的數據或方法；\n- version：獲取當前引入的 ofa.js 的版本號\n- 實例數據特征：介紹實例數據的子對象數據特性，如何監聽數據的變動"}],"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"$ 方法 是 ofa.js 中的核心函數，用於操作 DOM 元素實例。下面將介紹 $ 的主要作用："},{"t":"h2","c":"獲取元素實例"},{"t":"p","c":"通過 $ 方法，你可以獲取頁面上符合css選擇器的第一個元素實例，並對其進行操作。以下是一個示例："},0,0,0,0,{"t":"p","c":"在上面的示例中，我們使用 $ 符號選擇了具有 id 為 \"target1\" 的元素實例，並通過設置 text 屬性來修改其文本內容。"},{"t":"h2","c":"查找子元素實例"},{"t":"p","c":"實例也擁有 $ 方法，可以通過實例上的 $ 方法獲取元素實例的第一個符合條件的子元素實例。"},0,0,0,0,{"t":"h2","c":"元素實例特性"},{"t":"p","c":"請不要將獲取的元素實例直接插入到其他地方，這樣的操作會導致原來的元素受到影響。如果需要創建一份副本，您可以使用 clone 方法。"},0,0,0,0,{"t":"h2","c":"獲取影子節點內的子元素"},{"t":"p","c":"可以通過 shadow 屬性獲取實例後，在通過 $ 方法獲取想要的元素；"},0,{"t":"h2","c":"直接實例化元素"},{"t":"p","c":"你可以通過以下方式直接將原生元素初始化為 $ 實例對象："},0,0,{"t":"p","c":"這樣，你可以方便地將現有的 HTML 元素轉換為 $ 實例，以便使用 $ 提供的功能進行操作和處理。"},{"t":"h2","c":"生成元素實例"},{"t":"p","c":"除了獲取現有的元素實例，$ 還可以用於創建新的元素實例，並將其添加到頁面中。"},{"t":"h3","c":"通過字符串生成"},{"t":"p","c":"你可以使用 $ 函數通過字符串創建新元素實例，如下所示："},0,0,0,0,{"t":"p","c":"在這個示例中，我們使用 $ 函數創建了一個具有指定樣式和文本內容的新元素實例，並將其添加到具有 id 為 \"target1\" 的現有元素實例內。"},{"t":"h3","c":"通過對象生成"},{"t":"p","c":"你還可以使用 $ 函數通過對象的方式生成新元素實例，如下所示："},0,0,0,0,{"t":"p","c":"在這個示例中，我們使用 $ 函數通過對象的方式定義了一個新元素實例，包括標簽類型、文本內容和樣式屬性，並將其添加到具有 id 為 \"target1\" 的現有元素實例內。"}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"使用 all 方法，你可以獲取頁面上符合 CSS 選擇器 的所有元素，並返回一個數組包含這些元素。"},0,0,0,0,{"t":"h2","c":"獲取子元素"},{"t":"p","c":"實例也擁有 all 方法，可以通過實例上的 all 方法選擇並獲取子元素。"},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"使用 prev 屬性，你可以獲取元素的前一個相鄰元素實例。"},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"使用 prevs 屬性，您能夠輕松獲取當前元素之前的所有相鄰元素實例，這些元素將以數組的形式返回。"},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"使用 next 屬性，你可以獲取元素的後一個相鄰元素實例。"},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"使用 nexts 屬性，您能夠輕松獲取當前元素後面的所有相鄰元素實例，這些元素將以數組的形式返回。"},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"使用 siblings 屬性，您能夠輕松獲取當前元素的所有相鄰元素實例，這些元素將以數組的形式返回。"},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"使用 parent 屬性，您可以獲得實例的父元素實例；"},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"使用 parents 屬性，您能夠輕松獲取當前元素的所有父元素實例，這些元素將以數組的形式返回。"},0,0,0,0],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"使用 clone 方法可以克隆並生成一份元素實例；"},0,0,0,0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"通過 ele 屬性，你可以獲取實例的實際元素，從而使用原生的屬性或方法。"},0,0,0,0,{"t":"p","c":"在上面的示例中，我們使用 ele 屬性獲取了一個元素，並修改了其內部的 HTML 內容，以及用於記錄的元素的 tagName。這使得你可以結合原生 JavaScript 方法對元素進行更復雜的操作。"}],"root":[{"t":"h1","c":"root"},{"t":"p","c":"使用 root 屬性獲取元素的根節點；"},{"t":"p","c":"在頁面上，普通元素的根節點都是 document 實例；"},0,0,0,0,{"t":"h2","c":"在影子節點內的元素"},{"t":"p","c":"由於組件內元素，是與外部環境隔離的，影子節點內的元素的 root 屬性就是影子根節點；"},0,0,0],"children":[{"t":"h1","c":"子元素"},{"t":"p","c":"獲取子元素實例非常簡單，你只需要將實例當作數組，通過數字獲取它的子元素實例。"},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"獲取目標元素的子元素數量；案例如上所示；"},0],"host":[{"t":"h1","c":"host"},{"t":"p","c":"使用 host 屬性，可以獲取元素的宿主組件實例。這對於在組件內部訪問其宿主組件的數據和方法非常有用。"},{"t":"p","c":"下面是一個示例，演示如何使用 host 屬性獲取宿主組件的實例："},0,0,0,{"t":"p","c":"在這個示例中，我們創建了一個自定義組件 host-demo，並在組件內部訪問了它的宿主組件實例，然後比較了它們是否相等。"},{"t":"p","c":"如果元素不在組件內，host 的值將為 null。例如："},0,0,0,0,{"t":"p","c":"在這個示例中，#target 元素在 body下，不在任何組件或頁面內，所以 $(\"#target\").host 的值為 null。"}],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"使用 shadow 屬性，你可以獲取元素的影子根節點實例。"},0,0,0,{"t":"p","c":"需要注意的是，避免在具有模板語法的元素內直接修改影子節點內的元素，以確保操作的一致性和可維護性。"},{"t":"h2","c":"從外部獲取組件影子元素內的元素實例"},{"t":"p","c":"您還可以從外部獲取自定義元素實例，然後通過 shadow 屬性訪問影子節點內的元素，如下所示："},0],"app":[{"t":"h1","c":"app"},{"t":"p","c":"在 o-app 內的元素，包括在 o-app 內的 o-page 的影子節點內的元素，或者再內部的子組件，它們的 app 屬性都是指向這個 o-app 的元素實例。"},{"t":"p","c":"以下是一個示例，演示了如何在 o-app 內的元素中訪問 app 屬性："},0,{"t":"p","c":"代碼如下："},0,0,0,{"t":"p","c":"在上述示例中，o-app 元素的 app 屬性包含了 o-page 元素和 test-comp 自定義組件內的元素。這意味著它們都可以通過 app 屬性訪問到 o-app 元素的數據和方法。"}]},"operation":{"array-like":[{"t":"h1","c":"添加或刪除子元素"},{"t":"p","c":"元素實例擁有類似數組的特性，添加或刪除節點只需要使用數組那幾個操作方法即可；其中使用 push、unshift、pop、shift、splice 方法時，內部會自動執行 $ 方法 的初始化操作，所以可以直接填寫具體的元素字符串或對象。"},{"t":"p","c":"同樣的，您也可以使用其他數組方法，例如 forEach、map、some 等等。"},{"t":"p","c":"請注意，在具有模板語法的元素上不要添加或刪除子元素。"},{"t":"h2","c":"push"},{"t":"p","c":"從末尾添加子元素。"},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"在數組的開頭添加子元素。下面是一個示例："},0,0,0,0,{"t":"h2","c":"pop"},{"t":"p","c":"從末尾刪除子元素。"},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"在數組的開頭刪除子元素。"},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"可以刪除或替換現有子元素，也可以添加新子元素。其使用方式與數組的 splice 方法相似。下面是一個示例："},0,0,0,0],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"刪除目標節點；"},{"t":"p","c":"請注意，在具有模板語法的元素上不要操作元素。"},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"before 方法用於向目標元素的前面添加元素。在執行 before 操作之前，會自動執行 $ 方法 的初始化操作，因此可以直接填寫具體的元素字符串或對象。"},{"t":"p","c":"請注意，在具有模板語法的元素上不要操作元素。"},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"after 方法用於向目標元素的後面添加元素。在執行 after 操作之前，會自動執行 $ 方法 的初始化操作，因此可以直接填寫具體的元素字符串或對象。"},{"t":"p","c":"請注意，在具有模板語法的元素上不要操作元素。"},0,0,0,0],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"wrap 方法用於在目標元素的外部包裹一層元素。在執行 wrap 操作之前，會自動執行 $ 方法 的初始化操作，因此可以直接填寫具體的元素字符串或對象。"},{"t":"p","c":"下面是一個示例："},0,0,0,0,{"t":"h2","c":"注意事項"},{"t":"p","c":"目標元素必須擁有父節點，否則包裹操作會失敗。"},0,{"t":"p","c":"請注意，在具有模板語法的元素上不要操作元素。"}],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"unwrap 方法用於在目標元素的移除一層外部包裹的元素。"},{"t":"p","c":"下面是一個示例："},0,0,0,0,{"t":"h2","c":"注意事項"},{"t":"p","c":"目標元素必須擁有父節點，否則包裹操作會失敗。"},0,{"t":"p","c":"當擁有其他兄弟元素時，也不可以執行 unwrap；"},0,{"t":"p","c":"請注意，在具有模板語法的元素上不要操作元素。"}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"text 方法用於獲取或設置元素的文本內容。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接獲取或設置元素的文本內容。下面是一個示例："},0,0,0,0,{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以在模板內使用 :text 屬性來向目標元素設置對應的屬性值。這在組件的渲染中特別有用。下面是一個示例："},0,0,0],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"attr 方法用於獲取或設置元素的 attributes。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接使用 attr 方法獲取或設置元素的屬性。下面是一個示例："},0,0,0,0,{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以在模板內使用 attr:aaa=\"bbb\" 方式，將目標元素的 aaa 屬性設置為組件 bbb 的值。這種方法對於組件渲染特別有用。下面是一個示例："},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"css 方法用於獲取或設置目標元素的樣式。"},{"t":"h2","c":"直接使用"},{"t":"p","c":"你可以直接使用 css 方法來獲取或設置元素的樣式。下面是一個示例："},0,0,0,0,{"t":"h2","c":"全量設置"},{"t":"p","c":"通過獲取的 css 對象，你可以得到直接設置在元素上的 style 值。下面是一個示例："},0,0,0,0,{"t":"p","c":"使用 css 對象的特性，你可以快速地調整目標元素的樣式。"},{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以通過模板語法來設置目標元素的樣式。下面是一個示例："},0,0,0,{"t":"h2","c":"設置 css 的技巧"},{"t":"p","c":"你可以通過 $ele.css = {...$ele.css, color:'red'} 的方式來修改元素的某個樣式屬性，而不影響其他樣式屬性。這種方式可以在不重寫整個樣式的情況下，只修改其中一個屬性。"},{"t":"h3","c":"示例"},0,{"t":"p","c":"在上面的示例中，通過使用 { ...myElement.css, color: 'red' }，我們只修改了元素的顏色樣式，而將其他樣式屬性保持不變。這是一個很方便的技巧，可以靈活地修改元素的樣式。"}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"classList 屬性和原生保持一致；"},{"t":"p","c":"下面是一個示例，演示了如何使用 classList："},0,0,0,0,{"t":"p","c":"classList 屬性允許你輕松地添加、刪除和切換類名，以便動態更改元素的樣式。有關更多操作方法，請查閱 classList。"}],"style":[{"t":"h1","c":"style"},{"t":"p","c":"使用 style 屬性和原生保持一致；"},{"t":"p","c":"請注意，style 屬性無法獲取樣式的實際值，而只能獲取在 style 屬性上設置的值。盡管 style 方法與 css 方法 類似，但它無法進行全量樣式覆蓋。相較於 css，style 方法的內部執行效率更高。"},{"t":"p","c":"下面是一個示例，演示了如何使用 style："},0,0,0,0,{"t":"p","c":"請記住，style 方法只獲取和設置 style 屬性上的值，而不是實際的計算樣式。"}],"html":[{"t":"h1","c":"html"},{"t":"p","c":"設置目標內部的 html 代碼；"},0,0,0,0,{"t":"h2","c":"注意事項"},{"t":"p","c":"html 是個比較危險的方法，被塞入 script 也會自動執行內部的 javascript 代碼，使用時注意預防 XSS；"},{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以在模板內使用 :html 屬性來向目標元素設置對應的屬性值。這在組件的渲染中特別有用。下面是一個示例："},0,0,0],"data":[{"t":"h1","c":"data"},{"t":"p","c":"獲取元素的 dataset，使用 data 屬性和原生 dataset 保持一致；"},0,0,0,0]},"event":{"on":[{"t":"h1","c":"on"},{"t":"p","c":"使用 on 方法，你可以為目標元素注冊事件處理程序。這使你能夠輕松地捕獲和響應用戶的交互操作。"},{"t":"p","c":"下面是一個示例，演示如何使用 on 方法為按鈕元素注冊點擊事件處理程序："},0,0,0,0,{"t":"p","c":"在這個示例中，我們使用 on 方法為按鈕元素添加了一個點擊事件處理程序。當用戶點擊按鈕時，會觸發事件處理程序，計數器將遞增並將結果顯示在頁面上。"},{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以使用模板語法來為目標元素綁定方法。下面是一個示例："},0,0,0,{"t":"p","c":"在這個示例中，我們在按鈕元素上使用 on:click 綁定了一個名為 addCount 的方法。當用戶點擊按鈕時，這個方法將被調用，計數器的值將遞增並在頁面上顯示。這種方式使你可以將事件處理程序與組件的方法關聯，實現更復雜的交互。"},{"t":"h2","c":"event"},{"t":"p","c":"在注冊時間後，觸發的函數會被帶上 event，和原生保持一致；"},0,0,0,0],"one":[{"t":"h1","c":"one"},{"t":"p","c":"使用 one 方法，你可以為目標元素注冊一次性事件處理程序，這意味著事件處理程序將在第一次觸發後自動解除綁定，不會再次觸發。"},{"t":"p","c":"下面是一個示例，演示如何使用 one 方法為按鈕元素注冊點擊事件處理程序："},0,0,0,0,{"t":"p","c":"在這個示例中，我們使用 one 方法為按鈕元素添加了一個點擊事件處理程序。當用戶點擊按鈕時，事件處理程序會觸發，但之後不會再次觸發，因為它已被解除綁定。"},{"t":"h2","c":"模板語法方式使用"},{"t":"p","c":"你還可以使用模板語法來為目標元素綁定一次性事件處理程序。下面是一個示例："},0,0,0,{"t":"p","c":"在這個示例中，我們在按鈕元素上使用 one:click 綁定了一個名為 addCount 的方法。當用戶點擊按鈕時，這個方法將被調用，但之後不會再次觸發，因為它是一次性事件處理程序。"}],"off":[{"t":"h1","c":"off"},{"t":"p","c":"使用 off 方法可以注銷已注冊的事件處理程序，以取消對事件的監聽。"},{"t":"p","c":"下面是一個示例，演示如何使用 off 方法取消事件監聽："},0,0,0,0,{"t":"p","c":"在這個示例中，我們注冊了一個點擊事件處理程序 f，當按鈕被點擊時，事件處理程序會在 #logger 中顯示點擊次數。使用 off 方法，我們在點擊次數達到3時取消了事件的監聽。"}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"使用 emit 方法，你可以主動觸發事件，而且觸發的事件具有冒泡機制。冒泡機制意味著事件從內部元素冒泡到外部元素，從內到外的層級觸發事件。"},{"t":"p","c":"下面是一個示例，演示如何使用 emit 方法觸發自定義事件並利用冒泡機制傳遞事件到外部元素："},0,0,0,0,{"t":"p","c":"在這個示例中，我們為 <ul> 元素和 <li> 元素分別注冊了相同的自定義事件 custom-event 處理程序。當我們使用 emit 方法觸發事件時，該事件從 <li> 元素冒泡到 <ul> 元素，觸發了兩個事件處理程序。"},{"t":"h2","c":"自定義數據"},{"t":"p","c":"通過帶上 data 參數，你可以傳遞自定義數據給事件處理程序："},0,0,0,0,{"t":"p","c":"在這個示例中，我們通過 data 參數傳遞了自定義數據給事件處理程序。事件處理程序可以通過 event.data 獲取傳遞的數據。"},{"t":"h2","c":"不冒泡觸發事件"},{"t":"p","c":"如果你不希望事件冒泡，你可以在觸發事件時帶上 bubbles: false 參數："},0,0,0,0,{"t":"p","c":"在這個示例中，我們使用 bubbles: false 參數觸發了自定義事件。這個事件不會冒泡到上層元素，所以只有 <li> 元素的事件處理程序被觸發。"},{"t":"h2","c":"穿透根節點"},{"t":"p","c":"默認情況下，事件不會穿透自定義組件的影子 DOM。但你可以通過設置 composed: true 讓自定義事件穿透根節點，觸發根節點之外的元素。"},0,0,0,0,0,{"t":"p","c":"在這個示例中，我們創建了一個自定義組件 composed-test，它包含一個影子 DOM 中的元素和一個觸發事件的按鈕。默認情況下，事件不會穿透影子 DOM 到根節點。但是，通過在事件觸發時使用 composed: true 參數，我們讓事件穿透到了根節點，觸發了根節點外的元素。"}]},"temp-syntax":{"text-render":[{"t":"h1","c":"文本渲染"},{"t":"p","c":"你可以使用兩個包裹的大括號的形式 {{xxx}} 在模板內渲染文本，其中 xxx 是組件或頁面自身的屬性。這允許你將屬性的值直接渲染到頁面上。"},{"t":"p","c":"以下是一個示例，演示了如何在模板中渲染文本："},0,0,0,{"t":"p","c":"在這個示例中，{{txt}} 將會被屬性 txt 的值替代，最終呈現在頁面上。"}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"你可以通過 class 語法快速切換模板內的 class 名。在 class:aaa=\"bbb\" 中，當 bbb 表達式(或組件自身的 bbb 屬性)為 true 時，會為目標元素添加 aaa 這個 className。"},{"t":"p","c":"請注意，className 不能包含大寫字母，請使用 - 作為分隔符。"},{"t":"p","c":"以下是一個示例，演示了如何使用 class 語法在模板中切換元素的 class 名："},0,0,0,{"t":"h2","c":"直接使用 class"},{"t":"p","c":"你可以使用 class 方法來直接調整元素的 className。在下面的示例中，演示了如何使用 class 方法來動態添加和刪除類名："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先通過 class 方法將 color-red 類添加到元素上，然後在一秒後將其移除，再過半秒後將 color-blue 類添加到元素上。這會動態更改目標元素的樣式。"},{"t":"p","c":"我們建議使用 classList 屬性來操作類名，因為這是更常見和標準的方法。"}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"通過 sync 語法對組件進行雙向數據綁定"},0,0,0,{"t":"p","c":"sync 還可以和內嵌的組件實例屬性進行綁定，案例請查看雙向數據綁定；"}],"condition":[{"t":"h1","c":"條件渲染"},{"t":"p","c":"條件渲染是通過三個條件組件來實現的："},{"t":"h2","c":"x-if"},{"t":"p","c":"x-if 是主要的判斷組件，需要設置 value 值。如果 value 的條件滿足，它會顯示包裹的內容。"},{"t":"h2","c":"x-if-else"},{"t":"p","c":"x-if-else 可以跟在 x-if 或 x-if-else 後面，需要設置 value 值。如果前面的條件組件不滿足，且自身的 value 為 true，它會顯示包裹的內容。"},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else 可以跟在 x-if 或 x-if-else 後面，放在最後。如果前面的條件都不滿足，它會顯示自身包裹的內容。不需要設置 value 值。"},{"t":"h2","c":"示例"},0,0,0,{"t":"p","c":"在示例中，使用了這些條件渲染組件來根據 count 的值選擇要顯示的內容。當 count 能被 3 整除時，x-if 條件滿足，顯示紅色的文本；當 (count + 1) 能被 3 整除時，x-if-else 條件滿足，顯示綠色的文本；否則，顯示藍色的文本。"}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"使用 x-fill 組件來進行列表渲染；設置 value 屬性來填充數組數據。"},{"t":"p","c":"在 x-fill 內部，可以使用特殊變量 $index 代表當前列表項的索引，以及 $data 代表列表項本身的數據。"},{"t":"p","c":"下面是一個示例，演示了如何使用 x-fill 渲染一個數組："},0,0,0,{"t":"p","c":"在這個示例中，我們將 x-fill 組件用於渲染數組 arr，並在每個列表項中顯示索引和數據。"},{"t":"h2","c":"模板列表渲染"},{"t":"p","c":"你可以使用模板元素template並添加 name 屬性，來定制組件內的臨時模板。在 x-fill 使用時，使用 name 屬性指定要填充的模板名。"},{"t":"p","c":"下面是一個示例，演示了如何使用模板列表渲染："},0,0,0,{"t":"p","c":"在這個示例中，我們創建了一個名為 \"easyLi\" 的模板，然後使用 x-fill 填充了數組 arr 的數據，並在每個列表項中顯示索引和數據的名稱。"},{"t":"h2","c":"嵌套列表渲染"},{"t":"p","c":"在進行嵌套列表渲染時，從第二層開始，必須使用模板來填充。這樣的設計是為了避免多層嵌套的列表渲染代碼變得復雜。"},{"t":"p","c":"下面是一個示例，演示了如何進行嵌套列表渲染："},0,0,0,{"t":"p","c":"在這個示例中，我們有一個數組 arr，其中包含了兩個對象。每個對象都有一個 name 屬性，以及一個可能包含嵌套子項的 childs 屬性。我們使用 x-fill 來填充列表，並使用模板 \"easyLi\" 渲染子項。如果某項具有子項，我們使用 x-if 來檢查並創建嵌套的列表。"},{"t":"h2","c":"遞歸列表渲染"},{"t":"p","c":"模板渲染還可以進行遞歸渲染，這對於構建樹形結構的列表非常有用。"},{"t":"p","c":"下面是一個演示如何進行遞歸列表渲染的示例："},0,0,0,{"t":"p","c":"在這個示例中，我們有一個數組 arr，其中包含了兩個對象。每個對象都有一個 name 屬性，以及一個可能包含嵌套子項的 childs 屬性。我們使用 x-fill 來填充列表，並使用模板 \"easyLi\" 渲染子項。如果某項具有子項，我們使用 x-fill 來遞歸渲染子列表，實現了遞歸列表渲染。"},{"t":"h2","c":"replace-temp"},{"t":"p","c":"有時候，當我們嘗試列表渲染到 select 或 table 內，瀏覽器可能會自動移除 <x-fill> 元素，導致無法正常進行列表渲染。在這種情況下，可以使用 replace-temp 的方式進行渲染。使用 replace-temp 的方法是，在一個 <template> 標簽中設置 is=\"replace-temp\"，並將這個模板放在瀏覽器會自動修正的元素內。"},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created 生命周期鉤子在組件創建時被觸發。在此階段，組件的數據尚未被初始化，模板內容也未被渲染。你可以在這個階段執行一些初始化操作，或者準備在後續階段使用的數據。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"ready 生命周期鉤子會在組件的數據和模板剛被初始化後觸發，表示組件已經準備就緒。在這個階段，你可以訪問組件的數據，並且模板已經渲染完成，可以執行一些與界面交互相關的操作。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"一旦 ready 階段完成，與之關聯的 watch 對象中的監聽函數會被觸發一次。隨後，當數據的某個值發生變動時，會再次觸發相應鍵（key）的監聽函數。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"loaded 生命周期鉤子在組件模板內的所有依賴都加載完成後觸發。這個階段確保在渲染組件之前，所有的依賴都已經加載完畢。這個時候適合去除在 ready 階段添加的Loading樣式。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"attached 生命周期鉤子會在組件被添加到文檔中時觸發。在這個階段，適合獲取組件內元素的尺寸相關信息，進行數據綁定和全局事件的操作。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0],"router-change":[{"t":"h1","c":"routerChange 事件"},{"t":"p","c":"routerChange 事件是一個特定於 o-page 元素的事件，它只會在 o-page 的嵌套父頁面上觸發。此事件在應用路由發生變化時被觸發，無論是跳轉到新頁面還是返回到先前的頁面。"},{"t":"p","c":"它提供了一種方式來監聽和響應應用程序的路由變化，通常在嵌套頁面的父頁面中使用。當路由發生變化時，可以監聽 routerChange 事件以執行相應的操作，例如更新頁面內容或導航狀態。"},{"t":"p","c":"這個事件對於構建具有多個嵌套頁面的應用程序非常有用，它使得在頁面之間導航和通信變得更加容易。"},{"t":"h2","c":"示例"},{"t":"p","c":"跳轉到嵌套頁面查看；"}],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"detached 生命周期鉤子會在組件從文檔中移除時觸發。在這個階段，你可以執行一些清理操作，比如取消事件監聽或者釋放資源，以防止內存泄漏。"},{"t":"h2","c":"示例代碼"},0,0,0,0,0,{"t":"h2","c":"生命周期流程圖"},0]},"others":{"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app 是 ofa.js 中的核心組件之一，用於配置和管理整個應用程序。以下是app的一些關鍵屬性和方法："},{"t":"h2","c":"src"},{"t":"p","c":"src 屬性用於指定應用參數配置模塊的具體地址。有關詳細示例，請參考 案例。"},0,{"t":"h2","c":"current"},{"t":"p","c":"current 屬性用於獲取正在展示中的頁面實例。這可以幫助您訪問和操作當前正在顯示的頁面，例如更新其內容或執行特定的操作。"},0,{"t":"h2","c":"goto"},{"t":"p","c":"goto 方法用於跳轉到指定的頁面。您可以傳遞目標頁面的地址，應用將加載並顯示該頁面。這是應用導航的重要方法。"},0,{"t":"h2","c":"replace"},{"t":"p","c":"replace 方法與 goto 類似，但它是用來替換當前頁面而不是在堆棧中添加新頁面。這可以用於實現頁面替換而不是堆棧導航。"},0,{"t":"h2","c":"back"},{"t":"p","c":"back 方法用於返回上一頁，實現頁面導航的後退操作。這會將用戶導航回上一個頁面。"},0,{"t":"h2","c":"routers"},{"t":"p","c":"routers 屬性包含應用程序的路由配置信息。這是一個重要的屬性，定義了應用程序中各個頁面的路由規則和映射。路由配置決定了頁面之間的導航和如何處理 URL。"},0],"page":[{"t":"h1","c":"o-page 組件"},{"t":"p","c":"o-page 是 ofa.js 中的核心組件之一，代表著一個獨立的頁面或頁面模塊。以下是 o-page 的一些關鍵屬性和方法："},{"t":"h2","c":"src 屬性"},{"t":"p","c":"src 屬性用於指定頁面模塊的具體地址。這是指定頁面內容和行為的關鍵屬性，告訴應用程序從哪裏加載特定頁面的內容。"},0,{"t":"h2","c":"goto 方法"},{"t":"p","c":"goto 方法用於從當前頁面跳轉到另一個頁面。相比較於 app 的 goto 方法，page 的 goto 方法可以使用相對地址來導航到其他頁面。"},0,{"t":"h2","c":"replace 方法"},{"t":"p","c":"replace 方法用於替換當前頁面為另一個頁面。這與 app 的 replace 方法類似，但是在頁面內進行替換操作。"},0,{"t":"h2","c":"back 方法"},{"t":"p","c":"back 方法用於返回到前一個頁面。這會導航用戶回到上一個頁面，類似於瀏覽器的後退操作。"},0],"box":[{"t":"h1","c":"盒模型"},{"t":"p","c":"在網頁開發中，元素的尺寸是一個重要的概念，它包括了內容區域、內邊距、邊框和外邊距。以下是一些表示元素尺寸的相關屬性："},{"t":"h2","c":"width"},{"t":"p","c":"width 表示元素的內容區域的寬度，它不包括內邊距、邊框和外邊距。"},{"t":"h2","c":"height"},{"t":"p","c":"height 表示元素的內容區域的高度，它不包括內邊距、邊框和外邊距。"},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidth 表示元素的可見內容區域的寬度，包括內邊距，但不包括邊框和外邊距。"},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeight 表示元素的可見內容區域的高度，包括內邊距，但不包括邊框和外邊距。"},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"offsetWidth 表示元素的整體寬度，包括內容區域、內邊距、邊框和外邊距。"},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"offsetHeight 表示元素的整體高度，包括內容區域、內邊距、邊框和外邊距。"},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidth 表示元素的整體寬度，包括內容區"},0,0,0,0],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"tag 屬性用於獲取元素的標簽，返回一個小寫字符串。"},{"t":"p","c":"在下面的示例中，我們演示了如何使用 tag 方法來獲取一個元素的標簽："},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"formData 方法用於生成與表單元素綁定的對象數據，使得處理表單元素更加簡單和高效。這個方法會生成一個對象，包含目標元素內所有表單元素的值，該對象會實時反映表單元素的改動。"},{"t":"p","c":"在下面的示例中，我們演示了如何使用 formData 方法生成與表單元素綁定的對象數據："},0,0,0,0,{"t":"p","c":"在這個示例中，我們創建了一個包含文本輸入框、單選按鈕和文本區域的表單，並使用 formData 方法創建了一個對象 data，該對象包含了這些表單元素的值。我們還使用 watch 方法來監視數據的變化，以及將數據實時顯示在頁面上。當用戶修改表單元素的值時，data 對象會相應地更新，使得數據處理變得非常簡單和高效。"},{"t":"h2","c":"反向數據綁定"},{"t":"p","c":"生成的對象數據同樣具有反向的綁定能力，這意味著當你修改對象的屬性時，相關的表單元素值也會自動更新。這在處理表單數據時非常有用，因為你可以輕松地實現雙向數據綁定。"},{"t":"p","c":"在下面的示例中，我們演示了如何使用 formData 方法生成的對象數據，以及如何進行反向數據綁定："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先創建了一個包含文本輸入框、單選按鈕和文本區域的表單，然後使用 formData 方法生成了一個數據對象 data。隨後，通過修改 data 對象的屬性，我們實現了反向數據綁定，即表單元素的值會隨著對象屬性的更改而自動更新。這種雙向數據綁定功能使得與表單數據的交互更加便捷。"},{"t":"h2","c":"監聽特定的表單"},{"t":"p","c":"默認情況下，formData() 方法會監聽目標元素內的所有 input、select 和 textarea 元素。但如果你只想監聽特定的表單元素，可以通過傳遞 CSS 選擇器 來實現。"},{"t":"p","c":"在下面的示例中，我們演示了如何通過傳遞 CSS 選擇器來監聽特定的表單元素："},0,0,0,0,{"t":"p","c":"在此示例中，我們只希望監聽具有 class 為 \"use-it\" 的表單元素，因此我們傳遞了 \".use-it\" 作為參數給 formData() 方法。這樣，只有帶有該類名的表單元素會被監聽和包括在生成的數據對象中。這對於選擇性地監聽表單元素非常有用，以便更精確地管理你的表單數據。"},{"t":"h2","c":"自定義表單"},{"t":"p","c":"自定義表單組件的使用非常簡單，只需要為自定義組件添加一個 value 屬性 並設置 name 特性。"},{"t":"p","c":"在下面的示例中，我們創建了一個名為 \"custom-input\" 的自定義表單組件。這個組件是一個可編輯的文本框，當文本發生變化時，它會實時更新其 value 屬性。"},0,0,0,0,{"t":"p","c":"在你使用自定義表單組件時，你只需將它添加到你的表單中，並設置所需的 name 屬性："},0,{"t":"p","c":"在上述示例中，我們通過添加 <custom-input> 元素並設置 name 屬性來使用自定義表單組件。隨後，我們使用 formData() 方法監聽輸入元素和自定義組件的值，以便實時獲取和處理表單數據。這種方法可以讓你非常方便地擴展你的表單，以包括自定義的表單組件，從而滿足你的特定需求。"},{"t":"h2","c":"在組件或頁面內使用表單數據"},{"t":"p","c":"有時，你可能需要在組件或頁面內使用表單數據，並且需要在 ready 周期生命周期時生成數據並將其綁定到組件上。"},{"t":"p","c":"在下面的示例中，我們演示了如何在自定義組件內使用表單數據。這個組件包含一個文本輸入框，當你輸入內容時，它會實時更新日誌中的數據。"},0,0,0,{"t":"p","c":"通過 ready 周期生命周期，在組件準備就緒後，我們使用 this.shadow.formData() 方法生成了表單數據對象 fdata。然後，我們使用 watch 監聽 fdata 的變化，當數據發生變化時，將其轉化為 JSON 字符串並更新 logtext，以實現實時顯示表單數據的功能。"}],"index":[{"t":"h1","c":"index"},{"t":"p","c":"index 屬性用於獲取元素在其父元素下的位置。這個位置是從0開始計數的，也就是說第一個元素的位置是0，第二個是1，以此類推。"},{"t":"p","c":"在下面的示例中，我們演示了如何使用 index 屬性來獲取一個元素在其父元素下的位置："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先選中一個具有 id 為 \"target\" 的 <li> 元素。然後，我們使用 index 屬性來獲取該元素在其父元素 <ul> 下的位置，即第二個元素，所以 index 的值為1。然後將這個值顯示在具有 id 為 \"logger\" 的 <div> 元素中。"}],"is":[{"t":"h1","c":"is"},{"t":"p","c":"用於檢測元素是否符合表達式；"},0,0,0,0],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"用於主動刷新組件的渲染視圖，有時候組件上的數據沒有更新時，可以使用該方法刷新組件的視圖；"},0,0,0],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"PATH 屬性通常用於自定義組件或頁面組件上，用於獲取該組件的注冊組件的文件地址。這在開發過程中可以幫助你了解組件的來源，特別是當你需要引用或加載其他資源文件時，可以使用 PATH 屬性來構建文件路徑。"},{"t":"p","c":"下面是一個簡單示例，演示如何在自定義組件中使用 PATH 屬性："},0,{"t":"p","c":"在這個示例中，我們選擇了一個具有 id 為 \"myCustomComponent\" 的 my-comp 元素，然後通過 PATH 屬性獲取了該自定義組件的文件路徑。你可以根據需要在腳本部分使用 componentPath 變量，例如，用它來構建其他資源文件的路徑或進行其他操作。"}],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extend 是一個高階方法，用於擴展實例的屬性或方法；"},0,0,0,0,{"t":"h2","c":"擴展 $ 底層"},{"t":"p","c":"和 jQuery 類似，你也可以通過 fn.extend 擴展底層實例的屬性或方法；從 fn 擴展的屬性或方法會應用到所有實例上；"},0,0,0,0,{"t":"h2","c":"擴展模板語法"},{"t":"p","c":"通過 extend 擴展屬性或函數，可以增加模板語法的功能，甚至為組件提供專屬的模板語法糖。但需要注意的是，盡量不要使用非官方的模板語法，因為它們會給使用者帶來一定的學習成本，並且大量非官方模板語法糖會降低開發體驗。"},{"t":"h3","c":"擴展屬性"},{"t":"p","c":"你可以通過擴展屬性，在模板中使用 : 來進行設置。下面我們將擴展一個 red 屬性，當 red 為 true 時，字體顏色變為紅色："},0,0,0,0,0,{"t":"p","c":"在這個示例中，我們為模板語法添加了一個 red 屬性，當 count % 3 不為 0 時，字體顏色將變為紅色。"},{"t":"h3","c":"擴展方法"},{"t":"p","c":"你還可以通過 extend 擴展方法，使其在模板語法中可用。方法名稱就是冒號前的部分。在這裏，我們擴展了一個 color 模板語法，後面跟著的參數將被傳遞給定義的擴展方法。"},{"t":"p","c":"此處設置了 always 屬性為 true，表示在組件每次需要刷新界面的時機時，都會調用這個定義好的方法。如果不設置 always，那麽這個模板語法函數只會運行一次。"},{"t":"p","c":"其中，options 提供了更多的參數，可以幫助你開發更具定制性的模板語法；"},0,0,0,0,0,{"t":"h2","c":"模板語法原理"},{"t":"p","c":"到目前為止，你應該已經能夠理解，ofa.js 上的許多模板語法實際上是通過 extend 擴展出來的："},{"t":"l","c":"- class、attr 方法每次刷新視圖都會運行\n- on、one 這種函數綁定只會運行一次"},{"t":"p","c":"你可以查看下面的示例來更好地理解 ofa.js 的模板渲染原理："},0,0,0],"version":[{"t":"h1","c":"version"},{"t":"p","c":"通過 ofa.version 屬性，你可以獲取當前引入的 ofa.js 的版本號。"},0,0,0,0,0,{"t":"p","c":"這樣，你就可以在頁面上顯示當前使用的 ofa.js 版本。"}],"stanz":[{"t":"h1","c":"實例數據特征"},{"t":"p","c":"通過 $ 獲取或創建的實例對象，擁有完整 stanz 數據特性，因為 $ 實例是從 stanz 繼承而來的。這意味著你可以利用 stanz 提供的數據操作方法和特性來操作和監聽實例對象的數據。"},0,{"t":"h2","c":"watch"},{"t":"p","c":"實例可以通過 watch 方法監聽值的變動；即使改動了對象的子對象的值，也能在對象的 watch 方法中監聽到變動。"},{"t":"p","c":"下面是一個示例，演示如何使用 $ 實例和 watch 方法："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先創建了一個 $ 實例對象 target，然後使用 watch 方法來監聽它的變動。即使我們改動了對象的子對象的值，例如 target.bbb.child.val 的值，在 watch 方法中都能監聽到這些變動並更新 logger 元素的內容。這展示了 $ 實例對象的強大特性，使你能夠輕松監控對象的變化。"},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick 和 watch 方法功能類似，但 watchTick 內部有節流操作，它在單個線程下執行一次，因此在某些性能要求更高的場景下可以更有效地監聽數據變動。"},{"t":"p","c":"下面是一個示例，演示如何使用 $ 實例的 watchTick 方法："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先創建了一個 $ 實例對象 target。然後，我們使用 watch 方法和 watchTick 方法來監聽對象的變動。watch 方法會在數據變動時立即運行，而 watchTick 方法在單個線程下執行一次，因此能夠限制監聽操作的頻率。你可以根據你的需求選擇使用 watch 或 watchTick 方法來監聽數據的變化。"},{"t":"h2","c":"unwatch"},{"t":"p","c":"unwatch 方法用於取消對數據的監聽，可以撤銷之前注冊的 watch 或 watchTick 監聽。"},{"t":"p","c":"下面是一個示例，演示如何使用 $ 實例的 unwatch 方法："},0,0,0,0,{"t":"p","c":"在這個示例中，我們首先創建了一個 $ 實例對象 target，然後使用 watch 方法和 watchTick 方法分別注冊了兩個監聽。之後，通過 unwatch 方法傳遞之前保存的監聽返回值 tid1 和 tid2 來撤銷這兩個監聽。這意味著在第一個 setTimeout 中的屬性改變不會觸發任何監聽，因為監聽已被撤銷。"},{"t":"h2","c":"不被監聽的值"},{"t":"p","c":"在 $ 實例中，使用下劃線 _ 開頭的屬性名表示這些值不會被 watch 或 watchTick 方法監聽。這對於一些臨時或私有的屬性非常有用，你可以在不觸發監聽的情況下隨意更改它們。"},{"t":"p","c":"下面是一個示例，演示了如何使用下劃線開頭的屬性值來避免被監聽："},0,0,0,0,{"t":"p","c":"在這個示例中，我們創建了一個 $ 實例對象 target，然後使用 watch 方法監聽屬性值的變動。在 setTimeout 中，我們嘗試更改 _aaa 屬性值，但這個更改不會觸發監聽。這對於需要在不觸發監聽的情況下更新屬性值的情況非常有用。"},{"t":"h2","c":"基本特征"},{"t":"p","c":"設置在實例上的對象數據將被轉換為 Stanz 實例，這種 Stanz 實例允許進行監聽。"},0,{"t":"p","c":"我們還可以使用 $.stanz 來創建一個沒有與實例綁定的 Stanz 數據。"},0,{"t":"p","c":"這些示例展示了將對象數據設置為 Stanz 實例以進行監聽的基本特征。"},{"t":"p","c":"更多完整的特性請查閱 stanz；"}]}}}