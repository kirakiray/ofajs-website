{"cases":{"index":[0,{"t":"h1","c":"Inicio rápido"},{"t":"p","c":"Para comenzar a usar, simplemente integra el proyecto ofajs en tu proyecto importando la dirección del CDN:"},0,{"t":"p","c":"Este es un ejemplo simple que muestra cómo usar ofa.js para modificar el contenido de elementos DOM."},{"t":"h2","c":"Uso"},{"t":"p","c":"Después de importar ofa.js, se registrará el símbolo $ en el ámbito global. Use $('xxx') para seleccionar el primer elemento que cumpla con la condición, donde xxx es el contenido estándar del selector CSS."},{"t":"p","c":"En el ejemplo anterior, utilizamos el símbolo \"$\" para seleccionar tres elementos con diferentes \"id\" y modificar su contenido mediante la configuración de los atributos \"text\", \"html\" y \"value\"."},{"t":"p","c":"Para obtener más información sobre las propiedades y métodos disponibles, consulte la documentación de la API."}],"event":[0,{"t":"h1","c":"Respuesta a eventos"},{"t":"p","c":"Puede usar el método on para asociar eventos. Eventos es uno de los conceptos fundamentales en el desarrollo, a través de la activación de eventos, la aplicación puede generar respuestas y lograr la interactividad."},{"t":"p","c":"El siguiente ejemplo muestra cómo unir un evento de clic:"},{"t":"p","c":"En este ejemplo, seleccionamos el elemento button utilizando $ y vinculamos el evento click con el método on. Cuando se hace clic en el botón, se activa la función de devolución de llamada que cambia el contenido de texto del elemento target a \"¡Hola mundo!\""},{"t":"p","c":"Si desea obtener más información sobre los tipos de eventos disponibles, consulte el documento Eventos."}],"simple-component":[0,{"t":"h1","c":"Creación y uso de componentes"},{"t":"p","c":"Una vez que se complete la carga de ofa.js, se registrará globalmente un componente llamado 'load-module' que puedes referenciar usando la abreviatura 'l-m'. Su uso es similar a la etiqueta 'script', donde puedes usar el atributo 'src' para referenciar la ubicación del componente que has desarrollado."},{"t":"p","c":"Ahora, empecemos a crear nuestros propios componentes. Primero, crea un archivo HTML con el mismo nombre que el del componente."},{"t":"p","c":"En el archivo del componente, primero se agrega un elemento template y se le agrega el atributo component. El contenido que el componente necesita renderizar se coloca dentro de este elemento template. Finalmente, este contenido se renderizará dentro del Shadow DOM del componente, el cual está aislado del entorno externo para evitar la contaminación del entorno externo."},{"t":"p","c":"A continuación, simplemente use el componente l-m para llamar a su componente desarrollado. En la página, simplemente use la etiqueta del componente que ha definido."},{"t":"p","c":"El componente registrado debe utilizar solo letras minúsculas y el símbolo -, y debe contener al menos un -. Debe seguir esta regla de nomenclatura."},{"t":"p","c":"A través de este ejemplo, aprenderás cómo crear un componente llamado my-comp y cómo usarlo en otra página. También puedes establecer el estilo del componente mediante la vinculación de un archivo CSS externo."}],"slot":[0,{"t":"h1","c":"Ranuras de componente"},{"t":"p","c":"Al añadir la etiqueta <slot></slot> en la plantilla, se puede colocar el contenido dentro del slot correspondiente del componente al usarlo."},{"t":"p","c":"En general, los componentes personalizados no tienen la propiedad display definida de forma predeterminada, por lo que debes definirla manualmente para el componente. Puedes utilizar el selector :host en el estilo del componente para agregar estilos propios del mismo."},{"t":"p","c":"Este ejemplo muestra cómo crear un componente llamado simple-btn. El template del componente incluye una ranura donde se puede insertar contenido en el componente. Se añade estilo al componente mediante el selector :host. En otra página, se hace referencia al componente simple-btn utilizando el componente l-m e insertando contenido en él."}],"render-text":[0,{"t":"h1","c":"Renderizado de texto"},{"t":"p","c":"En el archivo del componente, puedes agregar una etiqueta script para escribir el código lógico del componente. Puedes configurar los parámetros del componente a través del objeto default expuesto."},{"t":"p","c":"Entre ellos, el parámetro data se utiliza para definir los datos predeterminados de los elementos del componente. Una vez que se instancia, puedes usar la sintaxis del plantilla."},{"t":"p","c":"El texto se renderiza envuelto por dobles llaves, es decir {{xxx}}, donde xxx representa el nombre de la propiedad del componente."},{"t":"p","c":"Se muestra un ejemplo de cómo renderizar la propiedad val de un elemento componente."}],"attribute-transmission":[0,{"t":"h1","c":"Transferencia de características"},{"t":"p","c":"Los parámetros attrs y data son similares en funcionalidad. Los datos establecidos en attrs se fusionarán en data, pero los datos en attrs se reflejarán en las características propias del componente."},0,{"t":"p","c":"Cuando se utiliza un componente externo, también se puede pasar datos al componente interno a través de atributos. Es importante tener en cuenta que los datos pasados a través de los atributos solo pueden ser de tipo cadena de caracteres."}],"get-set-comp":[0,{"t":"h1","c":"Obtener y modificar el valor de la instancia del componente"},{"t":"p","c":"Puede obtener o modificar los datos del componente desde el exterior."},{"t":"p","c":"El ejemplo muestra cómo operar con los datos de un componente externo."}],"inject-host":[0,{"t":"h1","c":"Inyectar componente de anfitrión"},{"t":"p","c":"Dado el aislamiento de los Web Components, es difícil modificar directamente los estilos de los elementos dentro de las ranuras de los componentes. Para abordar este problema, ofa.js proporciona un componente llamado \"inject-host\"; el componente \"inject-host\" inyecta estilos en la capa principal para configurar de manera más flexible la apariencia del componente."},{"t":"p","c":"Es importante tener en cuenta que el uso de este componente puede afectar el estilo de la capa principal. Por lo tanto, al modificar los estilos, se debe mantener la nomenclatura adecuada para evitar afectar el estilo de la capa principal."},{"t":"p","c":"En el ejemplo, hemos definido el componente comp-two, que utiliza el componente inject-host para inyectar estilos. Esto nos permite establecer estilos en los elementos internos del componente comp-two utilizando los estilos inyectados, sin afectar a otros componentes."},{"t":"p","c":"Además, los siguientes elementos requieren una atención especial"},{"t":"l","c":"- Al agregar etiquetas <style> dentro de inject-host, podemos definir estilos específicos dentro del componente. Estos estilos solo afectarán a los elementos del componente actual y no se extenderán a otros componentes.\n- Al inyectar estilos, debemos evitar el uso de selectores demasiado comunes para evitar afectar los estilos de otros componentes. Es importante mantener la singularidad y especificidad del selector.\n- inject-host también puede inyectar archivos de hojas de estilo externas usando la forma <link rel=\"stylesheet\" href=\"target/style.css\">."},{"t":"p","c":"En todo el ejemplo, al usar inject-host dentro del componente comp-two, podemos configurar y aplicar de manera flexible el estilo interno del componente sin romper el estilo de otros componentes."}],"property-transmission":[0,{"t":"h1","c":"Atributos de transferencia"},{"t":"p","c":"Utilizando la sintaxis de propbinding, puede aplicar los datos de un componente a los atributos de los elementos en la plantilla."},{"t":"p","c":"El método de uso consiste en agregar atributos :nombre=\"clave\" a un elemento de destino, donde nombre es el nombre del atributo que se debe establecer en el elemento de destino y clave es el nombre de la clave de atributo que deseas pasar en tu componente personalizado."},{"t":"p","c":"Anteriormente mencioné la forma de establecer atributos usando selectores, pero aquí se introduce la sintaxis de transmisión de atributos para establecer atributos."}],"sync":[0,{"t":"h1","c":"Enlace de datos bidireccional"},{"t":"p","c":"mediante el uso de la sintaxis sync, puede establecer una asociación bidireccional en tiempo real entre los elementos interactivos de la interfaz de usuario (como cuadros de texto o componentes personalizados) y el modelo de datos."},{"t":"p","c":"El siguiente ejemplo muestra cómo usar la propiedad \"sync\" en un componente para lograr una vinculación bidireccional entre un cuadro de texto y un modelo de datos:"},{"t":"l","c":"- En el parámetro data, hemos definido un dato llamado testText y le hemos asignado el valor inicial \"Soy testText\".\n- El uso de sync:value=\"testText\" indica que se ha establecido una vinculación bidireccional entre el valor del campo de entrada y el dato testText. Por lo tanto, cuando el usuario ingresa contenido en el campo, el dato testText se actualizará en tiempo real, y viceversa.\n- De manera similar, el uso de sync:txt=\"testText\" indica que se ha establecido una vinculación bidireccional entre el atributo txt del componente personalizado y el dato testText. Cuando el atributo txt del componente cambie, el dato testText se actualizará en tiempo real, y viceversa."},{"t":"p","c":"A través de la vinculación de datos bidireccional, puede establecer fácilmente una conexión entre la interfaz de usuario y el modelo de datos, de modo que los cambios en los datos se reflejen automáticamente en la interfaz, al mismo tiempo que las entradas del usuario en la interfaz también afecten inmediatamente al modelo de datos."},{"t":"p","c":"Lo que debes tener en cuenta es que la sincronización de datos solo puede transferir cadenas de texto o números, no puede transferir otros tipos de datos."}],"bind-event":[0,{"t":"h1","c":"Eventos de vinculación"},{"t":"p","c":"Dentro del componente, puedes utilizar la propiedad on para vincular eventos y hacer que el componente sea interactivo. Aquí se muestra cómo puedes vincular eventos en un componente para lograr efectos interactivos."},{"t":"p","c":"El parámetro proto se utiliza para definir los métodos propios del componente. Estos métodos pueden ser utilizados tanto dentro del componente como fuera del mismo al ejecutarlo a través de un selector."},{"t":"p","c":"on:click=\"xxx\" puede ser seguido por el nombre de un método definido dentro del componente o por una expresión de función. Si se utiliza una expresión de función, no es necesario escribir explícitamente la palabra clave this, el alcance de las variables se vinculará automáticamente al componente en sí mismo;"},{"t":"p","c":"Si desea obtener más información sobre los tipos de eventos disponibles, consulte el documento Eventos."}],"nested-component":[0,{"t":"h1","c":"Componentes anidados"},{"t":"p","c":"Colocar toda la lógica en un solo componente no es una elección sabia; puedes dividir la lógica en otros componentes y usar la importación mediante el método l-m."},{"t":"p","c":"En el ejemplo se importa el componente anidado llamado CompTwo a través de <l-m src=\"./comp-two.html\"></l-m>."},{"t":"p","c":"A través de <comp-two :txt=\"val\"></comp-two>, se usa un componente anidado y se pasa el atributo val del componente actual como atributo txt al componente anidado. De esta manera, el componente anidado puede usar los datos pasados para realizar la renderización."},{"t":"p","c":"En <comp-two></comp-two>, estamos usando un componente anidado sin pasar ningún atributo. La forma en que se utiliza aquí depende de la lógica y el diseño del componente anidado."},{"t":"p","c":"Si un componente se carga correctamente, sin importar dónde, se puede utilizar el componente con el nombre correspondiente. Incluso si se utiliza el componente \"l-m\" para cargar el mismo componente varias veces en diferentes lugares, esto no provocará que el componente se cargue varias veces. Este mecanismo garantiza la reutilización y coherencia de los componentes."}],"event-passing":[0,{"t":"h1","c":"Paso de eventos"},{"t":"p","c":"Además de escuchar eventos nativos, on también se puede utilizar para escuchar eventos personalizados, lo cual es muy importante para la comunicación de eventos entre componentes. Los eventos personalizados se activan mediante el método emit. Al activar un evento personalizado, se puede pasar datos personalizados al receptor."},{"t":"p","c":"Si necesitas cruzar los límites del Shadow DOM del componente para activar eventos, puedes agregar el atributo composed."},{"t":"p","c":"En el siguiente ejemplo, aprenderemos cómo utilizar el método emit para la transferencia de eventos entre componentes anidados."}],"condition":[0,{"t":"h1","c":"El rendimiento condicional"},{"t":"p","c":"No sólo hay sintaxis de plantilla, sino también componentes de plantilla en la plantilla;"},0,{"t":"p","c":"El renderizado condicional le permite insertar contenido diferente en un componente de forma dinámica según las condiciones específicas. A continuación se muestra un ejemplo de cómo usar el renderizado condicional dentro de un componente."},{"t":"p","c":"En este ejemplo, creamos un componente llamado test-demo. El componente contiene un botón que aumenta la propiedad count. Usando las etiquetas x-if, x-else-if y x-else, implementamos la lógica de representación condicional."},{"t":"l","c":"- La etiqueta x-if acepta un atributo value, que se utiliza para definir una condición. Si el valor de value es true, se renderizará el contenido dentro de x-if. En este ejemplo, si count es un número par, se mostrará texto en color rojo.\n- La etiqueta x-else-if también acepta un atributo value, que se utiliza para definir una condición. Si la condición anterior no se cumple y el valor de value es true, se renderizará el contenido dentro de x-else-if. En este ejemplo, si count es un múltiplo de 3, se mostrará texto en color azul.\n- La etiqueta x-else no requiere un atributo value, se renderizará su contenido cuando ninguna de las condiciones anteriores se cumpla. En este ejemplo, si count no es ni un número par ni un múltiplo de 3, se mostrará texto en color verde. También se puede utilizar x-else inmediatamente después de x-if."},{"t":"p","c":"De esta manera, puedes renderizar contenido diferente de manera dinámica según diferentes condiciones, logrando una interacción y visualización flexible."}],"fill":[0,{"t":"h1","c":"Rendimiento de relleno"},{"t":"p","c":"El relleno de plantillas (x-fill) en los marcos de frontend es similar al concepto de renderización de listas, lo que le permite renderear dinámicamente un conjunto de componentes miniatura según una colección de datos."},{"t":"p","c":"En el proceso de renderizado de relleno, puedes utilizar las siguientes variables especiales:"},{"t":"l","c":"- $data: Representa los datos del elemento de llenado. Al operar en $data, puedes obtener o modificar los datos de cada elemento de llenado.\n- $index: Representa el índice del elemento actual en la colección de datos.\n- $host: Representa el componente actual. Si deseas obtener datos del componente o llamar a los métodos del componente, necesitas utilizar $host para acceder al componente."}],"fill-temp":[0,{"t":"h1","c":"Relleno de renderizado recursivo"},{"t":"p","c":"relleno de representación le permite usar plantillas independientes para representar datos y nombrarlas mediante el atributo nombre en el elemento <plantilla>. Esta forma le permite lograr una representación de datos con estructuras anidadas, creando así componentes más complejos."},{"t":"p","c":"Cuando se utiliza el x-fill para el rendimiento de relleno, simplemente pase el nombre de la plantilla correspondiente al atributo name para rendir el contenido de la plantilla independiente. Además, el rendimiento de relleno también admite el relleno recursivo, es decir, se puede seguir utilizando el mismo nombre de plantilla dentro de la plantilla para lograr un relleno anidado."},{"t":"p","c":"En el ejemplo, hemos definido una plantilla independiente llamada item y le hemos pasado el nombre de la plantilla correspondiente usando x-fill. De esta manera, cada elemento en los datos se renderizará utilizando esta plantilla, y dentro de la plantilla se puede usar el mismo nombre de plantilla para llenado recursivo. Esta forma le permite manejar datos con estructuras anidadas de manera flexible y lograr una renderización de componentes más compleja."}],"life-cycle":[0,{"t":"h1","c":"Ciclo de vida"},{"t":"p","c":"Los métodos del ciclo de vida proporcionan oportunidades para ejecutar código en diferentes etapas del componente. En ofa.js, hay cinco métodos principales del ciclo de vida, que son: created, ready, watch, attached y detached."},{"t":"l","c":"- created(): Se llama cuando se crea el componente, en este momento aún no se ha renderizado el shadow root. Puede realizar algunas configuraciones de inicialización aquí, pero no puede acceder a los elementos dentro del shadow root.\n\n- ready(): Se llama después de que se haya renderizado el shadow root, generalmente se utiliza para la lógica de inicialización del componente. En esta etapa, puede acceder y manipular los elementos dentro del shadow root, así como realizar otras operaciones que necesite realizar después de que se complete el renderizado.\n\n- watch: Se utiliza definiendo un objeto watch para escuchar cambios en los datos. Después de que ready se complete, se activa un evento de watch correspondiente al valor en data. A partir de entonces, cada vez que el valor de la clave correspondiente cambie, se activará la función correspondiente dentro del watch.\n\n- attached(): Se llama cuando el componente se agrega al documento, en este momento puede interactuar con el entorno externo, como obtener la apariencia del componente o inicializar la lógica de datos compartidos.\n\n- detached(): Se llama cuando el componente se elimina del documento. En esta etapa, puede realizar tareas de limpieza, cancelar la interacción con el entorno externo y liberar recursos."}],"form-data":[0,{"t":"h1","c":"Datos del formulario"},{"t":"p","c":"En muchas aplicaciones, el procesamiento de datos de formulario es una tarea común. Para simplificar este proceso, ofa.js ha abstraído el manejo de datos de formulario y proporciona el método formData. Con este método, puede mapear fácilmente los valores de los elementos del formulario a un objeto y actualizar automáticamente los datos de este objeto cuando cambian los valores de los elementos del formulario, y viceversa."},{"t":"p","c":"A través de la propiedad shadow, puedes acceder al contenido del nodo raíz del Shadow DOM del componente. Esto te permite acceder y manipular los elementos y estilos del Shadow DOM dentro del componente."},{"t":"p","c":"En este ejemplo, podemos ver cómo utilizar el método formData para mapear automáticamente los datos del formulario al objeto fdata. Esto le permite obtener o modificar los valores de los elementos del formulario manipulando el objeto fdata, y estos cambios también se sincronizarán automáticamente con los elementos correspondientes del formulario."}],"custom-form-element":[0,{"t":"h1","c":"Componente de formulario personalizado"},{"t":"p","c":"Utilizando ofa.js, puedes desarrollar fácilmente componentes personalizados de elementos de formulario con características estándar. Solo necesitas agregar el atributo value a tu componente personalizado y configurar el atributo name, de esta manera tu componente hecho a medida se puede utilizar como un elemento de formulario estándar. Al actualizar el atributo value del componente, puedes interactuar con los elementos del formulario."},{"t":"p","c":"Cuando se inicialice formData, es necesario agregar las características del selector del componente personalizado a los parámetros (aunque los parámetros predeterminados del método formData sean \"input,select,textarea\"). De esta manera, formData puede interactuar con el componente personalizado."},{"t":"p","c":"En este ejemplo, implementamos un campo de texto editable utilizando el componente personalizado custom-input. Este componente se utiliza como elemento de formulario y utiliza el atributo value para interactuar con los datos. Al utilizar el método formData, agregamos \"input,custom-input\" como parámetro para inicializar correctamente los datos del formulario."}],"use-page":[0,{"t":"h1","c":"Usando componentes de página"},{"t":"p","c":"Una vez que se carga ofa.js, se agrega automáticamente un componente de página llamado o-page al ámbito global. Este componente se utiliza para cargar módulos de página, que son un tipo especial de módulo de componente y no se registran como etiquetas personalizadas, sino que se cargan a través del componente o-page."},{"t":"p","c":"Las páginas modulares son similares a los módulos de componentes, pero con algunas diferencias. Las páginas modulares utilizan el atributo page para definir la plantilla en lugar del atributo component. La lógica de desarrollo de las páginas modulares es similar a la de los módulos de componentes; se usan la misma sintaxis de plantillas y los mismos componentes de plantilla. Sin embargo, las páginas modulares no pueden utilizar el atributo attrs porque los parámetros de la página generalmente se pasan a través de la URL en lugar de data o attrs."},{"t":"p","c":"En el ejemplo, el componente 'o-page' se utiliza para cargar el módulo de la página 'page.html'. Dentro del módulo de la página, se utiliza la propiedad 'page' para definir la plantilla y luego se utiliza una función en JavaScript para devolver un objeto que establece los datos. El parámetro de consulta 'count' en la URL se pasa al módulo de la página y se utiliza para inicializar los datos. Los eventos de clic en los botones de la página pueden actualizar los datos y mostrarlos en la página."}],"use-app":[0,{"t":"h1","c":"Uso del componente app"},{"t":"p","c":"En ofa.js, puedes usar el componente o-app para crear la estructura de diseño de toda la aplicación y cargar diferentes módulos de página en ella. Mediante el uso del componente o-app, el componente o-page y los módulos de página, puedes construir la estructura de páginas de toda la aplicación y realizar la navegación entre páginas."},{"t":"p","c":"Cuando el componente o-page está dentro de o-app, puedes usar la etiqueta <a> con el atributo olink para realizar la navegación entre páginas. Esta navegación no afectará a la página actual, sino que solo ocurrirá dentro de o-app, similar a usar <iframe>."},{"t":"p","c":"Si el componente o-page está dentro de o-app, también puedes utilizar los siguientes métodos:"},{"t":"l","c":"- Usar el método goto para realizar una navegación de página.\n- Usar el método back para volver a la página anterior.\n- Usar el método replace para realizar una navegación de reemplazo en la página actual."},{"t":"p","c":"A través del componente o-app, puedes construir la estructura de diseño de toda la aplicación y cargar diferentes módulos de página en ella. Al mismo tiempo, la funcionalidad de enrutamiento proporcionada por o-app hace que la navegación entre páginas sea más conveniente y flexible."},{"t":"p","c":"En este ejemplo, creamos un diseño de aplicación utilizando el componente o-app y luego cargamos un módulo de página llamado page1.html."},{"t":"p","c":"En el módulo de la página page1.html, hemos definido un título y un botón. Al hacer clic en el botón, se redirigirá a otro módulo de página llamado page2.html. También hemos agregado un enlace con el atributo olink, al hacer clic en el enlace también se navegará a page2.html."},{"t":"p","c":"En el módulo de la página page2.html, también hemos definido un título y un botón. Al hacer clic en el botón, se regresará a la página anterior, logrando la navegación de la página."}],"app-loading":[0,{"t":"h1","c":"Personalizar la carga para la aplicación"},{"t":"p","c":"A continuación se muestra un ejemplo de cómo personalizar la carga para el componente o-app. En este ejemplo, hemos creado una barra de progreso animada que se incrementa gradualmente durante la carga de la página y se completa al llegar al 100%. Luego, se elimina el elemento de carga."},{"t":"p","c":"Puede copiar y utilizar el siguiente código para personalizar el efecto de carga de su aplicación:"},0,{"t":"p","c":"A través de este código, puedes agregar un efecto de carga único a tu aplicación, para que los usuarios tengan una mejor experiencia durante el proceso de cambio de página."}],"app-config":[0,{"t":"h1","c":"Configurar los parámetros de la aplicación"},{"t":"p","c":"Puede configurar los parámetros de la aplicación mediante la configuración de un módulo externo para la etiqueta o-app."},{"t":"p","c":"Estos parámetros son un módulo de ES, puede configurar los siguientes parámetros:"},{"t":"l","c":"- home: Página principal de la aplicación, es la página que se muestra al cargar inicialmente.\n- loading: Contenido mostrado mientras se carga un módulo en una página de la aplicación al hacer clic para navegar. Puedes devolver una cadena como contenido de carga.\n- pageAnime: Efecto de animación al cambiar de página, utiliza un objeto que contiene propiedades de estilo CSS.\n  - current: Estilo cuando la página está actualmente en pantalla.\n  - next: Estilo cuando la página aún no ha entrado en pantalla.\n  - previous: Estilo cuando la página está a punto de salir de pantalla."},{"t":"p","c":"A través de esta forma, puede personalizar la página de inicio, el estilo de carga y las animaciones de transición de página según las necesidades de la aplicación, brindándole una experiencia más personalizada."}],"nested-page":[0,{"t":"h1","c":"Página incrustada"},{"t":"p","c":"Algunas interfaces de usuario de aplicaciones están compuestas por varias capas de páginas anidadas, como la navegación superior o lateral compartida. Puedes usar la propiedad parent para indicar la página padre que contiene la página actual."},{"t":"p","c":"El proceso de creación de la página principal es similar al desarrollo de componentes. Necesitas crear una página que contenga el diseño completo del marco y luego colocar las subpáginas internas anidadas en la ranura (slot)."},{"t":"p","c":"Este ejemplo demuestra cómo crear páginas anidadas, donde page1.html y page2.html son las subpáginas, y layout.html es la página principal. La página principal layout.html incluye toda la estructura del marco, mientras que las subpáginas se enlazan a través del atributo parent para indicar que deben estar incrustadas dentro de la página principal."},{"t":"p","c":"Cuando se cambia de página, se activará el evento routerChange. En la inicialización de la página y al cambiar de página, puedes utilizar la propiedad app.current para obtener la dirección de la página actual y corregir el estado de activación de las pestañas en la página."}],"set404":[0,{"t":"h1","c":"Configuración de la página 404"},{"t":"p","c":"En el módulo de configuración de la aplicación, personalice el contenido mostrado cuando la página no se cargue correctamente estableciendo la función fail."},{"t":"p","c":"En este ejemplo, se mostrará la primera línea de contenido del mensaje de error cuando la carga de la página falle."},0],"multi-nested":[0,{"t":"h1","c":"Páginas de anidamiento múltiple"},{"t":"p","c":"Para utilizar la función de páginas con múltiples niveles de anidamiento, simplemente configura el atributo \"parent\" en el módulo de página anidada de la capa superior y establece su valor como la dirección del módulo de página que deseas anidar."},{"t":"p","c":"Para obtener información más detallada, consulta el artículo anterior que proporciona parámetros y métodos relacionados con la anidación."}],"use-hash-router":[0,{"t":"h1","c":"usar enrutador hash"},{"t":"p","c":"Solo necesitas usar el componente o-router para vincular las rutas del componente de la aplicación con la página web actual. Una vez que la página y la ruta están vinculadas, incluso si se actualiza la página, se mantendrá el estado de la ruta de la página."},{"t":"p","c":"En este ejemplo, haga clic en el botón  <span style='font-family: \"iconfont\"'>&#xe7cb;</span>  para abrirlo en una nueva página y probarlo."},0],"use-scsr":[0,{"t":"h1","c":"Uso del esquema SCSR"},{"t":"p","c":"En este ejemplo, haga clic en el botón <span style='font-family: \"iconfont\"'>&#xe7cb;</span> para abrir y probar en una nueva página."},{"t":"p","c":"SCSR, cuyo nombre completo es Representación estática del lado del cliente, también conocida como representación estática del cliente, es una variante de CSR (Representación del lado del cliente) que, al mantener la experiencia del usuario de CSR, permite que las páginas sean rastreadas por los motores de búsqueda en un estado estático."},{"t":"p","c":"El sitio web actual utiliza el esquema SCSR para construirlo."},{"t":"p","c":"SCSR i.e. State Controlled Stateless Rendering, permite la renderización en la página mediante la ejecución directa de módulos de página en modo de archivo único sin necesidad de usar la etiqueta o-page. Específicamente, se trata de anidar el código de plantilla del módulo de página directamente dentro de o-app."},{"t":"h2","c":"Nota:"},{"t":"p","c":"Para todas las páginas que adopten el esquema SCSR, excepto el contenido descriptivo de la página (como título, meta descripción, palabras clave) y el contenido de la plantilla de la página, se debe mantener la coherencia de los recursos referenciados para garantizar una experiencia de usuario consistente después de la navegación y actualización de la página."}],"sync-state":[0,{"t":"h1","c":"Sincronización de estados"},{"t":"p","c":"A veces es necesario que varias instancias de componentes o páginas compartan los mismos datos, en este caso es necesario contar con la función de sincronización de estado."},{"t":"p","c":"Utilice el método $.stanz para crear datos compartidos; si desea compartir estos datos en un componente, debe vincular los datos al componente en el momento de adjuntarlo."},{"t":"p","c":"Se necesita borrar los datos vinculados durante el ciclo de \"detached\" para evitar una fuga de memoria."},{"t":"p","c":"En este ejemplo, mostramos cómo usar la función de sincronización de estado para implementar el cambio de modo oscuro. Primero, usamos el método $.stanz para crear un objeto de datos llamado isDark, que puede ser compartido entre varios componentes. Esto permite que las diferentes instancias de los componentes compartan datos y logren el cambio de modo oscuro."}],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"Los alias permiten a los usuarios utilizar los recursos compartidos de manera más conveniente, especialmente cuando se trata de componentes compartidos entre dominios para utilizar la misma versión de recursos."},{"t":"p","c":"En este ejemplo, hemos configurado un alias a través del método lm.config, asignando el alias @obook a https://cdn.jsdelivr.net/npm/obook. Ahora, cuando utilizamos @obook como prefijo, se mapeará automáticamente a la URL especificada."},0,0,0,0,{"t":"p","c":"Utilizando el alias @obook, hemos introducido el recurso \"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\" en la etiqueta l-m, lo que permite que los componentes entre diferentes dominios accedan de manera más conveniente a los recursos compartidos sin necesidad de conocer la dirección detallada del recurso. Esto mejora la mantenibilidad del código y la facilidad de compartir recursos entre dominios."},{"t":"h2","c":"Nota:"},{"t":"p","c":"Cuando establezca un alias, tenga en cuenta lo siguiente:"},{"t":"l","c":"- Los alias de las teclas deben comenzar con @, como @example."},0,{"t":"l","c":"- No configure duplicar los mismos nombres de alias, de lo contrario esto generará un error."},0]},"docs":{"introduce":[{"t":"h1","c":"ofa.js - Progressive Front-End Framework"},{"t":"h2","c":"Qué es ofa.js?"},{"t":"p","c":"ofa.js es un marco de front-end progresivo diseñado para permitir a los desarrolladores ingresar al desarrollo y uso de front-end con el menor costo posible. Proporciona una serie de herramientas y API simples pero poderosas que hacen que el desarrollo de front-end sea más eficiente y conveniente."},{"t":"h2","c":"Propósito"},{"t":"h3","c":"Reemplazar jQuery"},{"t":"p","c":"En muchos proyectos pequeños, es posible que no sea necesario utilizar frameworks grandes como React y Vue, y preferimos utilizar jQuery para tareas front-end sencillas. ofa.js mejora la API de jQuery y reemplaza muchos métodos de jQuery por propiedades, lo que lo hace más adecuado en muchas situaciones."},{"t":"h3","c":"Simplifique el desarrollo y el flujo de trabajo del front-end"},{"t":"p","c":"El objetivo de ofa.js es simplificar el proceso de desarrollo frontend tedioso. Permite a los desarrolladores construir aplicaciones frontend más rápidamente sin tener que aprender herramientas complejas como Node.js, npm y scaffolding. Con ofa.js, puedes volver a disfrutar de la experiencia de desarrollo con solo importar una biblioteca."},{"t":"h3","c":"Convertirse en un marco de desarrollo front-end de bala de plata."},{"t":"p","c":"El objetivo de ofa.js es ser una \"bala de plata\", es decir, poder abordar diversos problemas de desarrollo front-end y proporcionar una solución integral. No es solo una biblioteca de herramientas, sino también un marco de desarrollo front-end completo."},{"t":"h2","c":"Características"},{"t":"h3","c":"Desarrollo de componentes fácil de usar"},{"t":"p","c":"Los componentes desarrollados con ofa.js tienen prácticamente ningún costo de aprendizaje. ofa.js proporciona una API simple e intuitiva que permite a los desarrolladores crear e integrar componentes rápidamente, al mismo tiempo que mantiene el código limpio y fácil de mantener."},{"t":"h3","c":"Modularidad integrada, actualizaciones de estado y soluciones de integración de aplicaciones"},{"t":"p","c":"La solución interna de ofa.js integra soluciones modulares, actualización de estado e integración de aplicaciones, lo que permite a los desarrolladores completar tareas de desarrollo fronterizo complejas sin necesidad de buscar bibliotecas o herramientas de terceros adicionales."},{"t":"h3","c":"Soluciones de enrutamiento y SSG (Static Site Generation) proporcionadas oficialmente."},{"t":"p","c":"La biblioteca ofa.js proporciona soluciones oficiales para enrutamiento y generación de sitios estáticos, lo que ayuda a los desarrolladores a gestionar mejor el enrutamiento del lado del cliente y a mejorar el rendimiento de la aplicación y la amigabilidad SEO."},{"t":"h3","c":"Tamaño de código racionalizado"},{"t":"p","c":"El código de ofa.js ha sido optimizado cuidadosamente y el tamaño del archivo .min comprimido es solo de 38 kb (solo 14 kb bajo gzip). Esto hace que ofa.js sea un marco front-end eficiente que se puede cargar y usar rápidamente en diversas condiciones de red."}],"get-started":{"index":[{"t":"h1","c":"Comenzando a usar"},{"t":"h2","c":"Cómo usar los"},{"t":"h3","c":"Cita directa"},{"t":"p","c":"Puedes utilizar la dirección CDN para referenciar directamente ofa.js en tu página:"},0,{"t":"h3","c":"Instalación vía npm"},{"t":"p","c":"Primero, instala ofa.js en tu proyecto."},0,{"t":"p","c":"Luego, importa el módulo ofa.js en tu proyecto:"},0,{"t":"h3","c":"Use"},{"t":"p","c":"Después de importar el recurso, ofa.js establecerá una propiedad $ en el ámbito global, todas las funciones estarán disponibles en $, su uso se explicará detalladamente en el tutorial posteriormente."},{"t":"p","c":"En general, recomendamos agregar ofa.js de forma directa utilizando la cita, mientras que la opción de usar npm se utiliza para compatibilidad con frameworks como React y Vue."}],"common-properties":[{"t":"h1","c":"Atributos o métodos comunes"},{"t":"p","c":"En la instancia $, además de seleccionar elementos mediante selectores, también se proporcionan algunas funciones comunes para facilitar la operación y búsqueda de elementos."},{"t":"p","c":"Puede echar un vistazo rápido y, en el futuro, consultar la documentación de la API cuando sea necesario."},{"t":"h2","c":"Atributos comunes"},{"t":"l","c":"- tag: Obtén el nombre de la etiqueta del objetivo\n- ele: Obtén el elemento nativo real de la instancia\n- index: Obtén el orden del elemento objetivo en su elemento padre\n- text: Obtén o establece el texto del elemento objetivo\n- html: Obtén o establece el código HTML del elemento objetivo\n- css: Obtén o establece el estilo del elemento objetivo\n- style: Obtén el estilo nativo del elemento objetivo\n- classList: Obtén la lista de clases nativas del elemento objetivo\n- data: Obtén el conjunto de datos nativos del elemento objetivo"},{"t":"h3","c":"Operaciones de nodos"},{"t":"l","c":"- before: agregar un elemento antes de la instancia objetivo\n- after: agregar un elemento después de la instancia objetivo\n- remove: eliminar el elemento objetivo\n- attr: obtener o establecer los atributos del elemento objetivo"},{"t":"h2","c":"Características importantes"},{"t":"l","c":"- Datos del formulario: Facilita la vinculación y la obtención de datos del formulario."},{"t":"p","c":"Si desea obtener una comprensión más profunda de la api de ofa.js, puede consultar la documentación API."}],"hello-world":[{"t":"h1","c":"El primer caso."},{"t":"p","c":"A continuación se presenta un ejemplo en el que, al hacer clic en el botón, el texto se cambia a \"Hola Mundo\":"},0,0,0,0,{"t":"p","c":"Cuando se presiona el botón, se mostrará el texto en negrita \"Hello World\"."},{"t":"p","c":"Ahora, expliquemos en detalle los conceptos básicos."},{"t":"h2","c":"Selector"},{"t":"p","c":"Después de importar ofa.js, el símbolo $ se registrará en el ámbito global. Puedes seleccionar el primer elemento que cumpla con la condición utilizando $('xxx'), donde xxx es el contenido estándar del selector CSS. Puedes hacer clic en el enlace para ver el contenido específico del selector."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, un segundo después de abrir la página, se cambiará el contenido de texto de las etiquetas p, #desk y .logger respectivamente."},{"t":"h2","c":"Asignación de eventos"},{"t":"p","c":"Después de seleccionar un elemento de manera exitosa, puedes vincular eventos a ese elemento. Como se mencionó anteriormente en el ejemplo de \"Hello World\", vinculamos un evento de clic al elemento con el id \"btn\". Cuando se hace clic en el botón, la función vinculada será ejecutada."},{"t":"p","c":"Puedes hacer clic para ver el ejemplo de evento en la sección ejemplo de evento y conocer algunos casos de enlaces de eventos."},{"t":"p","c":"Todos los eventos disponibles se pueden consultar en Eventos web para obtener una lista completa de eventos."},{"t":"h2","c":"Propiedades"},{"t":"p","c":"En los dos casos anteriores, mostramos el uso de las propiedades html y text respectivamente."},{"t":"p","c":"Puedes obtener el contenido de un elemento usando las propiedades html o text, como se muestra a continuación:"},0,0,0,0,{"t":"p","c":"En este ejemplo, asignamos el contenido HTML del elemento #t1 a los elementos #t2 y #t3."}],"basic-concept":[{"t":"h1","c":"Conceptos básicos de instancias"},{"t":"p","c":"La instancia $ es una encapsulación de los elementos en la página. Además de seleccionar elementos existentes, también se puede usar para crear nuevos elementos y operar sobre ellos. En este capítulo, se explicará cómo crear nuevos elementos y algunas operaciones sobre la instancia $."},{"t":"h2","c":"Crear nuevo elemento"},{"t":"p","c":"Con la instancia $, podemos crear nuevos elementos y manipularlos directamente, por ejemplo:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, creamos un nuevo elemento div con el código $('<div style=\"color:red\">I am text</div>') y lo agregamos al body."},{"t":"h2","c":"Obtener elementos secundarios"},{"t":"p","c":"Los ejemplos obtenidos a través de $, no tienen la propiedad children como un elemento DOM. Pero podemos acceder a los elementos hijos directos de la instancia usando índices de matriz."},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, obtenemos el elemento div y accedemos al primer y segundo elemento p mediante índices. Al mismo tiempo, también utilizamos $div.length para obtener la cantidad de elementos hijos."},{"t":"h2","c":"Operando con elementos hijos"},{"t":"p","c":"A través de $ instancia, también podemos usar directamente los métodos del arreglo para manipular los elementos secundarios, como push y pop."},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, obtuvimos todas las instancias de elementos p y usamos el método push para agregar un nuevo elemento div como hijo, luego usamos el método pop para eliminar el último hijo."},{"t":"p","c":"A través de los ejemplos anteriores, puedes conocer algunas operaciones básicas de una instancia $, incluyendo la creación de nuevos elementos y el acceso y manipulación de elementos secundarios. Una instancia $ proporciona métodos convenientes para operar con elementos en la página."}],"elements-and-events":[{"t":"h1","c":"Obtener elementos y eventos relacionados"},{"t":"p","c":"Este capítulo tiene como objetivo reforzar la comprensión del contenido del capítulo anterior, incluyendo la selección de elementos y la vinculación de eventos."},{"t":"h2","c":"Seleccionar elementos"},{"t":"p","c":"En los capítulos anteriores, hemos aprendido cómo obtener un elemento global utilizando el símbolo $. A continuación, describiremos otros métodos para obtener elementos."},{"t":"h3","c":"Encontrar un elemento desde dentro de un elemento"},{"t":"h4","c":"Utilice $(\"xxx\"). $('xxxx') de la siguiente manera"},{"t":"p","c":"$(\"xxx\").$('xxxx') es una forma de seleccionar un elemento padre y luego buscar elementos hijos que cumplan con ciertas condiciones. En este caso, $(\"xxx\") selecciona un elemento padre y luego utiliza $('xxxx') para buscar elementos hijos que cumplan con ciertas condiciones."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, primero selecciona el elemento padre con la clase \"parent\" utilizando $(\".parent\"). Luego, busca dentro de ese elemento padre los elementos hijos con la clase \"child\" utilizando $(\".child\"). Luego modifica el contenido de texto de esos elementos hijos a \"Elemento hijo modificado\"."},{"t":"h3","c":"Utilizar el enfoque $('xxx xxxx')."},{"t":"p","c":"$('xxx xxxx') es buscar los elementos que cumplan con la segunda condición del selector en el ámbito global, y luego buscar los elementos que cumplan con la primera condición del selector dentro de estos elementos. Esta forma permite encontrar directamente los subelementos que cumplan con la condición de manera más eficiente."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, se utiliza directamente $('div .child') para buscar los elementos secundarios con la clase child y se modifica el contenido de texto de los elementos secundarios a \"Elemento hijo modificado\"."},{"t":"h3","c":"No es posible traducir el texto."},{"t":"h4","c":"Utiliza $.all('xxx') para buscar elementos globales."},{"t":"p","c":"$.all('xxx') método se utiliza para buscar todos los elementos en la página que cumplan con la condición del selector, y los devuelve como una colección de elementos. Esto permite seleccionar varios elementos en la página para realizar operaciones en lote."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, se utiliza $.all(\"p\") para encontrar todos los elementos de etiqueta p en la página y realizar operaciones en lote en ellos. Se modifica el contenido del texto como \"Párrafo Modificado 1\", \"Párrafo Modificado 2\" y \"Párrafo Modificado 3\"."},{"t":"h3","c":"Buscar todos los elementos que cumplan con las condiciones dentro de un elemento"},{"t":"p","c":"Además de poder buscar elementos a nivel global, también puedes buscar todos los elementos hijos que cumplan con una determinada condición dentro de un elemento específico, utilizando el siguiente formato: $('xxx').all('xxxx')."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, primero se utiliza $(\".container\") para encontrar los elementos con la clase container, luego se utiliza .all(\".item\") para encontrar todos los elementos secundarios con la clase item dentro de ese contenedor y se realiza una operación en lote en ellos, modificando su contenido de texto a \"Modified Item 1\", \"Modified Item 2\" y \"Modified Item 3\"."},{"t":"h2","c":"Eventos"},{"t":"p","c":"Ya hemos hablado sobre cómo usar on para enlazar eventos. A continuación, se presentarán algunos métodos relacionados con eventos."},{"t":"h3","c":"Documentación sobre el uso del método off"},{"t":"p","c":"El método off se utiliza para eliminar las funciones de manejo de eventos vinculadas mediante el método on. Cuando ya no se necesita una función de manejo de eventos para un determinado evento, se puede utilizar el método off para eliminarla del elemento, evitando así ejecuciones duplicadas o pérdidas de memoria."},{"t":"h4","c":"sintaxis"},0,{"t":"l","c":"- selector: Selector del elemento al que se quiere remover el manejador de eventos.\n- eventName: Nombre del evento que se desea remover.\n- eventHandler: Función de manejo de eventos que se desea remover."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, cuando se hace clic en el botón, aparecerá un cuadro de diálogo que muestra \"¡Botón pulsado!\". Sin embargo, después de 5 segundos, se eliminó la función de manejo de eventos de clic mediante el método off, por lo que al hacer clic en el botón nuevamente, no se activará el cuadro de diálogo."},{"t":"h3","c":"Documentación de uso del método one"},{"t":"p","c":"El método one se utiliza para vincular una función de manejo de eventos, pero esta función solo se ejecutará una vez cuando se desencadene el evento por primera vez. Después de ejecutarse una vez, la función de manejo de eventos se eliminará automáticamente para evitar desencadenamientos repetidos."},{"t":"h4","c":"sintaxis"},0,{"t":"l","c":"- selector: Selecciona el elemento en el que se va a asociar la función de manejo de eventos.\n- eventName: Nombre del evento que se va a asociar.\n- eventHandler: Función de manejo de eventos que se va a ejecutar."},{"t":"h4","c":"Ejemplo"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, cuando se hace clic en el botón, se mostrará un cuadro de diálogo que dice \"¡Botón clicado una vez!\". Pero después del primer clic, se eliminará la función de manejo de eventos, por lo que los clics posteriores en el botón no volverán a mostrar el cuadro de diálogo."},{"t":"h3","c":"Documentación del uso del método emit"},{"t":"p","c":"El método emit se utiliza para activar manualmente eventos específicos vinculados a un elemento. Mediante el método emit, se puede activar la ejecución de las funciones de manejo de eventos sin realizar ninguna operación actualmente."},{"t":"h4","c":"sintaxis"},0,{"t":"l","c":"- selector: Elige el elemento que quieres que desencadene el evento.\n- eventName: Nombre del evento que quieres desencadenar."},{"t":"h4","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, se activó manualmente el evento de clic del botón mediante el método emit, lo que mostrará un cuadro de diálogo con el mensaje \"¡Botón clickeado!\", aunque en realidad no se hizo clic en el botón."},{"t":"p","c":"Ten en cuenta que el uso del método emit no simula un clic de ratón u otros eventos reales, sino que llama directamente a la función de manejo de eventos asociada. Por lo tanto, si deseas ejecutar un evento en casos específicos, puedes utilizar el método emit."},{"t":"p","c":"Cuando has vinculado un evento, a veces es posible que desees detener la propagación del evento (burbujeo) o cancelar la acción predeterminada del evento. A continuación se explicará cómo evitar la propagación y cancelar la acción predeterminada después de que se haya desencadenado el evento."},{"t":"h3","c":"Deshabilita el burbujeo de eventos"},{"t":"p","c":"La propagación de eventos se refiere a cuando se desencadena un evento en un elemento, se propaga hacia arriba a lo largo del árbol DOM y activa sucesivamente eventos del mismo tipo en los elementos padre. Si deseas detener la propagación después de manipular el evento en un elemento específico, puedes usar el método event.stopPropagation()."},{"t":"p","c":"Código de ejemplo:"},0,{"t":"p","c":"En el ejemplo anterior, cuando haces clic en el botón \"Click Me\", se mostrará \"Button Clicked!\", pero no se activarán \"Inner Div Clicked!\" y \"Outer Div Clicked!\". Esto se debe a que llamamos a event.stopPropagation() en el controlador del evento de clic del botón, lo que impide que el evento se propague más allá."},{"t":"h3","c":"Cancelar el comportamiento predeterminado de un evento"},{"t":"p","c":"Algunos eventos en ciertos elementos tienen un comportamiento predeterminado cuando se activan. Por ejemplo, hacer clic en un botón de envío provocará el envío del formulario, hacer clic en un enlace redireccionará a la dirección del enlace, etc. Si desea evitar el comportamiento predeterminado de un evento, puede utilizar el método event.preventDefault()."},{"t":"p","c":"Código de ejemplo:"},0,{"t":"p","c":"En el ejemplo anterior, cuando haces clic en el botón de envío \"Submit\", se mostrará \"Hello, {name}! Form submission prevented.\", pero no se activará la alerta \"Form Submitted!\". Esto se debe a que en el controlador del evento de clic del botón de envío se llama a event.preventDefault(), lo cual evita el comportamiento de envío predeterminado del formulario."}]},"create-component":{"index":[{"t":"h1","c":"Creación y uso de componentes"},{"t":"p","c":"El ofa.js utiliza archivos básicos de HTML y JavaScript para definir componentes, evitando la introducción de nuevos tipos de archivos para reducir el costo de aprendizaje. Si tienes un conocimiento básico de HTML, podrás desarrollar y usar los componentes de ofa.js de manera rápida."},{"t":"h2","c":"Pasos previos a la creación de un componente"},{"t":"p","c":"Antes de comenzar a crear los componentes, debes tener en cuenta algunos preparativos. Dado que la creación de componentes implica la operación de solicitar recursos del navegador, si solo abres el archivo HTML haciendo doble clic para verlo, se verá bajo el protocolo \"file\". Bajo el protocolo \"file\", la carga de módulos de JavaScript puede generar errores. Por lo tanto, debes preparar un servidor estático para ver correctamente el componente."},{"t":"p","c":"Si estás usando el editor Visual Studio Code, simplemente puedes instalar un complemento que admita un servidor estático. Recomendamos usar el complemento Live Server."},{"t":"p","c":"Después de instalar el complemento, simplemente haga clic derecho en el archivo demo.html y seleccione \"Abrir con Live Server\". El complemento abrirá automáticamente el archivo en modo de servidor estático."},{"t":"p","c":"Si estás utilizando otro editor, también puedes crear un servidor Nginx o Apache que sea capaz de mostrar HTML estático. De esta manera, podrás visualizar y desarrollar tus componentes de manera adecuada."},{"t":"h2","c":"Crear un componente de botón"},{"t":"p","c":"A continuación, vamos a crear un componente de botón simple llamado simple-button, que tendrá un estilo más atractivo que los botones nativos."},{"t":"p","c":"Primero, crea un archivo llamado simple-button.html, utiliza la etiqueta template y agrega el atributo component para identificarlo como un componente."},{"t":"p","c":"Luego, escriba el código de la plantilla del componente dentro de 'template'. Luego, debajo del contenido de la plantilla, agregue una etiqueta 'script' y coloque el código JavaScript del componente dentro de ella."},0,{"t":"p","c":"Después de la exitosa introducción de ofa.js, se registrará automáticamente el componente load-module, que es un componente utilizado para la referencia declarativa de módulos, similar a una etiqueta de script. Este componente actuará como un proxy para cargar el módulo especificado en src y realizará el procesamiento previo necesario. En este caso, se cargará la plantilla y se registrará el componente simple-button."},{"t":"p","c":"load-module componente también se puede abreviar como l-m para reducir la cantidad de código."},0,{"t":"p","c":"El componente load-module es una biblioteca de cargador declarativo personalizado que ofrece potentes funcionalidades para ampliar el soporte de varios tipos de archivos o para realizar una gestión intermedia de los módulos de JavaScript. Se ha separado en un proyecto independiente y la documentación detallada de su uso se encuentra en https://github.com/kirakiray/drill.js."},{"t":"h3","c":"Modo de doble archivo"},{"t":"p","c":"El modo de archivos dobles separa la \"plantilla estática\" y el \"código lógico\", lo que hace que los componentes sean más claros."},{"t":"p","c":"El código lógico se coloca en un archivo js, y este archivo js debe tener la declaración export const type = $.COMP; para notificar a la página que se trata de un módulo de componente. En este modo dividido, el código del módulo puede utilizar la sintaxis estándar de los Módulos ES, como import."},{"t":"p","c":"El componente de botón consta de dos archivos:"},{"t":"l","c":"1. simple-button.html: Plantilla y estilo HTML del componente de botón."},0,{"t":"l","c":"2. simple-button.mjs: Código de registro del componente de botón."},0,{"t":"p","c":"En el lugar donde se requiere usar este componente, usa l-m para importar este módulo. A continuación se muestra una página de ejemplo que utiliza el botón simple (modo de dos archivos)."},0],"parameter-description":[{"t":"h1","c":"Explicación detallada de los parámetros de registro del componente"},{"t":"p","c":"En ofa.js, puedes definir algunos parámetros de registro específicos en los módulos de componentes para configurar los componentes de manera más flexible. A continuación, se detalla cada parámetro de registro con ejemplos correspondientes."},{"t":"h2","c":"Parámetros base"},{"t":"p","c":"El parámetro base son las configuraciones básicas para registrar un componente, que incluyen las siguientes propiedades:"},{"t":"h3","c":"tag"},{"t":"p","c":"tag representa el nombre del componente registrado. Cuando no se define el atributo tag, el nombre del componente registrado será igual al nombre del archivo."},{"t":"p","c":"Ejemplo:"},0,{"t":"h3","c":"data"},{"t":"p","c":"data es un atributo de tipo objeto que se utiliza para generar componentes y agregar datos personalizados de forma predeterminada."},{"t":"p","c":"Ejemplo:"},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs es un atributo de tipo objeto que también pertenece a data, pero estos datos se reflejarán en los atributos del elemento. Los cambios en los atributos también se actualizarán dinámicamente en los datos del componente. Cuando hay claves en mayúsculas, se convierten en nombres de propiedades con guiones en lugar de camelCase."},{"t":"p","c":"Ejemplo:"},0,{"t":"h3","c":"proto"},{"t":"p","c":"En los parámetros de registro del componente, puedes agregar un objeto proto para definir los métodos que se deben agregar al prototipo del componente. De esta manera, cuando se crea una instancia del componente, estos atributos y métodos se agregarán al prototipo de la instancia, lo que permitirá que todas las instancias accedan y compartan estos métodos."},0,{"t":"h3","c":"watch"},{"t":"p","c":"El watch es un atributo de tipo objeto que se utiliza para escuchar los cambios en data y colocar la función de escucha aquí. Después de registrarse correctamente, el valor escuchado se ejecutará inmediatamente una vez."},{"t":"l","c":"- La función registrada en watch solo se disparará una vez durante un cambio en el hilo. Por lo tanto, aunque se modifique el valor de escucha varias veces en un hilo, solo se activará una vez.\n- El primer parámetro es el valor actual.\n- El segundo parámetro es un objeto que contiene el conjunto de datos watchers. Normalmente, en watchers solo habrá un objeto, desde el cual se puede obtener el oldValue. Cuando se cambia el valor de escucha varias veces en un solo hilo, este conjunto de datos registrará los cambios múltiples."},{"t":"p","c":"Ejemplo:"},0,{"t":"h3","c":"temp"},{"t":"p","c":"La mayoría de las veces, no necesitas establecer esta variable. Se utiliza principalmente en el modo separado para especificar la dirección de la plantilla de componente. Cuando temp no está definido, por defecto se cargará el archivo HTML con el mismo nombre que el módulo actual, que debería estar en el mismo directorio."},{"t":"h2","c":"Combinar variables por defecto"},{"t":"p","c":"Puede escribir todas las variables de exportación en \"default\", esto hace que sea más conveniente escribir;"},0,{"t":"h2","c":"Código de ejemplo"},{"t":"p","c":"A continuación se muestra un código de ejemplo completo, que incluye la definición de parámetros básicos y plantillas de componentes."},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"Puedes usar funciones asíncronas para definir datos default, de modo que puedas retornar dinámicamente los parámetros de registro del componente."},{"t":"p","c":"Función function traerá un objeto que incluye load, url y query:"},{"t":"l","c":"- El método load es una función de carga asíncrona, se utiliza de la misma manera que la carga asincrónica de import, y se puede cargar un módulo asincrónico utilizando const data = await load(xxx).\n- Los módulos cargados a través de load tienen el mismo efecto que los cargados a través de load-module. El método load es una versión funcional del componente load-module, y se puede consultar la documentación en https://github.com/kirakiray/drill.js para obtener información específica sobre cómo usarlo.\n- url es el nombre de archivo del módulo actual.\n- query es un objeto resultante de convertir los parámetros de URL al cargar este módulo."},{"t":"p","c":"A continuación se muestra un ejemplo del uso de 'default':"},0,{"t":"p","c":"En este ejemplo, mostramos cómo utilizar los parámetros de registro de ofa.js para personalizar el comportamiento del componente. Al configurar adecuadamente estos parámetros, puedes adaptarte mejor a las distintas necesidades de los componentes y lograr un desarrollo de componentes más flexible."}],"life-cycle":[{"t":"h1","c":"Ciclo de vida de los componentes"},{"t":"p","c":"En ofa.js, el ciclo de vida de los componentes se activa mediante funciones de enganche en momentos específicos. Estas funciones de enganche te permiten controlar e interactuar de forma más precisa. ofa.js tiene cinco funciones de enganche clave en su ciclo de vida: created, ready, watch, loaded, attached y detached, que se activan en diferentes momentos."},{"t":"h2","c":"Hooks de ciclo de vida"},{"t":"h3","c":"created"},{"t":"p","c":"created El gancho de ciclo de vida se activa cuando se crea el componente. En esta etapa, los datos del componente aún no se han inicializado y el contenido de la plantilla no se ha renderizado. Puedes realizar algunas operaciones de inicialización en esta etapa, o preparar datos que se utilizarán en etapas posteriores."},{"t":"h3","c":"ready"},{"t":"p","c":"El gancho de ciclo de vida ready se disparará después de que los datos y la plantilla del componente hayan sido inicializados, lo cual indica que el componente está listo. Durante esta etapa, puedes acceder a los datos del componente y la plantilla ya ha sido renderizada, por lo que puedes realizar algunas operaciones relacionadas con la interacción de la interfaz."},{"t":"p","c":"Si la plantilla de componente depende de otros componentes, esta etapa no esperará a que se carguen las dependencias. Por lo tanto, esta etapa es adecuada para agregar estilos de carga a los componentes, pero ten en cuenta que debes esperar a que las dependencias se carguen antes de ejecutar las operaciones relacionadas."},{"t":"h3","c":"watch"},{"t":"p","c":"Una vez que se complete la etapa \"ready\", se activará la función de escucha en el objeto \"watch\" asociado una vez. Luego, cuando ocurra un cambio en algún valor de los datos, se volverá a activar la función de escucha correspondiente a la clave (key) respectiva."},{"t":"h3","c":"loaded"},{"t":"p","c":"loaded es un gancho de ciclo de vida que se activa después de que se hayan cargado todas las dependencias en la plantilla del componente. Esta etapa garantiza que todas las dependencias se hayan cargado antes de renderizar el componente. En este momento, es apropiado eliminar los estilos de carga añadidos en la etapa ready."},{"t":"h3","c":"attached"},{"t":"p","c":"El gancho de ciclo de vida attached se activa cuando el componente se agrega al documento. En esta etapa, es adecuado obtener información relacionada con el tamaño de los elementos internos del componente, realizar la vinculación de datos y las operaciones de eventos globales."},{"t":"h3","c":"detached"},{"t":"p","c":"El gancho de vida detached se activa cuando el componente es removido del documento. En esta etapa, puedes realizar algunas operaciones de limpieza, como cancelar eventos o liberar recursos para evitar fugas de memoria."},{"t":"h2","c":"Demostración de ejemplo"},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo utilizar estos ganchos de ciclo de vida:"},0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"web-components":[{"t":"h1","c":"Conocimientos generales de Componentisation"},{"t":"p","c":"ofa.js es una biblioteca de encapsulamiento basada en la tecnología de Componentes Web, con el objetivo de simplificar y acelerar el proceso de desarrollo de componentes. Al ocultar los detalles técnicos complejos, permite a los desarrolladores centrarse en la construcción de componentes y aplicaciones de alta calidad."},{"t":"p","c":"Para desarrollar componentes de manera más efectiva, es necesario aprender algunos conceptos de Web Components. Los puntos de conocimiento mencionados a continuación no solo se pueden aplicar en ofa.js, sino que también te beneficiarán si estás utilizando otros marcos que utilicen Web Components."},{"t":"h2","c":"Contenedores DOM sombra"},{"t":"p","c":"En Web Components, Shadow DOM proporciona un contenedor aislado para encapsular el estilo y la estructura interna del componente. Esto significa que el estilo y la estructura DOM internos del componente no interferirán con el estilo y la estructura externos, lo que garantiza la predictibilidad y mantenibilidad del componente."},{"t":"p","c":"En ofa.js, cada componente tiene un contenedor Shadow DOM que sirve para aislar el contenido interno del componente. El contenido de la plantilla se renderiza dentro de este contenedor. Las instancias de componente obtenidas mediante $ también pueden acceder al contenedor Shadow DOM interno utilizando la propiedad shadow, lo cual permite realizar operaciones y acceder a los elementos internos del componente."},0,{"t":"h2","c":"Selectores de CSS comunes en Web Components"},{"t":"p","c":"Web Components proporciona varios selectores CSS especiales para seleccionar y dar estilo a diferentes partes internas del componente. Aquí hay algunos selectores comunes:"},{"t":"h3","c":":host selector"},{"t":"p","c":"selector:host se utiliza para seleccionar el contenedor externo del componente. Puede usar este selector para definir el estilo del componente."},0,{"t":"h3","c":"Selector ::slotted()"},{"t":"p","c":"::slotted() selector se utiliza para seleccionar elementos envueltos por el contenido del slot. Puede usar este selector en estilos internos del componente para aplicar estilos al contenido del slot."},0,{"t":"h2","c":"Uso de ranuras (Slot)"},{"t":"p","c":"Las ranuras son mecanismos utilizando en componentes web para incrustar contenido externo dentro de un componente. Las ranuras permiten a los desarrolladores pasar contenido personalizado al interior del componente, lo que permite una estructura de componente más flexible."},{"t":"h3","c":"Ranura única"},{"t":"p","c":"En la plantilla del componente, se puede usar el elemento <slot> para definir ranuras. El contenido proporcionado desde el exterior será insertado dentro de las ranuras."},0,0,{"t":"h3","c":"Múltiples ranuras con nombre"},{"t":"p","c":"Además de la ranura predeterminada, también se pueden definir varias ranuras con nombres. Las ranuras con nombres permiten a los desarrolladores insertar contenido diferente en diferentes posiciones de ranura."},0,0,{"t":"h2","c":"El uso del evento slotchange"},{"t":"p","c":"El evento slotchange se activa cuando cambia el contenido del slot. Puedes utilizar este evento para llevar a cabo algunas operaciones relacionadas con el contenido del slot."},0],"template-syntax":[{"t":"h1","c":"Sintaxis de plantilla"},{"t":"p","c":"ofa.js proporciona una serie de potentes sintaxis de plantilla que te permiten manipular de manera más flexible los elementos de interfaz y los datos de los componentes. Estas sintaxis de plantilla te ayudarán a lograr efectos de interfaz y experiencias de interacción enriquecidas."},{"t":"l","c":"- Renderización de texto: Renderiza rápidamente texto en archivos de plantilla\n- class: Renderiza rápidamente nombres de clases en archivos de plantilla\n- sync: Sincroniza rápidamente datos en archivos de plantilla\n- Renderización condicional: Renderiza contenido en archivos de plantilla según la necesidad\n- Renderización de listas: Renderiza rápidamente datos de arrays en archivos de plantilla"}]},"create-app":{"index":[{"t":"h1","c":"Introducción"},{"t":"p","c":"Además de poder desarrollar componentes, ofa.js también se puede utilizar para desarrollar aplicaciones completas."},{"t":"p","c":"ofa.js integra la aplicación como un componente o-app, lo que te permite crear rápidamente aplicaciones simplemente utilizando esta etiqueta. Este enfoque simplifica y agiliza la creación de aplicaciones."},{"t":"p","c":"Además, ofa.js también proporciona un completo esquema de enrutamiento y SSG (generación de páginas estáticas), que ayuda a los desarrolladores a construir aplicaciones más robustas. Estas funcionalidades aceleran el proceso de desarrollo, permitiéndote centrarte en la lógica de la aplicación y la experiencia del usuario, sin tener que preocuparte demasiado por los detalles subyacentes."},0,{"t":"p","c":"El siguiente es un ejemplo de código de tutorial de aplicación simple; a continuación se explicará el proceso de desarrollo de la aplicación paso a paso."}],"page":[{"t":"h1","c":"Usar el componente o-page"},{"t":"p","c":"En el interior de ofa.js, construimos un componente personalizado llamado \"o-page\" que proporciona conveniencia para el desarrollo de páginas. Este componente desempeña un papel clave en el desarrollo de aplicaciones. Cuando quieres utilizar la sintaxis de plantilla del componente pero no quieres crear un componente completamente nuevo, el componente \"o-page\" será tu mejor opción."},{"t":"h2","c":"Módulos de página"},{"t":"p","c":"Crear un módulo de página de archivo único es similar a crear un módulo de componente. Utiliza la etiqueta template para envolver el código de plantilla de la página y agrega el atributo page. Dentro de esta etiqueta, puedes utilizar libremente la sintaxis de plantilla para interactuar con otros componentes o módulos de página."},0,{"t":"p","c":"En un archivo HTML, usa el atributo src de la etiqueta o-page para especificar la ruta del archivo del módulo de la página. El contenido de la página se renderizará dentro de este componente."},0,{"t":"h2","c":"Modo de archivo dual"},{"t":"p","c":"El modo de doble archivo separa las 'Plantillas estáticas' y el 'Código lógico' para que el contenido de la página sea más claro."},{"t":"p","c":"A continuación se presentan los pasos para utilizar el componente o-page y los módulos de página."},{"t":"l","c":"1. Crear el módulo de la página:"},{"t":"p","c":"Al igual que con la creación de un módulo de componente, se puede crear un módulo de página, pero se debe configurar la propiedad type como $.PAGE. Los parámetros disponibles para el módulo de página incluyen temp, data, proto y watch."},0,{"t":"l","c":"2. Crear plantillas de página:"},{"t":"p","c":"En el mismo directorio que el módulo de la página, crea un archivo de plantilla de página llamado my-page-template.html. En este archivo de plantilla, puedes usar la sintaxis de la plantilla para la interacción, similar a la sintaxis de la plantilla de componente mencionada anteriormente."},0,{"t":"p","c":"En su archivo HTML, use la etiqueta <o-page> para utilizar el componente o-page y use el atributo src para hacer referencia a la ruta del archivo del módulo de la página. El contenido de la página se renderizará dentro de este componente."},0,{"t":"p","c":"De esta manera, cuando abres la página, el componente 'o-page' cargará dinámicamente el módulo de página 'my-page.mjs' y renderizará el contenido de la página según la plantilla y los datos en el módulo. El ciclo de vida del módulo de página y la sintaxis de la plantilla son consistentes con el módulo de componente, lo que hace que el desarrollo y la gestión de la página sean más uniformes y flexibles."}],"app":[{"t":"h1","c":"Uso del componente o-app"},{"t":"p","c":"Para crear una ventana de aplicación completa fácilmente, puedes usar la etiqueta o-app. A continuación se muestra cómo crear una aplicación y configurarla paso a paso:"},{"t":"p","c":"El texto parece un poco aburrido, le recomendamos que vaya a Demostración de casos de uso de aplicaciones para probarlo en la práctica;"},{"t":"h2","c":"Código base"},{"t":"p","c":"Cree un archivo HTML y configure la etiqueta o-app como la ventana de visualización de la aplicación. Asegúrese de establecer el estilo de pantalla completa para o-app para que la aplicación ocupe toda la ventana de visualización."},0,{"t":"l","c":"2. Crea un módulo \"es\" para configurar los datos de la aplicación. Los datos de configuración incluyen las siguientes opciones:\n\n   - home: Tipo de cadena, la dirección del módulo de la página de inicio de la aplicación.\n   - loading: Tipo de función, esta función se ejecutará cuando la aplicación cargue una nueva página, y el contenido resultante se insertará en la aplicación como una indicación de carga. Se eliminará automáticamente una vez que la página se haya cargado por completo.\n   - fail: Tipo de función, esta función se ejecutará cuando la aplicación falle al cargar una página, y el valor resultante se mostrará en la aplicación como un mensaje de carga fallida. La función contendrá la dirección \"src\" de la página de carga fallida y el objeto de error.\n   - pageAnime: Configuración de animación al cambiar entre páginas."},{"t":"p","c":"A continuación se muestra un ejemplo de datos de configuración de la aplicación:"},0,{"t":"l","c":"3. Utilice la etiqueta o-app en el archivo HTML y referencie el módulo de configuración de datos a través del atributo src."},0,{"t":"p","c":"A través de los pasos anteriores, has creado exitosamente una ventana de aplicación que utiliza el componente \"o-app\". El componente \"o-app\" cargará la página según la configuración de los datos, mostrando un mensaje de carga o un mensaje de error en caso de fallo, y también admite animaciones de cambio de página. De esta manera, puedes construir rápidamente una aplicación completamente funcional e interactiva."},{"t":"h2","c":"Saltos de ruta"},{"t":"p","c":"En la aplicación o-app, puedes realizar fácilmente la navegación de rutas, saltando de un módulo de página a otro. A continuación se presentan algunas formas diferentes de realizar la navegación de rutas."},{"t":"h3","c":"Utilice la etiqueta <a> para la navegación de ruta."},{"t":"p","c":"Puedes utilizar la etiqueta <a> en el HTML de la página para realizar redirecciones de enrutamiento. Debes especificar el atributo href con la ruta al módulo de la página de destino, y agregar el atributo olink para indicar al componente o-app que se trata de un enlace de enrutamiento."},0,{"t":"h3","c":"goto"},{"t":"p","c":"Puedes usar el atributo on:click en la plantilla de la página para vincular eventos de clic y llamar al método goto en el módulo para la navegación de ruta."},0,{"t":"p","c":"o directamente descargados en el elemento de destino:"},0,{"t":"h3","c":"Sustitución de páginas de salto y retorno"},{"t":"p","c":"Además del método goto, o-app también admite los métodos replace y back."},{"t":"l","c":"- El método replace se utiliza para sustituir una redirección, reemplazando la ruta actual de la página y convirtiendo la nueva página en la ruta actual."},0,{"t":"p","c":"El método back se utiliza para volver a la página anterior."},0,{"t":"p","c":"El componente mantendrá su estado de enrutamiento dentro de la aplicación, pero los datos de enrutamiento no estarán vinculados a la pestaña del navegador actual. De esta manera, puedes implementar fácilmente la navegación entre páginas en la aplicación."},{"t":"p","c":"Si desea vincular rutas y páginas, puede utilizar el componente o-router, que será detallado en las secciones siguientes."},{"t":"p","c":"Por medio de los métodos anteriores, puedes implementar una navegación flexible en la aplicación o-app, permitiendo a los usuarios explorar fácilmente diferentes contenidos de las páginas."},{"t":"h2","c":"Acceso a la aplicación y a la página actual"},{"t":"p","c":"En cada elemento dentro de la aplicación (incluyendo componentes), puedes obtener la instancia de o-app a través del atributo app. Esto es muy útil para realizar operaciones que interactúen con toda la aplicación."},{"t":"p","c":"Utilizando la propiedad app.current, puedes obtener la dirección del módulo de página actualmente activo."},{"t":"p","c":"A continuación se muestra un ejemplo de uso:"},0,{"t":"p","c":"En el ejemplo anterior, se obtuvo la etiqueta de la aplicación mediante el selector .app, y luego se obtuvo la dirección de la página actualmente activa accediendo a la propiedad app.current."},{"t":"h2","c":"Trucos y consejos: almacenar en caché la página siguiente por adelantado"},{"t":"p","c":"En algunos escenarios, es posible que ya sepas que el usuario va a pasar a la siguiente página. Para mejorar la experiencia del usuario, puedes precargar el módulo de la página siguiente de antemano, de modo que se pueda cargar de inmediato al realizar la navegación real, reduciendo así el tiempo de espera del usuario y brindando una experiencia más fluida."},{"t":"p","c":"En el código JavaScript de la página actual, llama al método load y pasa la ruta del módulo de la siguiente página, dicho módulo será cargado y almacenado en caché."},0],"subrouting":[{"t":"h1","c":"Patrones de subenrutamiento"},{"t":"p","c":"En ofa.js, la configuración de subrutas es ligeramente diferente a la práctica de algunos frameworks frontend. ofa.js utiliza un enfoque más intuitivo al establecer la página padres como contenedores en los módulos de la página, para cumplir con los requisitos de las subrutas."},{"t":"h2","c":"Establecer el contenedor de páginas padre"},{"t":"p","c":"Para crear una subruta, primero debes establecer el parámetro parent en el módulo de la página secundaria, indicando la dirección del módulo de la página principal. De esta manera, cuando se cargue la página secundaria, el archivo ofa.js automáticamente envolverá la página secundaria en el contenedor de la página principal."},0,{"t":"p","c":"En el ejemplo anterior, el módulo de página de la subpágina especifica la dirección del contenedor de la página padre mediante el parámetro parent."},{"t":"h2","c":"Configuración de la plantilla del contenedor de la página padre"},{"t":"p","c":"La plantilla del contenedor de la página principal debe tener un elemento <slot> para que las páginas secundarias puedan insertarse en la posición especificada en la página principal. Además, asegúrate de que el elemento contenedor del elemento <slot> esté configurado como position: relative, esto es muy importante ya que las páginas secundarias se posicionan absolutamente dentro del contenedor de la página principal."},{"t":"p","c":"A continuación se muestra un ejemplo de plantilla de contenedor de página padre."},0,{"t":"p","c":"En el ejemplo anterior, al establecer un elemento contenedor con una ranura, las subpáginas se insertarán en ese contenedor. Asegúrese de que el elemento contenedor tenga una posición relativa para que las subpáginas se puedan posicionar en función del contenedor."},{"t":"p","c":"Mediante este método, puedes configurar las subrutas de forma más intuitiva, cargando y renderizando las páginas hijas a través de la asociación entre el contenedor de la página principal y las páginas hijas."},{"t":"h2","c":"Ruta de escucha en páginas padre"},{"t":"p","c":"En algunos casos, varias páginas comparten la misma página principal como contenedor, cuando estas páginas se cambian, la página principal no se actualiza. En esta situación, la página principal aún puede escuchar los cambios en la ruta para realizar las acciones correspondientes sin refrescar la página."},{"t":"h3","c":"Listening for route changes"},{"t":"p","c":"La función routerChange puede ser configurada en el módulo de la página padre para escuchar los cambios de la ruta. Cuando ocurre un cambio de ruta en la página sin refrescarla, se activa el evento routerChange. Este evento pasa la información de la página actual y el método de dirección (type)."},{"t":"p","c":"A continuación se muestra un ejemplo de un módulo de página principal que muestra cómo configurar la función routerChange para escuchar los cambios en la ruta:"},0,{"t":"p","c":"En el ejemplo anterior, la función routerChange recibe dos parámetros, current representa la dirección actual de la página y type representa el método de navegación. Cuando se produce un cambio de ruta en la página, esta función se activará y mostrará la información correspondiente."}],"o-router":[{"t":"h1","c":"Uso del componente o-router"},{"t":"p","c":"El componente o-router es un componente usado para vincular las rutas dentro de o-app a la pestaña del navegador actual. Este componente te ayuda a gestionar las rutas de página y la visualización de una manera más conveniente."},{"t":"h2","c":"Carga del componente o-router"},{"t":"p","c":"En primer lugar, debes agregar el componente o-router en tu página. Puedes hacerlo importando el archivo router.mjs de la siguiente manera:"},0,{"t":"h2","c":"Uso del componente o-router"},{"t":"p","c":"Para utilizar el componente o-router, debe envolverlo fuera del componente o-app. De esta manera, se puede enlazar la ruta dentro de la aplicación a la pestaña actual del navegador."},0,{"t":"h2","c":"atributos fix-body"},{"t":"p","c":"\"El componente o-router también proporciona la propiedad fix-body. Cuando se establece esta propiedad, el componente agregará automáticamente estilos a la etiqueta <html> para que el tamaño de la aplicación sea igual al tamaño de la página, lo que permitirá que el contenido de la aplicación llene toda la ventana.\""},0],"scsr":[{"t":"h1","c":"Renderizado estático del cliente (SCSR)"},{"t":"h2","c":"Qué es SCSR?"},{"t":"p","c":"SCSR, cuyo nombre completo es Representación en el Lado del Cliente Estático, se refiere a la representación del lado del cliente en forma estática. La Representación del Lado del Cliente Estático (SCSR) es una variante del CSR (Representación en el Lado del Cliente) que permite que las páginas sean indexadas por los rastreadores web mientras se mantiene la experiencia del usuario del CSR."},{"t":"h2","c":"Cómo utilizar SCSR"},{"t":"p","c":"Puedes hacer referencia a la biblioteca SCSR de la siguiente manera:"},0,{"t":"h2","c":"Principio de funcionamiento de SCSR"},{"t":"p","c":"SCSR es un módulo de página que se ejecuta en modo de archivo único sin la necesidad de utilizar la etiqueta o-page, lo que permite la renderización en la página. En pocas palabras, se coloca directamente el código de la plantilla del módulo de la página dentro de o-app."},{"t":"p","c":"El siguiente es un ejemplo de SCSR que muestra cómo renderizar contenido de módulos de página directamente en la página:"},0,{"t":"p","c":"Mediante SCSR, el contenido dentro de la etiqueta template se renderizará directamente en la página, y esta parte del contenido es en realidad un módulo de página en modo de archivo único."},{"t":"p","c":"Siguiendo con el ejemplo de la página home.html mencionada anteriormente, creamos una página help:"},0,{"t":"p","c":"Después de hacer clic en \"IR A AYUDA\" en la página home.html, se realizará una transición suave a la página help.html, lo que logra un efecto de transición suave en el renderizado del lado del cliente."},{"t":"h2","c":"Nota:"},{"t":"p","c":"Todos los recursos referenciados en las páginas que utilizan el esquema SCSR, con excepción del contenido descriptivo de la página (como el título, meta descripción y palabras clave) y del contenido del plantilla de la página, deben mantenerse consistentes para garantizar una experiencia uniforme después de la navegación y actualización de la página."},{"t":"h2","c":"Acerca de los esquemas SSR"},{"t":"p","c":"El actual esquema de SCSR es en realidad más similar a un esquema de SSG (Generación de Sitio Estático), ya que renderiza las páginas como contenido estático de antemano y luego se interactúa con ellas mediante el cliente. ofa.js ya proporciona un esquema de envoltura de componentes relativamente independiente, lo que permite a los desarrolladores de frontend envolver los componentes y luego combinarlos con esquemas de renderizado de páginas tradicionales en el backend (como Node.js, Go, Java, PHP, etc.), lo que permite a los desarrolladores de backend utilizar rápidamente estos componentes envueltos para construir páginas web de alta calidad."},{"t":"p","c":"Planeamos ofrecer en el futuro una solución completa de SSR (Renderizado en el Lado del Servidor). El principio de esta solución es obtener el contenido de la siguiente página y compararlo con el contenido de la página actual para realizar operaciones dinámicas como agregar, eliminar y modificar atributos. Sin embargo, hay que tener en cuenta que este plan de SSR puede ser bastante demorado debido a las complicadas operaciones de comparación y modificación de elementos."},{"t":"p","c":"ofa.js es un marco en desarrollo y el autor tiene limitaciones de tiempo debido a sus otras responsabilidades. Aún no ha completado completamente la solución SSR para ofa.js. Sin embargo, si en el futuro ofa.js obtiene más usuarios y surge una fuerte demanda de una solución SSR, el autor continuará mejorando y desarrollando esta solución. Por ahora, el autor se centrará en la estabilidad y la expansión de las funciones del marco. También se agradece el feedback y las sugerencias de los usuarios para satisfacer mejor sus necesidades en el futuro."}]},"others":{"data-sharing":[{"t":"h1","c":"Compartir datos"},{"t":"p","c":"ofa.js difiere de otros marcos de terceros al no utilizar un modelo de gestión de estado tradicional. El autor considera que las actualizaciones de estado deben ser imperceptibles, es decir, que los cambios en los datos deben desencadenar automáticamente actualizaciones de datos."},{"t":"p","c":"La librería ofa.js tiene una excelente capacidad para compartir datos. Sus instancias se desarrollan utilizando la biblioteca de intercambio de datos Stanz. Los objetos en las instancias son sincronizables. Para lograr el intercambio de datos, simplemente crea un objeto Stanz independiente y haz que todos los componentes lo referencien directamente."},{"t":"p","c":"El siguiente ejemplo muestra cómo compartir datos:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, los dos componentes escriben datos en sí mismos durante el ciclo de vida attached. Luego, el objeto del componente se convierte en datos compartidos. Después del ciclo de vida detached, los datos compartidos anteriores se establecen como null para garantizar que se recuperen los datos."},{"t":"h2","c":"Nota:"},{"t":"p","c":"Dado que los datos se comparten, asegúrate de liberar los datos en el momento adecuado para evitar pérdidas de memoria."},0],"about-micro-frontend":[{"t":"h1","c":"Sobre Micro Frontends"},{"t":"p","c":"La microfrontend es un patrón de arquitectura frontend que tiene como objetivo ayudar a los equipos a construir y mantener aplicaciones frontend grandes y complejas. Se basa en la idea de la arquitectura de microservicios, descomponiendo la aplicación frontend en partes más pequeñas e independientes que pueden ser desarrolladas, probadas y desplegadas por diferentes equipos."},{"t":"p","c":"Durante el proceso de expansión de las aplicaciones front-end monolíticas tradicionales, puede volverse difícil mantener y ampliarlas. El objetivo de micro frontends es dividir la aplicación en módulos más pequeños y manejables, permitiendo que los equipos de desarrollo puedan desarrollar e implementar estos módulos de manera independiente, mejorando así la eficiencia del equipo y la mantenibilidad de la aplicación."},{"t":"p","c":"ofa.js tiene características nativas de microfrontend, y se diferencia de otros marcos en que los componentes, páginas y aplicaciones desarrollados con ofa.js no requieren compilación previa. En comparación con marcos como React, Vue y Angular, que necesitan ser construidos una vez en un entorno Node.js para generar el código del cliente, el código de desarrollo de ofa.js se puede colocar directamente en un servidor estático y se puede ver, usar y ejecutar en tiempo real sin pasos de construcción adicionales."},{"t":"p","c":"ofa.js se ajusta a las características del microfrontend:"},{"t":"l","c":"1. Implementación individual: Cada componente y página se pueden desarrollar, probar e implementar de forma independiente, lo que permite al equipo lanzar nuevas funciones y solucionar problemas más rápidamente.\n\n2. Integración: Las aplicaciones desarrolladas con ofa.js pueden combinar diferentes módulos. Esto se puede lograr compartiendo combinaciones a través de aplicaciones, páginas, componentes, etc.\n\n3. Equipos independientes: Cada módulo frontend (componente/página/aplicación) puede ser desarrollado y mantenido por equipos independientes, fomentando así la autonomía y la innovación del equipo.\n\n4. Recursos compartidos: En el proyecto ofa.js, generalmente hay recursos compartidos como estilos, componentes, páginas, etc., para garantizar la consistencia y la eficiencia.\n\n5. Carga a pedido: Las aplicaciones de ofa.js pueden cargar módulos según sea necesario, lo que mejora el rendimiento y la velocidad de carga de la aplicación."},{"t":"p","c":"Aunque ofa.js no puede utilizar directamente componentes desarrollados con frameworks como Vue y React, los componentes desarrollados con ofa.js pueden ser utilizados por Vue y React, lo que brinda una mayor flexibilidad y escalabilidad para desarrolladores de diferentes tecnologías."},{"t":"p","c":"Usando Componentes Web en Vue:"},{"t":"l","c":"- Wrapper de Componentes Web para Vue\n- Integración de Vue con Componentes Web\n- Cómo usar Componentes Web en Vue"},{"t":"p","c":"En React utilice Web Components:"},{"t":"l","c":"- Usar Web Components junto con React\n- Usar Web Components en React\n- Integrar Web Components en React"}]}},"api":{"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"$ es una función principal en ofa.js que se utiliza para manipular instancias de elementos del DOM. A continuación se presentan los principales usos de $:"},{"t":"h2","c":"Obtener instancias de elementos"},{"t":"p","c":"A través del método $, puedes obtener la primera instancia de elemento que cumple con un selector CSS en la página y realizar operaciones en ella. A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, usamos el símbolo $ para seleccionar una instancia de elemento con id \"target1\" y modificamos su contenido de texto estableciendo el atributo text."},{"t":"h2","c":"Ejemplo de búsqueda de elementos secundarios"},{"t":"p","c":"Las instancias también tienen un método $ que te permite obtener la primera instancia de elemento que cumple con una condición de selección en la instancia."},0,0,0,0,{"t":"h2","c":"Atributos de la instancia del elemento"},{"t":"p","c":"No inserte directamente las instancias de elementos recuperados en otros lugares, ya que esto afectará a los elementos originales. Si necesita crear una copia, puede usar el método clone."},0,0,0,0,{"t":"h2","c":"Obtener los elementos secundarios dentro de un nodo sombreado"},{"t":"p","c":"Puede obtener la instancia mediante el atributo shadow y luego obtener el elemento deseado mediante el método $;"},0,{"t":"h2","c":"Instantiation of elements"},{"t":"p","c":"Puede inicializar elementos nativos directamente en objetos de instancia $ de la siguiente manera:"},0,0,{"t":"p","c":"De esta manera, puedes convertir fácilmente los elementos HTML existentes en instancias de $ para poder utilizar las funcionalidades proporcionadas por $ para operar y procesarlos."},{"t":"h2","c":"Generación de instancias de elementos"},{"t":"p","c":"Además de obtener instancias de elementos existentes, $ también se puede utilizar para crear nuevas instancias de elementos y agregarlos a la página."},{"t":"h3","c":"Generado a partir de cadenas"},{"t":"p","c":"Puedes usar la función $ para crear nuevas instancias de elementos a partir de cadenas, como se muestra a continuación:"},0,0,0,0,{"t":"p","c":"En este ejemplo, usamos la función $ para crear una nueva instancia de elemento con un estilo y contenido de texto específico, y lo agregamos a una instancia de elemento existente con el atributo id \"target1\"."},{"t":"h3","c":"Generado a través de objetos"},{"t":"p","c":"También puedes usar la función $ para generar nuevas instancias de elementos utilizando objetos, como se muestra a continuación:"},0,0,0,0,{"t":"p","c":"En este ejemplo, estamos utilizando la función $ para definir una nueva instancia de elemento utilizando un objeto, que incluye el tipo de etiqueta, el contenido de texto y los atributos de estilo, y luego lo agregamos a una instancia de elemento existente con el id \"target1\"."}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"Con el método all, puedes obtener todos los elementos que coincidan con los selectores CSS en la página y devolverlos en un array."},0,0,0,0,{"t":"h2","c":"Obtener elementos secundarios"},{"t":"p","c":"Las instancias también tienen el método all, que permite seleccionar y obtener elementos secundarios utilizando el método all en la instancia."},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"Con la propiedad 'prev', puedes obtener la instancia del elemento anterior adyacente."},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"Mediante el atributo prevs, puedes obtener fácilmente todas las instancias de elementos adyacentes que están antes del elemento actual, y se devolverán como un array."},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"Utilizando el atributo next, puedes obtener la siguiente instancia del elemento adyacente."},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"Usando la propiedad siblings, puedes obtener fácilmente todas las instancias de los vecinos del elemento actual, que serán devueltas como un array."},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"Usando el atributo nexts, puedes obtener fácilmente todas las instancias de elementos adyacentes que están después del elemento actual, y se devolverán como un array."},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"Con el atributo parent, podemos obtener una instancia del elemento padre de la instancia;"},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"Usando el atributo parents, puedes obtener fácilmente todas las instancias de elementos padres del elemento actual, y se devolverán como un array."},0,0,0,0],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"El método clone te permite clonar y generar una instancia de elemento."},0,0,0,0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"Mediante el atributo ele, puedes obtener la instancia real del elemento, lo que te permite usar atributos y métodos nativos."},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, utilizamos la propiedad ele para obtener un elemento y modificar su contenido HTML interno, así como el nombre de etiqueta del elemento utilizado para el registro. Esto te permite realizar operaciones más complejas en el elemento utilizando métodos de JavaScript nativo."}],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"Usando el atributo shadow, puedes obtener la instancia del nodo raíz en sombra del elemento."},0,0,0,{"t":"p","c":"Es importante tener en cuenta que se debe evitar modificar directamente los elementos dentro de los nodos sombra en elementos con sintaxis de plantilla, para asegurar la consistencia y mantenibilidad de las operaciones."},{"t":"h2","c":"Obtener instancias de elementos dentro de elementos sombra de componentes desde el exterior"},{"t":"p","c":"También puede obtener instancias de elementos personalizados externamente y luego acceder a los elementos dentro del nodo sombra a través de la propiedad shadow, como se muestra a continuación:"},0],"children":[{"t":"h1","c":"Subelementos"},{"t":"p","c":"Obtener instancias de elementos secundarios es muy sencillo, simplemente tienes que tratar la instancia como un arreglo y obtener su instancia de elemento secundario mediante un número."},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"Obtener la cantidad de elementos secundarios de un elemento objetivo; como se muestra en el ejemplo anterior;"},0],"root":[{"t":"h1","c":"root"},{"t":"p","c":"Usar el atributo root para obtener el nodo raíz del elemento;"},{"t":"p","c":"En la página, el nodo raíz de los elementos comunes es una instancia de document;"},0,0,0,0,{"t":"h2","c":"Elementos dentro de los nodos sombra"},{"t":"p","c":"Debido a que los elementos dentro de un componente están aislados del entorno externo, la propiedad root de los elementos dentro del nodo sombra es el nodo raíz de la sombra;"},0,0,0],"app":[{"t":"h1","c":"app"},{"t":"p","c":"Si los elementos dentro de o-app, incluyendo los elementos dentro del nodo sombra de o-page dentro de o-app, o los componentes secundarios internos, todos tienen un atributo app que apunta a la instancia del elemento o-app."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo acceder al atributo \"app\" dentro de un elemento en o-app:"},0,{"t":"p","c":"El código es el siguiente:"},0,0,0,{"t":"p","c":"En el ejemplo anterior, el atributo 'app' del elemento 'o-app' contiene elementos dentro del elemento 'o-page' y el componente personalizado 'test-comp'. Esto significa que ambos pueden acceder a los datos y métodos del elemento 'o-app' a través del atributo 'app'."}],"host":[{"t":"h1","c":"host"},{"t":"p","c":"Usando el atributo host, puedes obtener una instancia del componente host del elemento. Esto es útil para acceder a los datos y métodos de su componente host desde el interior del componente."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo utilizar la propiedad host para obtener la instancia del componente hospedado:"},0,0,0,{"t":"p","c":"En este ejemplo, creamos un componente personalizado llamado host-demo y accedemos a su instancia del componente anfitrión dentro del componente, luego comparamos si son iguales."},{"t":"p","c":"Si el elemento no está dentro del componente, el valor de host será null. Por ejemplo:"},0,0,0,0,{"t":"p","c":"En este ejemplo, el elemento #target está fuera de cualquier componente o página dentro del body, por lo que el valor de $(\"#target\").host será null."}]},"index":[{"t":"h1","c":"API Introducción"},{"t":"p","c":"A continuación se muestra una descripción general de la API de ofa.js. Puede revisarlo primero y consultar la documentación detallada en el futuro si es necesario."},{"t":"h2","c":"Ejemplo relacionado"},{"t":"l","c":"- $: Principalmente utilizado para obtener métodos de instancia\n- all: Obtener todas las instancias relacionadas\n- prev: Obtener la instancia anterior al elemento objetivo\n- prevs: Obtener todas las instancias anteriores al elemento objetivo\n- next: Obtener la instancia siguiente al elemento objetivo\n- nexts: Obtener todas las instancias siguientes al elemento objetivo\n- siblings: Obtener todas las instancias de elementos adyacentes al elemento objetivo\n- parent: Obtener la instancia del elemento padre\n- parents: Obtener todas las instancias de los elementos padres\n- clone: Método para clonar una instancia\n- ele: Obtener el elemento nativo real de la instancia\n- shadow: Obtener el nodo raíz de sombra del componente personalizado\n- root: Obtener el nodo raíz de la instancia objetivo\n- subelemento: Obtener directamente un hijo por su índice\n- host: Obtener la instancia del elemento \"app\" objetivo"},{"t":"h2","c":"Operaciones de nodo"},{"t":"l","c":"- Agregar o eliminar nodos hijos\n- before：Agregar elementos antes de la instancia objetivo\n- after：Agregar elementos después de la instancia objetivo\n- remove：Eliminar el elemento objetivo\n- wrap：Envolver el elemento objetivo con otro elemento\n- unwrap：Quitar el elemento de envoltura de la instancia objetivo"},{"t":"h2","c":"Operaciones de atributos"},{"t":"l","c":"- text: Obtener o establecer el texto del elemento objetivo\n- html: Obtener o establecer el código HTML del elemento objetivo\n- attr: Obtener o establecer los atributos del elemento objetivo\n- css: Obtener o establecer los estilos del elemento objetivo\n- style: Obtener los estilos nativos del elemento objetivo\n- classList: Obtener la lista de clases nativas del elemento objetivo\n- data: Obtener el conjunto de datos nativos del elemento objetivo"},{"t":"h2","c":"Eventos relacionados"},{"t":"l","c":"- on: vincula un evento a un elemento objetivo\n- one: vincula un evento a un elemento objetivo de forma temporal\n- emit: activa manualmente un evento\n- off: desvincula un evento previamente vinculado"},{"t":"h2","c":"Sintaxis de plantilla"},{"t":"l","c":"- Renderizado de texto: Renderiza rápidamente texto en archivos de plantilla\n- class: Renderiza rápidamente nombres de clases en archivos de plantilla\n- sync: Sincroniza rápidamente datos en archivos de plantilla\n- Renderizado condicional: Renderiza contenido en archivos de plantilla según condiciones\n- Renderizado de listas: Renderiza rápidamente datos de arrays en archivos de plantilla"},{"t":"h2","c":"Ciclo de vida"},{"t":"l","c":"- created：El componente se crea pero no se activa cuando se renderiza el contenido.\n- ready：El componente se crea y se activa después de renderizar el contenido.\n- watch：El componente se inicializa y se activa cuando el valor cambia.\n- loaded：El componente se activa después de que los recursos internos se cargan.\n- attached：El componente se activa después de ser agregado al documento.\n- detached：El componente se activa después de ser eliminado del documento.\n- routerChange：La página principal incrustada se activa cuando cambia la ruta de la aplicación."},{"t":"h2","c":"Otros"},{"t":"l","c":"- Modelo de caja: Obtener todos los datos relacionados con el tamaño del elemento objetivo\n- formData: Vincular y obtener datos del formulario de manera conveniente\n- tag: Obtener el nombre de la etiqueta del objetivo\n- index: Obtener el orden del elemento objetivo dentro de su elemento padre\n- is: Verificar si el elemento objetivo coincide con la expresión de selector CSS\n- refresh: Actualizar activamente la interfaz del componente\n- PATH: Obtener la dirección del archivo de registro del componente o página\n- extend: Ampliar los datos o métodos de la instancia; ampliar los datos o métodos subyacentes de ofa.js;\n- Características de datos de instancia: Introducir las características de los datos subobjetos de los datos de la instancia y cómo escuchar los cambios en los datos"}],"operation":{"array-like":[{"t":"h1","c":"Añadir o eliminar elementos secundarios"},{"t":"p","c":"Las instancias de elementos tienen características similares a las de un array. Para añadir o eliminar nodos, solo se necesita utilizar los métodos de operación de arrays mencionados anteriormente. Si se utilizan los métodos \"push\", \"unshift\", \"pop\", \"shift\" o \"splice\", automáticamente se ejecutará la operación de inicialización del método [$] (../instance/dollar.md), por lo que se puede escribir directamente la cadena u objeto específico del elemento."},{"t":"p","c":"Del mismo modo, también puede utilizar otros métodos de matriz, como forEach, map, some, etc."},{"t":"p","c":"Por favor, tenga en cuenta que no debe agregar ni eliminar subelementos en elementos con sintaxis de plantilla."},{"t":"h2","c":"push"},{"t":"p","c":"Agregar un elemento secundario al final."},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"Añadir elementos secundarios al principio del array. A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"h2","c":"pop"},{"t":"p","c":"Eliminar elementos secundarios desde el final."},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"Eliminar subelementos al comienzo del array."},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"Se pueden eliminar o reemplazar elementos existentes, así como agregar nuevos elementos. Su uso es similar al método splice de una matriz. Aquí hay un ejemplo:"},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"El método before se utiliza para agregar elementos antes del elemento objetivo. Antes de realizar la operación before, se ejecuta automáticamente la operación de inicialización del método $, por lo tanto, se puede completar directamente con una cadena de elementos específicos u objetos."},{"t":"p","c":"Por favor, tenga en cuenta de no manipular los elementos con sintaxis de plantilla."},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"El método after se utiliza para añadir un elemento después del elemento de destino. La inicialización del método AAAA) se realiza automáticamente antes de la operación after, de modo que se pueden rellenar directamente cadenas u objetos de elementos específicos."},{"t":"p","c":"Por favor, tenga en cuenta de no manipular los elementos con sintaxis de plantilla."},0,0,0,0],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"El método wrap se utiliza para envolver un elemento objetivo con otro elemento. Antes de realizar la operación wrap, se realiza automáticamente la inicialización del método $, por lo que se puede ingresar directamente una cadena u objeto específico del elemento."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"h2","c":"Nota:"},{"t":"p","c":"Para que la operación de envoltura tenga éxito, el elemento objetivo debe tener un nodo padre."},0,{"t":"p","c":"Por favor, tenga en cuenta de no manipular los elementos con sintaxis de plantilla."}],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"Eliminar el nodo objetivo;"},{"t":"p","c":"Por favor, tenga en cuenta de no manipular los elementos con sintaxis de plantilla."},0,0,0,0],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"El método unwrap se utiliza para eliminar un contenedor externo de un elemento de destino."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"h2","c":"Nota:"},{"t":"p","c":"Para que la operación de envoltura tenga éxito, el elemento objetivo debe tener un nodo padre."},0,{"t":"p","c":"Tampoco es posible ejecutar unwrap cuando hay otros elementos hermanos;"},0,{"t":"p","c":"Por favor, tenga en cuenta de no manipular los elementos con sintaxis de plantilla."}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"El método text se utiliza para obtener o establecer el contenido de texto de un elemento."},{"t":"h2","c":"Uso directo"},{"t":"p","c":"Puedes acceder o establecer el contenido de texto de un elemento directamente. Aquí hay un ejemplo:"},0,0,0,0,{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Puedes usar la propiedad :text dentro de una plantilla para establecer valores de propiedad en el elemento de destino. Esto es especialmente útil en la representación de componentes. Aquí tienes un ejemplo:"},0,0,0],"html":[{"t":"h1","c":"html"},{"t":"p","c":"Establecer el código html dentro del objetivo;"},0,0,0,0,{"t":"h2","c":"Nota:"},{"t":"p","c":"html es un método peligroso, si se coloca un script se ejecutará automáticamente el código javascript interno, por lo que se debe tener precaución al utilizarlo para prevenir el XSS."},{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Todavía puedes usar el atributo :html en la plantilla para establecer el valor de atributo correspondiente en el elemento objetivo. Esto es especialmente útil en la renderización de componentes. A continuación se muestra un ejemplo:"},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"La función css se utiliza para obtener o establecer los estilos de un elemento objetivo."},{"t":"h2","c":"Uso directo"},{"t":"p","c":"Puedes usar el método css para obtener o establecer el estilo de un elemento directamente. Aquí tienes un ejemplo:"},0,0,0,0,{"t":"h2","c":"Configuración completa"},{"t":"p","c":"A través del objeto css obtenido, puedes obtener los valores de estilo que se han establecido directamente en el elemento. A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"p","c":"Usando las características del objeto css, puedes ajustar rápidamente el estilo del elemento objetivo."},{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Todavía puedes establecer el estilo de los elementos de destino a través de la sintaxis de la plantilla. A continuación, se muestra un ejemplo:"},0,0,0,{"t":"h2","c":"Consejos para configurar CSS"},{"t":"p","c":"Puedes modificar una propiedad de estilo de un elemento sin afectar otras propiedades utilizando $ele.css = {...$ele.css, color:'red'}. De esta manera, puedes cambiar solo una propiedad sin tener que reescribir todo el estilo."},{"t":"h3","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, al usar { ...myElement.css, color: 'red' }, solo modificamos el estilo de color del elemento, manteniendo las demás propiedades de estilo sin cambios. Es un truco muy útil que permite modificar flexiblemente el estilo de un elemento."}],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"El método attr se utiliza para obtener o establecer los atributos de un elemento."},{"t":"h2","c":"Uso directo"},{"t":"p","c":"Puedes usar el método attr para obtener o establecer los atributos de un elemento. A continuación se muestra un ejemplo:"},0,0,0,0,{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Además, puedes usar attr:aaa=\"bbb\" dentro del modelo para establecer el atributo aaa del elemento objetivo con el valor del componente bbb. Este método es especialmente útil para renderizar componentes. A continuación se muestra un ejemplo:"},0,0,0],"style":[{"t":"h1","c":"style"},{"t":"p","c":"Utiliza la propiedad style para mantener la coherencia con el nativo;"},{"t":"p","c":"Ten en cuenta que el atributo style no puede obtener el valor real de los estilos, solo puede obtener el valor establecido en el atributo style. Aunque el método style es similar al método css, no puede realizar una anulación completa de los estilos. En comparación con css, el método style es más eficiente en cuanto a ejecución interna."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo usar style:"},0,0,0,0,{"t":"p","c":"Por favor, ten en cuenta que el método style solo obtiene y establece los valores en el atributo style, no los estilos calculados."}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"La propiedad classList se mantiene igual que la nativa."},{"t":"p","c":"Aquí hay un ejemplo que muestra cómo usar classList:"},0,0,0,0,{"t":"p","c":"La propiedad classList te permite agregar, eliminar y cambiar dinámicamente los nombres de clase para cambiar el estilo de un elemento. Para obtener más información sobre los métodos de operación, consulta classList."}],"data":[{"t":"h1","c":"data"},{"t":"p","c":"Obtener el dataset de un elemento utilizando la propiedad data y mantenerlo consistente con el dataset nativo."},0,0,0,0]},"event":{"one":[{"t":"h1","c":"one"},{"t":"p","c":"Usando el método one, puedes registrar un controlador de eventos de un solo uso para un elemento objetivo, lo que significa que el controlador de eventos se desvinculará automáticamente después de la primera activación y no se activará nuevamente."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo usar el método one para registrar un controlador de eventos de clic para un elemento de botón:"},0,0,0,0,{"t":"p","c":"En este ejemplo, hemos utilizado el método one para agregar un controlador de eventos de clic al elemento de botón. Cuando el usuario hace clic en el botón, se activará el controlador de eventos, pero luego no se volverá a activar porque se ha desvinculado."},{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Aún puedes usar la sintaxis de plantillas para vincular manejadores de eventos desechables a los elementos de destino. Aquí tienes un ejemplo:"},0,0,0,{"t":"p","c":"En este ejemplo, estamos utilizando la definición \"one:click\" en el elemento de botón para ligar un método llamado \"addCount\". Cuando el usuario hace clic en el botón, se invocará este método, pero luego no se volverá a desencadenar porque es un manejador de eventos desechable."}],"on":[{"t":"h1","c":"on"},{"t":"p","c":"Con el método on, puedes registrar controladores de eventos para elementos de destino. Esto te permite capturar e interactuar fácilmente con las operaciones del usuario."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo usar el método on para registrar un controlador de eventos de clic para un elemento de botón:"},0,0,0,0,{"t":"p","c":"En este ejemplo, estamos usando el método on para agregar un controlador de eventos a un elemento de botón. Cuando el usuario hace clic en el botón, se activa el controlador de eventos, el contador se incrementa y el resultado se muestra en la página."},{"t":"h2","c":"Uso de la sintaxis de plantilla"},{"t":"p","c":"Puedes usar la sintaxis de plantilla para vincular métodos a elementos de destino. Aquí tienes un ejemplo:"},0,0,0,{"t":"p","c":"En este ejemplo, hemos utilizado on:click para vincular un método llamado addCount en el elemento del botón. Cuando el usuario hace clic en el botón, se llama a este método, incrementando el valor del contador y mostrándolo en la página. Esto te permite asociar manipuladores de eventos con métodos de componentes para lograr una interacción más compleja."},{"t":"h2","c":"event"},{"t":"p","c":"Después del tiempo de registro, la función activada llevará el evento, manteniendo la consistencia con el evento nativo;"},0,0,0,0],"off":[{"t":"h1","c":"off"},{"t":"p","c":"El método off te permite desregistrar los controladores de eventos registrados para dejar de escuchar eventos."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo usar el método off para cancelar la escucha de eventos:"},0,0,0,0,{"t":"p","c":"En este ejemplo, hemos registrado un controlador de eventos de clic llamado f. Cuando se hace clic en el botón, el controlador de eventos muestra el número de clics en #logger. Usando el método off, cancelamos la escucha del evento cuando el número de clics alcanza 3."}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"Mediante el método emit, puedes activar eventos de manera proactiva, y los eventos activados tienen un mecanismo de burbujeo. El mecanismo de burbujeo significa que los eventos se propagan desde los elementos internos hasta los elementos externos, activándose en niveles desde el interior hacia el exterior."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo utilizar el método emit para desencadenar eventos personalizados y utilizar el mecanismo de propagación para pasar el evento a elementos exteriores:"},0,0,0,0,{"t":"p","c":"En este ejemplo, hemos registrado el mismo manejador de eventos personalizado llamado custom-event tanto para el elemento <ul> como para el elemento <li>. Cuando activamos el evento utilizando el método emit, el evento se propaga desde el elemento <li> hasta el elemento <ul>, activando así dos manejadores de eventos."},{"t":"h2","c":"Datos personalizados"},{"t":"p","c":"Al pasar el parámetro data, puedes enviar datos personalizados al controlador de eventos:"},0,0,0,0,{"t":"p","c":"En este ejemplo, hemos pasado datos personalizados al controlador de eventos a través del parámetro data. El controlador de eventos puede acceder a los datos pasados a través de event.data."},{"t":"h2","c":"No se desencadena el evento de burbujeo"},{"t":"p","c":"Si no deseas que el evento se propague, puedes añadir el parámetro bubbles: false al disparar el evento."},0,0,0,0,{"t":"p","c":"En este ejemplo, estamos utilizando el parámetro bubbles: false para disparar un evento personalizado. Este evento no se propagará hacia los elementos superiores, por lo que solo se activará el manejador de eventos del elemento <li>."},{"t":"h2","c":"Raíz de penetración"},{"t":"p","c":"Por defecto, los eventos no pueden atravesar el shadow DOM de los componentes personalizados. Pero puedes permitir que los eventos personalizados atraviesen el nodo raíz estableciendo composed: true, lo que activará elementos fuera del nodo raíz."},0,0,0,0,0,{"t":"p","c":"En este ejemplo, creamos un componente personalizado llamado composed-test, que contiene un elemento en el DOM sombreado y un botón que dispara un evento. Por defecto, los eventos no atraviesan el DOM sombreado hasta el nodo raíz. Sin embargo, al usar el parámetro composed: true al disparar el evento, permitimos que el evento atraviese hasta el nodo raíz y active elementos fuera del nodo raíz."}]},"temp-syntax":{"text-render":[{"t":"h1","c":"Renderizado de texto"},{"t":"p","c":"Puede usar la forma de dos llaves envueltas {{xxx}} en la plantilla para renderizar el texto, donde xxx es una propiedad del componente o de la página en sí. Esto le permite renderizar directamente el valor de la propiedad en la página."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo renderizar texto en una plantilla."},0,0,0,{"t":"p","c":"En este ejemplo, {{txt}} será reemplazado por el valor de la propiedad txt y se mostrará en la página."}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"Puedes cambiar rápidamente el nombre de la clase dentro de la plantilla utilizando la sintaxis de class. En class:aaa=\"bbb\", cuando la expresión bbb (o la propiedad bbb del componente en sí) sea true, se agregará la clase aaa al elemento objetivo."},{"t":"p","c":"Por favor, tenga en cuenta que el className no puede contener letras mayúsculas, por favor use \"-\" como separador."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo utilizar la sintaxis class en una plantilla para cambiar el nombre de clase de un elemento."},0,0,0,{"t":"h2","c":"Usar clase directamente"},{"t":"p","c":"Puedes usar el método class para ajustar directamente el nombre de clase de un elemento. En el siguiente ejemplo se muestra cómo usar el método class para agregar y eliminar nombres de clase dinámicamente:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero agregamos la clase \"color-red\" al elemento utilizando el método class, luego la eliminamos después de un segundo, y posteriormente añadimos la clase \"color-blue\" al elemento después de medio segundo. Esto cambiará dinámicamente el estilo del elemento objetivo."},{"t":"p","c":"Recomendamos usar la propiedad classList para manipular los nombres de clase, ya que es el método más común y estándar."}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"Vinculación bidireccional de datos de componentes mediante sintaxis de sincronización."},0,0,0,{"t":"p","c":"sync también puede vincularse a las propiedades de instancia de componentes incrustados. Consulta el ejemplo en Data binding bidireccional."}],"condition":[{"t":"h1","c":"El rendimiento condicional"},{"t":"p","c":"El renderizado condicional se consigue a través de tres componentes condicionales:"},{"t":"h2","c":"x-if"},{"t":"p","c":"El componente principal x-if es un componente de condición que requiere establecer un valor value. Si se cumple la condición del valor value, mostrará el contenido envuelto."},{"t":"h2","c":"x-if-else"},{"t":"p","c":"x-if-else puede seguir a x-if o x-if-else y necesita establecer el valor value. Si el componente de condición anterior no se cumple y su propio valor value es verdadero, se mostrará el contenido envuelto."},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else se puede agregar después de x-if o x-if-else, al final. Si ninguna de las condiciones anteriores se cumple, mostrará el contenido definido por sí mismo. No es necesario establecer un valor value."},{"t":"h2","c":"Ejemplo"},0,0,0,{"t":"p","c":"En el ejemplo, se utilizan estos componentes de renderizado condicional para seleccionar el contenido a mostrar según el valor de count. Cuando count es divisible por 3, se cumple la condición x-if y se muestra el texto en rojo; cuando (count + 1) es divisible por 3, se cumple la condición x-if-else y se muestra el texto en verde; de lo contrario, se muestra el texto en azul."}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"Utilice el componente x-fill para renderizar listas; configure el atributo value para completar los datos del array."},{"t":"p","c":"En x-fill, se pueden usar las variables especiales $index para representar el índice del elemento de la lista actual y $data para representar los datos del elemento de la lista en sí."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo usar x-fill para representar una matriz:"},0,0,0,{"t":"p","c":"En este ejemplo, usamos el componente x-fill para representar el arreglo arr y mostrar el índice y los datos en cada elemento de la lista."},{"t":"h2","c":"Lista de plantillas para representar"},{"t":"p","c":"Puedes usar el elemento de plantilla template y agregar el atributo name para personalizar las plantillas temporales dentro del componente. Al utilizar x-fill, usa el atributo name para especificar el nombre de la plantilla que se debe llenar."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo usar la representación de listas de plantillas:"},0,0,0,{"t":"p","c":"En este ejemplo, creamos una plantilla llamada \"easyLi\" y luego llenamos los datos del arreglo arr usando x-fill, mostrando el índice y el nombre de los datos en cada elemento de la lista."},{"t":"h2","c":"Representación de listas anidadas"},{"t":"p","c":"Cuando se realiza una representación de listas anidadas, a partir del segundo nivel, se debe usar una plantilla para llenarla. Este diseño se realiza con el fin de evitar que el código de representación de listas anidadas de múltiples niveles se vuelva complejo."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo realizar una representación de listas anidadas:"},0,0,0,{"t":"p","c":"En este ejemplo, tenemos un arreglo arr que contiene dos objetos. Cada objeto tiene una propiedad name y una propiedad childs que puede contener elementos anidados. Utilizamos x-fill para llenar la lista y easyLi como plantilla para renderizar los elementos. Si un elemento tiene elementos hijos, utilizamos x-if para verificar y crear una lista anidada."},{"t":"h2","c":"Recursión en la presentación de listas"},{"t":"p","c":"La renderización de plantillas también puede hacerse de forma recursiva, lo cual es muy útil para construir listas con estructura de árbol."},{"t":"p","c":"A continuación se muestra un ejemplo de cómo realizar un renderizado de lista recursiva:"},0,0,0,{"t":"p","c":"En este ejemplo, tenemos un array arr que contiene dos objetos. Cada objeto tiene una propiedad name y una propiedad childs que puede contener elementos anidados. Utilizamos x-fill para rellenar la lista y renderizamos los elementos hijos utilizando la plantilla \"easyLi\". Si un elemento tiene elementos hijos, utilizamos x-fill para renderizar de forma recursiva la lista secundaria, logrando así renderizar una lista recursiva."},{"t":"h2","c":"replace-temp"},{"t":"p","c":"A veces, cuando intentamos renderizar listas en un elemento select o una tabla, el navegador puede eliminar automáticamente el elemento <x-fill>, lo que impide que se realice correctamente el renderizado de la lista. En este caso, se puede usar el método de replace-temp para realizar el renderizado. El método consiste en establecer is=\"replace-temp\" en una etiqueta <template> y colocar esta plantilla dentro de un elemento que el navegador corrija automáticamente."},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created El gancho de ciclo de vida se activa cuando se crea el componente. En esta etapa, los datos del componente aún no se han inicializado y el contenido de la plantilla no se ha renderizado. Puedes realizar algunas operaciones de inicialización en esta etapa, o preparar datos que se utilizarán en etapas posteriores."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"El gancho de ciclo de vida ready se disparará después de que los datos y la plantilla del componente hayan sido inicializados, lo cual indica que el componente está listo. Durante esta etapa, puedes acceder a los datos del componente y la plantilla ya ha sido renderizada, por lo que puedes realizar algunas operaciones relacionadas con la interacción de la interfaz."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"Una vez que se complete la etapa \"ready\", se activará la función de escucha en el objeto \"watch\" asociado una vez. Luego, cuando ocurra un cambio en algún valor de los datos, se volverá a activar la función de escucha correspondiente a la clave (key) respectiva."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"loaded es un gancho de ciclo de vida que se activa después de que se hayan cargado todas las dependencias en la plantilla del componente. Esta etapa garantiza que todas las dependencias se hayan cargado antes de renderizar el componente. En este momento, es apropiado eliminar los estilos de carga añadidos en la etapa ready."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"El gancho de ciclo de vida attached se activa cuando el componente se agrega al documento. En esta etapa, es adecuado obtener información relacionada con el tamaño de los elementos internos del componente, realizar la vinculación de datos y las operaciones de eventos globales."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"El gancho de vida detached se activa cuando el componente es removido del documento. En esta etapa, puedes realizar algunas operaciones de limpieza, como cancelar eventos o liberar recursos para evitar fugas de memoria."},{"t":"h2","c":"Código de ejemplo"},0,0,0,0,0,{"t":"h2","c":"Diagrama del ciclo de vida"},0],"router-change":[{"t":"h1","c":"Evento routerChange"},{"t":"p","c":"El evento routerChange es un evento específico del elemento o-page y solo se activará en la página principal anidada de o-page. Este evento se activa cuando cambia la ruta de la aplicación, ya sea al navegar a una nueva página o volver a una página anterior."},{"t":"p","c":"Ofrece una forma de escuchar y responder a cambios en la ruta de la aplicación, normalmente se usa en la página principal de páginas anidadas. Cuando cambia la ruta, puedes escuchar el evento routerChange para realizar acciones correspondientes, como actualizar el contenido de la página o el estado de navegación."},{"t":"p","c":"Este evento es muy útil para construir aplicaciones con múltiples páginas anidadas, facilitando la navegación y comunicación entre las páginas."},{"t":"h2","c":"Ejemplo"},{"t":"p","c":"Ir a página anidada para ver;"}]},"others":{"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app es uno de los componentes principales en ofa.js y se utiliza para configurar y gestionar toda la aplicación. A continuación se presentan algunas propiedades y métodos clave de app:"},{"t":"h2","c":"src"},{"t":"p","c":"src atributo se utiliza para especificar la dirección exacta del módulo de configuración de parámetros de la aplicación. Para ver ejemplos detallados, consulte Ejemplos."},0,{"t":"h2","c":"current"},{"t":"p","c":"current attributeName is used to obtain the instance of the currently displayed page. This can help you access and work with the currently displayed page, such as updating its content or performing specific operations."},0,{"t":"h2","c":"goto"},{"t":"p","c":"El método goto se utiliza para acceder a una página específica. Puede pasar la dirección de la página de destino y la aplicación la cargará y mostrará. Este es un método importante para la navegación de la aplicación."},0,{"t":"h2","c":"replace"},{"t":"p","c":"El método replace es similar a goto, pero se utiliza para reemplazar la página actual en lugar de agregar una nueva página a la pila. Esto se puede utilizar para implementar la sustitución de página en lugar de la navegación en pila."},0,{"t":"h2","c":"back"},{"t":"p","c":"El método back se utiliza para regresar a la página anterior y realizar la operación de navegación. Esto llevará al usuario de vuelta a la página anterior."},0,{"t":"h2","c":"routers"},{"t":"p","c":"La propiedad routers contiene la información de configuración de enrutamiento de la aplicación. Esta es una propiedad importante que define las reglas de enrutamiento y mapeo de las páginas en la aplicación. La configuración de enrutamiento determina la navegación entre las páginas y cómo se manejan las URL."},0],"page":[{"t":"h1","c":"Componente o-page"},{"t":"p","c":"o-page es uno de los componentes principales de ofa.js, que representa una página o módulo de página independiente. A continuación se muestran algunas propiedades y métodos clave de o-page:"},{"t":"h2","c":"Atributos `src"},{"t":"p","c":"El atributo src se utiliza para especificar la dirección específica de un módulo de página. Este es un atributo clave que especifica el contenido y el comportamiento de una página, y le indica a la aplicación de dónde cargar el contenido específico de la página."},0,{"t":"h2","c":"Método goto"},{"t":"p","c":"El método \"goto\" se utiliza para saltar de la página actual a otra página. En comparación con el método \"goto\" de \"app\", el método \"goto\" de \"page\" permite utilizar direcciones relativas para navegar a otras páginas."},0,{"t":"h2","c":"Método replace"},{"t":"p","c":"El método replace se utiliza para reemplazar la página actual por otra página. Esto es similar al método replace de app, pero se realiza dentro de la página."},0,{"t":"h2","c":"Método `back"},{"t":"p","c":"El método back se utiliza para volver a la página anterior. Esto llevará al usuario a la página anterior, similar a la función de retroceso de un navegador."},0],"box":[{"t":"h1","c":"Modelos de cajas"},{"t":"p","c":"En el desarrollo web, el tamaño de los elementos es un concepto importante que incluye el área de contenido, el padding, el borde y el margen. A continuación se presentan algunas propiedades relacionadas con el tamaño de los elementos:"},{"t":"h2","c":"width"},{"t":"p","c":"width representa el ancho del área de contenido del elemento, no incluye el padding, borde y margen."},{"t":"h2","c":"height"},{"t":"p","c":"height representa la altura del área de contenido del elemento, que no incluye el relleno, el borde y el margen."},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidth representa el ancho del área de contenido visible de un elemento, incluyendo el relleno pero excluyendo los bordes y los márgenes."},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeight representa la altura del área de contenido visible de un elemento, incluyendo el relleno pero excluyendo los bordes y los márgenes."},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"El offsetWidth representa el ancho total del elemento, incluyendo el área de contenido, el relleno interno, el borde y el margen externo."},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"La propiedad offsetHeight representa la altura total del elemento, incluyendo el área de contenido, el relleno interno, los bordes y los márgenes externos."},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidth representa el ancho total del elemento, incluyendo el área de contenido."},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"El método formData se utiliza para generar datos de objetos vinculados a elementos de formularios, lo que facilita y agiliza el manejo de los elementos del formulario. Este método generará un objeto que contiene los valores de todos los elementos del formulario dentro del elemento objetivo, y este objeto reflejará en tiempo real los cambios en los elementos del formulario."},{"t":"p","c":"En el siguiente ejemplo, mostramos cómo usar el método formData para generar datos de objetos vinculados a elementos de formulario:"},0,0,0,0,{"t":"p","c":"En este ejemplo, creamos un formulario que contiene un cuadro de texto, botones de radio y un área de texto, y usamos el método formData para crear un objeto data que contiene los valores de estos elementos del formulario. También usamos el método watch para vigilar los cambios en los datos y mostrarlos en tiempo real en la página. Cuando el usuario modifica los valores de los elementos del formulario, el objeto data se actualiza automáticamente, lo que hace que el manejo de los datos sea muy simple y eficiente."},{"t":"h2","c":"Enlace de datos bidireccional"},{"t":"p","c":"La data del objeto generado también tiene la capacidad de vinculación inversa, lo que significa que cuando modificas las propiedades del objeto, los valores de los elementos del formulario relacionados también se actualizarán automáticamente. Esto es muy útil cuando se manejan datos de formularios, ya que puedes lograr fácilmente una vinculación bidireccional de los datos."},{"t":"p","c":"En el siguiente ejemplo, demostramos cómo utilizar los datos de objetos generados por el método formData, y cómo realizar una vinculación de datos inversa:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero creamos un formulario que contiene un cuadro de texto, botones de opción y un área de texto. Luego, utilizamos el método formData para generar un objeto de datos llamado data. A continuación, modificamos las propiedades del objeto data para lograr una vinculación de datos bidireccional, lo que significa que el valor de los elementos del formulario se actualizará automáticamente cuando cambien las propiedades del objeto. Esta funcionalidad de vinculación de datos bidireccional hace que la interacción con los datos del formulario sea más fácil y conveniente."},{"t":"h2","c":"Escucha de formularios específicos"},{"t":"p","c":"Por defecto, el método formData() escucha todos los elementos input, select y textarea dentro del elemento objetivo. Pero si solo deseas escuchar elementos específicos del formulario, puedes lograrlo pasando un selector CSS."},{"t":"p","c":"En el siguiente ejemplo, mostramos cómo escuchar elementos específicos del formulario pasando un selector CSS:"},0,0,0,0,{"t":"p","c":"En este ejemplo, solo queremos escuchar los elementos de formulario con class \"use-it\", por lo tanto, pasamos \".use-it\" como argumento al método formData(). De esta manera, solo los elementos de formulario con este nombre de clase serán escuchados e incluidos en el objeto de datos generado. Esto es útil para escuchar selectivamente elementos de formulario para administrar de manera más precisa tus datos de formulario."},{"t":"h2","c":"Formulario personalizado"},{"t":"p","c":"El uso de componentes de formulario personalizados es muy simple, solo necesitas agregar una propiedad de valor al componente personalizado y configurar el atributo de nombre."},{"t":"p","c":"En el siguiente ejemplo, hemos creado un componente de formulario personalizado llamado \"custom-input\". Este componente es un cuadro de texto editable que actualiza su atributo value en tiempo real cuando el texto cambia."},0,0,0,0,{"t":"p","c":"Al utilizar un componente de formulario personalizado, simplemente tienes que agregarlo a tu formulario y establecer la propiedad name requerida:"},0,{"t":"p","c":"En el ejemplo anterior, utilizamos el elemento <custom-input> y establecemos el atributo name para utilizar componentes de formulario personalizados. Luego, utilizamos el método formData() para escuchar los valores de los elementos de entrada y los componentes personalizados, de modo de obtener y procesar los datos del formulario en tiempo real. Este método te permite ampliar fácilmente tu formulario para incluir componentes personalizados y así satisfacer tus necesidades específicas."},{"t":"h2","c":"Uso de datos de formulario dentro de un ensamblado o página"},{"t":"p","c":"A veces, es posible que debas usar datos de formularios dentro de un componente o página, y necesites generar esos datos durante el ciclo de vida ready y luego vincularlos al componente."},{"t":"p","c":"En el siguiente ejemplo, mostramos cómo utilizar datos de formularios dentro de un componente personalizado. Este componente incluye un campo de texto de entrada, que actualiza los datos en el registro en tiempo real cuando se introduce contenido."},0,0,0,{"t":"p","c":"Después del ciclo de vida \"ready\" en el componente, utilizamos el método this.shadow.formData() para generar el objeto de datos del formulario fdata. Luego, utilizamos watch para detectar cambios en fdata y, cuando eso suceda, lo convertimos a una cadena JSON y actualizamos logtext para mostrar en tiempo real los datos del formulario."}],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"El atributo tag se utiliza para obtener la etiqueta de un elemento, y devuelve una cadena en minúsculas."},{"t":"p","c":"En el siguiente ejemplo, demostramos cómo usar el método tag para obtener la etiqueta de un elemento:"},0,0,0,0],"index":[{"t":"h1","c":"index"},{"t":"p","c":"El atributo index se utiliza para obtener la posición de un elemento dentro de su elemento padre. Esta posición se cuenta a partir de 0, lo que significa que la posición del primer elemento es 0, la del segundo es 1, y así sucesivamente."},{"t":"p","c":"En el siguiente ejemplo, mostramos cómo usar la propiedad index para obtener la posición de un elemento dentro de su elemento padre:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero seleccionamos un elemento <li> con la id \"target\". Luego, utilizamos el atributo index para obtener la posición de este elemento dentro de su elemento padre <ul>, que es el segundo elemento, por lo que el valor de index es 1. Después, mostramos este valor en el elemento <div> con la id \"logger\"."}],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"Actualizar la vista de renderización del componente para actualizar los datos en ocasiones en las que no se han actualizado los datos en el componente."},0,0,0],"is":[{"t":"h1","c":"is"},{"t":"p","c":"Para comprobar si un elemento cumple con una expresión;"},0,0,0,0],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"La propiedad PATH se utiliza comúnmente en componentes personalizados o en componentes de página para obtener la ubicación del archivo de registro de ese componente. Esto puede ayudarte a conocer la procedencia del componente durante el proceso de desarrollo, especialmente cuando necesitas referenciar o cargar otros archivos de recursos. Puedes utilizar la propiedad PATH para construir la ruta del archivo."},{"t":"p","c":"A continuación se muestra un ejemplo sencillo que muestra cómo usar el atributo PATH en un componente personalizado:"},0,{"t":"p","c":"En este ejemplo, seleccionamos un elemento my-comp con un id de \"myCustomComponent\" y luego obtenemos la ruta del archivo de este componente personalizado a través de la propiedad PATH. Puedes usar la variable componentPath en el script según sea necesario, por ejemplo, para construir la ruta de otros archivos de recursos o realizar otras operaciones."}],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extend es un método de alto nivel que se utiliza para extender las propiedades o métodos de una instancia;"},0,0,0,0,{"t":"h2","c":"Ampliación de la subcapa $"},{"t":"p","c":"Similar a jQuery, también puedes ampliar las propiedades o métodos de la instancia subyacente a través de fn.extend; las propiedades o métodos extendidos desde fn se aplicarán a todas las instancias;"},0,0,0,0,{"t":"h2","c":"Expansión de la sintaxis de las plantillas"},{"t":"p","c":"A través de la extensión de propiedades o funciones mediante extend, se puede mejorar la funcionalidad de la sintaxis del modelo e incluso proporcionar azúcar sintáctica exclusiva para componentes. Sin embargo, es importante tener en cuenta que se debe evitar el uso de sintaxis de modelo no oficial, ya que esto puede generar un costo de aprendizaje para los usuarios y un deterioro en la experiencia de desarrollo."},{"t":"h3","c":"Propiedades de extensión"},{"t":"p","c":"Puedes configurar una extensión en la plantilla usando :. A continuación, vamos a crear una extensión llamada red, que cambiará el color de la fuente a rojo cuando red sea igual a true."},0,0,0,0,0,{"t":"p","c":"En este ejemplo, hemos agregado un atributo red a la sintaxis de la plantilla, y cuando count % 3 no es igual a 0, el color de fuente se pondrá rojo."},{"t":"h3","c":"Métodos ampliados"},{"t":"p","c":"Puedes extender el método 'extend' para hacerlo disponible en la sintaxis de la plantilla. El nombre del método es la parte antes de los dos puntos. Aquí estamos extendiendo la sintaxis de la plantilla 'color', y los argumentos seguidos después se pasarán al método de extensión definido."},{"t":"p","c":"Este lugar tiene el atributo 'always' establecido en 'true', lo que significa que cada vez que el componente necesita refrescar la interfaz, se llamará a este método definido. Si no se establece 'always', entonces esta función de sintaxis de plantilla solo se ejecutará una vez."},{"t":"p","c":"Entre ellos, options proporciona más parámetros que pueden ayudarte a desarrollar una sintaxis de plantilla más personalizada."},0,0,0,0,0,{"t":"h2","c":"Principios de sintaxis de plantillas"},{"t":"p","c":"Hasta ahora, deberías poder entender que muchas de las sintaxis de plantillas en ofa.js se extienden mediante extend:"},{"t":"l","c":"- Los métodos class y attr se ejecutan cada vez que se actualiza la vista.\n- Las funciones de enlace on y one solo se ejecutan una vez."},{"t":"p","c":"Puedes echar un vistazo a los ejemplos siguientes para comprender mejor el principio de renderizado de plantillas en ofa.js."},0,0,0],"stanz":[{"t":"h1","c":"Características de los datos de muestra"},{"t":"p","c":"Los objetos de instancia obtenidos o creados a través de $ tienen todas las características de datos de stanz porque las instancias de $ heredan de stanz. Esto significa que puedes utilizar los métodos y características de manipulación de datos proporcionados por stanz para operar y escuchar los datos de los objetos de instancia."},0,{"t":"h2","c":"watch"},{"t":"p","c":"Los ejemplos se pueden monitorear los cambios en los valores a través del método watch; incluso si se cambian los valores de los subobjetos del objeto, también se puede monitorear el cambio a través del método watch del objeto."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra el uso de instancias $ y el método watch:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero creamos una instancia de $ llamada target y luego usamos el método watch para escuchar sus cambios. Incluso si modificamos el valor de un subobjeto del objeto, como target.bbb.child.val, el método watch puede detectar estos cambios y actualizar el contenido del elemento logger. Esto demuestra las poderosas características de la instancia de $, que te permiten monitorear fácilmente los cambios en un objeto."},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick es similar a la función watch, pero tiene una operación de throttling interna. Se ejecuta una vez en un solo hilo, por lo que puede ser más efectivo para escuchar cambios en los datos en escenarios con requisitos de rendimiento más altos."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo usar el método watchTick de la instancia $:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero creamos una instancia del objeto $ llamada target. Luego, utilizamos los métodos watch y watchTick para monitorear los cambios en el objeto. El método watch se ejecuta inmediatamente cuando los datos cambian, mientras que el método watchTick se ejecuta una vez en un solo hilo, lo que limita la frecuencia de las operaciones de monitoreo. Puede elegir usar watch o watchTick según sus necesidades para monitorear los cambios en los datos."},{"t":"h2","c":"unwatch"},{"t":"p","c":"La función unwatch se utiliza para cancelar la escucha de datos y desvincular las escuchas anteriores registradas con watch o watchTick."},{"t":"p","c":"A continuación se muestra un ejemplo que muestra cómo utilizar el método unwatch de la instancia de $:"},0,0,0,0,{"t":"p","c":"En este ejemplo, primero creamos una instancia del objeto $ llamada target. Luego registramos dos escuchas usando los métodos watch y watchTick. Después, usamos el método unwatch para cancelar las dos escuchas previamente guardadas tid1 y tid2. Esto significa que los cambios en la propiedad dentro del primer setTimeout no activarán ninguna escucha porque estas han sido canceladas."},{"t":"h2","c":"Valores que no se escuchan"},{"t":"p","c":"En la aplicación $, el nombre de las propiedades que comienzan con guión bajo _ indica que estos valores no serán monitoreados por los métodos watch o watchTick. Esto es útil para algunas propiedades temporales o privadas, ya que puedes cambiarlos libremente sin activar el monitoreo."},{"t":"p","c":"A continuación se muestra un ejemplo que demuestra cómo usar valores de atributos que comienzan con un guión bajo para evitar ser monitoreados:"},0,0,0,0,{"t":"p","c":"En este ejemplo, creamos una instancia de objeto $ llamada target y luego usamos el método watch para monitorear cambios en los valores de las propiedades. En setTimeout, intentamos cambiar el valor de la propiedad _aaa, pero este cambio no activará la escucha. Esto es muy útil cuando se necesita actualizar el valor de una propiedad sin activar la escucha."},{"t":"h2","c":"Características básicas"},{"t":"p","c":"El objeto de datos en la instancia se convertirá en una instancia de Stanz, lo que permitirá la escucha."},0,{"t":"p","c":"Podemos usar $.stanz para crear un dato Stanz que no esté vinculado a una instancia."},0,{"t":"p","c":"Estos ejemplos muestran las características básicas de establecer datos de objeto como instancia de Stanz para la escucha."},{"t":"p","c":"Para obtener más características completas, consulte stanz;"}]}}}