{"cases":{"index":[0,{"t":"h1","c":"クイックスタート"},{"t":"p","c":"開始使用するには、CDNアドレスを使用してプロジェクトofajsをプロジェクトに統合するだけです。"},0,{"t":"p","c":"これは、DOM要素の内容を変更する方法を示すシンプルな例です："},{"t":"h2","c":"説明書"},{"t":"p","c":"ofa.jsの導入により、$シンボルがグローバルスコープに登録された。 最初にマッチした要素は $('xxx') によって選択されます。ここで xxx は標準の CSS セレクタ の内容です。"},{"t":"p","c":"上記の例では、異なる id を持つ3つの要素を選択するために $ 記号を使用し、text 、 html 、および value 属性を設定してその内容を変更しました。"},{"t":"p","c":"API のドキュメントを参照して、利用可能なプロパティやメソッドを確認してください。"}],"event":[0,{"t":"h1","c":"イベント応答"},{"t":"p","c":"イベントをバインドするために、on メソッドを使用することができます。イベントは開発の中でもっとも基本的な概念であり、アプリケーションはイベントのトリガーによってフィードバックを生成し、相互作用を実現することができます。"},{"t":"p","c":"以下の例は、クリックイベントのバインド方法を示しています。"},{"t":"p","c":"この例では、$ を使用して button 要素を選択し、on メソッドを使用して click イベントにバインドしました。ボタンがクリックされると、コールバック関数がトリガーされ、target 要素のテキストコンテンツが \"こんにちは、世界！\" に変更されます。"},{"t":"p","c":"利用可能なイベントタイプについて詳しく知りたい場合は、Eventsのドキュメントを参照してください。"}],"simple-component":[0,{"t":"h1","c":"コンポーネントの作成と使用"},{"t":"p","c":"一旦ofa.jsの読み込みが完了すると、グローバルに load-module という名前のコンポーネントが登録されます。これには、略語 l-m を使用して参照することができます。使用方法は、script タグと似ており、開発したコンポーネントのアドレスを src 属性で参照します。"},{"t":"p","c":"今、私たちのコンポーネントの作成を始めましょう。最初に、コンポーネント名と同じ名前のHTMLファイルを作成してください。"},{"t":"p","c":"では、テキストを翻訳します。コンポーネントファイルで、最初に template 要素を追加し、component 属性を追加します。コンポーネントにレンダリングする必要があるコンテンツをこの template 要素の内部に配置します。最終的に、このコンテンツはコンポーネンの Shadow DOM 内にレンダリングされます。Shadow DOM は外部環境との隔離が行われ、外部環境への汚染を防ぎます。"},{"t":"p","c":"次に、l-m コンポーネントを使用して、あなたが開発したコンポーネントを参照するだけです。ページ上では、定義したコンポーネントタグを直接使用します。"},{"t":"p","c":"注意しなければいけないのは、登録されたコンポーネント名は小文字の英字と - 記号のみ使用でき、そして少なくとも - を含める必要があります。この命名規則に従う必要があります。"},{"t":"p","c":"この例を通じて、my-comp という名前のコンポーネントを作成し、別のページで使用する方法を理解することができます。また、外部のCSSファイルをリンクすることで、コンポーネントのスタイルを設定することもできます。"}],"slot":[0,{"t":"h1","c":"コンポーネントスロット"},{"t":"p","c":"テンプレートに <slot></slot> タグを追加することで、コンポーネントの使用時に、対応するコンポーネントタグ内のスロットにコンテンツを配置することができます。"},{"t":"p","c":"自定义のコンポーネントは、デフォルトでは display 属性が定義されていないため、手動でコンポーネントに定義する必要があります。コンポーネントのスタイルでは、:host セレクタを使用して、コンポーネント自体のスタイルを追加することができます。"},{"t":"p","c":"この例は、simple-btnという名前のコンポーネントを作成する方法を示しています。コンポーネントのテンプレートには、コンポーネントに内容を挿入するスロットが含まれています。 :host セレクターをコンポーネントのスタイルに追加することで、コンポーネントにスイルを追加します。別のページで、l-mコンポーネントが simple-btn コンポーネントを参照し、内容を挿入します。"}],"render-text":[0,{"t":"h1","c":"テキストレンダリング"},{"t":"p","c":"コンポーネントファイルでは、script タグを追加してコンポーネントのロジックコードを記述することができます。公開された default オブジェクトを使用して、コンポーネントのパラメータを設定することができます。"},{"t":"p","c":"その中で、 data パラメーターはコンポーネント要素のデフォルトデータを定義するために使用されます。インスタンス化が完了すると、テンプレート構文を使用できます。"},{"t":"p","c":"テキストのレンダリングは、二重の中括弧で囲まれています。すなわち {{xxx}} であり、その中の xxx はコンポーネントのプロパティ名を表します。"},{"t":"p","c":"のケースは、コンポーネント要素のval属性をレンダリングする方法を示しています："}],"attribute-transmission":[0,{"t":"h1","c":"特性伝達"},{"t":"p","c":"attrs パラメータと data パラメータは機能的に類似しています。attrs に設定されたデータは data にマージされますが、attrs のデータはコンポーネント自体の特性に反映されます。"},0,{"t":"p","c":"外部でコンポーネントを使用する場合、属性を使用してデータをコンポーネントに渡すこともできます。ただし、属性を通じて渡されるデータは文字列型である必要があります。"}],"property-transmission":[0,{"t":"h1","c":"属性振り分け"},{"t":"p","c":"属性を渡すテンプレート構文を使用することで、コンポーネントのデータをテンプレート内の要素の属性に適用することができます。"},{"t":"p","c":"要素に :name=\"key\" 属性を追加することで使用します。ここで、name は設定する対象要素の属性名であり、key はカスタムコンポーネント内で渡す属性のキー名です。"},{"t":"p","c":"前回、セレクタを使って属性を設定するを紹介しましたが、ここではプロパティを設定するためのプロパティ・パッシング構文を紹介します；"}],"get-set-comp":[0,{"t":"h1","c":"コンポーネントインスタンスの値を取得および変更する方法"},{"t":"p","c":"外部からもコンポーネントのデータを取得または変更することができます。"},{"t":"p","c":"外部コンポーネントのデータを操作する方法を示しています。"}],"bind-event":[0,{"t":"h1","c":"イベントバインディング"},{"t":"p","c":"コンポーネントの内部では、on プロパティを使用してイベントをバインドし、コンポーネントにインタラクティブな機能を持たせることができます。 ここでは、コンポーネント内でイベントをバインドして対話機能を実現する方法を示します。"},{"t":"p","c":"protoパラメーターは、コンポーネントの固有のメソッドを定義するために使用されます。これらのメソッドは、コンポーネント内で使用することも、セレクターを介してコンポーネントを取得して外部で実行することもできます。"},{"t":"p","c":"on:click=\"xxx\"の後ろには、組み込みのメソッド名または関数式を使用することができます。関数式を使用する場合、thisキーワードを明示的に書く必要はありません。変数のスコープは自動的にコンポーネント自体にバインドされます。"},{"t":"p","c":"利用可能なイベントタイプについて詳しく知りたい場合は、Eventsのドキュメントを参照してください。"}],"nested-component":[0,{"t":"h1","c":"嵌套コンポーネント"},{"t":"p","c":"全ての過剰なロジックを1つのコンポーネントに置くことは賢明な選択ではありません。代わりに、ロジックを別のコンポーネントに分割し、l-mの方法で他のコンポーネントをインポートして使用することができます。"},{"t":"p","c":"案例中、<l-m src=\"./comp-two.html\"></l-m>という記述により、CompTwoという名前のネストコンポーネントがインポートされています。"},{"t":"p","c":"ネストされたコンポーネントは、<comp-two :txt=\"val\"></comp-two> を介して使用され、現在のコンポーネントの val 属性が txt 属性としてネストされたコンポーネントに渡される。 このようにして、入れ子になったコンポーネントは渡されたデータをレンダリングに使用することができる。"},{"t":"p","c":"<comp-two></comp-two>で、私たちはプロパティを渡さずにネストされたコンポーネントを使用しています。これは、ネストされたコンポーネント自体のロジックやデザインに依存しています。"},{"t":"p","c":"どこであっても、1つのコンポーネントが正常にロードされれば、該当する名前のコンポーネントを使用することができます。 l-m コンポーネントを複数の場所で複数回使用しても、コンポーネントが複数回ロードされることはありません。この仕組みにより、コンポーネントの再利用と一貫性が保証されます。"}],"inject-host":[0,{"t":"h1","c":"inject-host コンポーネント"},{"t":"p","c":"Web Components の isolation のため、スロット内の要素のスタイルを直接変更することは困難です。この問題に対処するため、ofa.js では inject-host というコンポーネントを提供しています。inject-host コンポーネントはホスト層にスタイルを注入することで、コンポーネントの外観をより柔軟に構成することができます。"},{"t":"p","c":"注意が必要なのは、このコンポーネントを使用すると、ホストレイヤーのスタイルに影響を与える可能性があることです。そのため、スタイルの侵入時には適切な命名規則を守り、ホストのスタイルに影響を与えないようにする必要があります。"},{"t":"p","c":"例では、comp-twoコンポーネントを定義し、内部でinject-hostコンポーネントを使用してスタイルを注入しています。これにより、注入されたスタイルを使用してcomp-twoコンポーネント内の要素のスタイルを設定することができ、他のコンポーネントに影響を与えることはりません。"},{"t":"p","c":"同時、以下の内容にも特に注意が必要です。"},{"t":"l","c":"- inject-host 内に <style> タグを追加することで、コンポーネント内で特定のスタイルを定義することができます。これらのスタイルは、現在のコンポーネントの要素にのみ影響を与え、他のコンポーネントには波及しません。\n- スタイルを注入する際には、他のコンポーネントのスタイルに影響を与えないように、一般的すぎるセレクタの使用を避ける必要があります。セレクタの一意性と特異性を維持する必要があります。\n- inject-host は、外部のスタイルシートファイルも注入することができます。<link rel=\"stylesheet\" href=\"target/style.css\"> のような方法で行います。"},{"t":"p","c":"例文：対訳見本で、comp-two コンポーネント内の inject-host を使うことで、他のコンポーネントのスタイルを崩さずに、柔軟にコンポーネント内部のスタイルを設定および適用することができます。"}],"event-passing":[0,{"t":"h1","c":"イベントの伝達"},{"t":"p","c":"原生のイベントの監視以外にも、onはカスタムイベントの監視にも使用することができ、これはコンポーネント間のイベント通知に非常に重要です。カスタムイベントはemitメソッドを使用してトリガーされます。カスタムイベントをトリガーすることで、カスタムデタを受信者に渡すことができます。"},{"t":"p","c":"Shadow DOMの境界を越えてイベントをトリガーするためには、composed属性を追加する必要があります。"},{"t":"p","c":"以下是翻译的结果：以下は、ネストされたコンポーネント間でイベントを伝達する方法を学ぶための例です。"}],"sync":[0,{"t":"h1","c":"双向データバインディング"},{"t":"p","c":"ユーザーインターフェース（例：入力ボックスやカスタムコンポーネント）とデータモデルの間にリアルタイムの双方向関連を確立するには、sync構文を使用します。"},{"t":"p","c":"以下の例は、コンポーネントで sync 属性を使用して、入力ボックスとデータモデルの間で双方向データバインディングを実現する方法を示しています。"},{"t":"l","c":"- data パラメーターで、testText という名前のデータを定義し、初期値を \"I am testText\" に設定しました。\n- sync:value=\"testText\" を使用することで、入力ボックスの値と testText データの間に双方向データバインディングが確立されます。したがって、ユーザーが入力ボッスにコンテンツを入力すると、testText データがリアルタイムに更新され、その逆も同様です。\n- 同様に、sync:txt=\"testText\" を使用することで、カスタムコンポーネントの txt 属性と testText データの間に双方向データバインディングが確立されます。コンポーネントの txt 属性が変更されると、testText データがリアルタイムに更新され、その逆も同様です。"},{"t":"p","c":"データバインディングを使用することで、ユーザーインターフェースとデータモデルの間に簡単に接続を確立できます。これにより、データの変更が自動的にインターフェースに反映され、また、ユーザーの入力も即座にデータモデルに影響を与えることができます。"},{"t":"p","c":"値する注意は、データ同期は 文字列 または 数値 のみを伝送できることです。他のデータ型は伝送できません。"}],"condition":[0,{"t":"h1","c":"条件レンダリング"},{"t":"p","c":"テンプレート構文に加えて、テンプレート・コンポーネントがテンプレートに含まれている。"},0,{"t":"p","c":"条件レンダリングは、特定の条件に基づいてコンポーネントに異なる内容を動的に挿入することを可能にします。以下は、コンポーネント内で条件レンダリングを使用する方法のデモ例です。"},{"t":"p","c":"この例では、test-demoという名前のコンポーネントを作成しました。コンポーネントにはボタンが含まれており、ボタンをクリックすると count プロパティが増加します。x-if、x-else-if、x-else タグを使用して、条件付き描画のロジックを実現しました。"},{"t":"l","c":"- x-if タグは value 属性を受け入れ、条件を定義します。 value の値が true の場合、x-if 内のコンテンツが表示されます。この例では、count が偶数の場合に赤いテキストが表示されます。\n- x-else-if タグも value 属性を受け入れ、条件を定義します。前の条件がたされず、value の値が true の場合、x-else-if 内のコンテンツが表示されます。この例では、count が3の倍数の場合に青いテキストが表示されます。\n- x-else タグには value 属性は必要ありませんが、前の条件がどれも満たされない場合に内部のコンテンツが表示されます。この例では、count が偶数でも3の倍数でもない場合に緑色のテキストが表示されます。x-else は x-if の直後にも使用できます。"},{"t":"p","c":"これによって、異なる条件に基づいて動的に異なるコンテンツをレンダリングし、柔軟なインタラクションと表示効果を実現することができます。"}],"fill":[0,{"t":"h1","c":"填充レンダリング"},{"t":"p","c":"フロントエンドのフレームワークでのフォームのレンダリング（x-fill）テンプレートは、リストのレンダリングの概念に似ています。これにより、データセットに基づいて複数のマイクロコンポーネントを動的にレンダリングすることができます。"},{"t":"p","c":"埋め込みレンダリングの過程で、以下の特殊な変数を使用することができます。"},{"t":"l","c":"- $data：データを埋め込む項目を表します。$dataを操作することで、各埋め込み項目のデータを取得または変更することができます。\n- $index：現在のデータ項目のデータセット内のインデックスを表します。\n- $host：現在のコンポーネント自体を表します。コンポネントのデータを取得したり、コンポーネントのメソッドを呼び出したりする場合は、$hostを使用してコンポーネントにアクセスする必要があります。"}],"fill-temp":[0,{"t":"h1","c":"再帰的な塗りつぶしレンダリング"},{"t":"p","c":"填充レンダリングは、単独のテンプレートを使用してデータをレンダリングし、<template> 要素に name 属性を追加することができます。この方法により、ネストされたデータ構造のレンダリングが可能になり、より複雑なコンポーネントを作成することができます。"},{"t":"p","c":"x-fillを使用してレンダリングを行う場合、対応するテンプレート名をname属性に渡すだけで、独立したテンプレートの内容をレンダリングすることができます。さらに、フィルインのレンダリングは再帰的なフィルインもサポートしており、つまりテンプレート内で同じテンプレート名を使用してネストされたフィルインを実現することができます。"},{"t":"p","c":"例の中で、item という独立なテンプレートを定義し、x-fill で該当するテンプレート名を渡しています。これによって、データ内の各項目がこのテンプレートを使用してレンダリングされ、テンプレート内部でも再び同じテンプレート名を使用して再帰的な充填が行われす。この方法により、ネストされた構造を持つデータを柔軟に処理し、より複雑なコンポーネントのレンダリングが可能となります。"}],"life-cycle":[0,{"t":"h1","c":"ライフサイクル"},{"t":"p","c":"ライフサイクルフック関数は、コンポーネントの様々な段階でコードを実行する機会を提供する。 ofa.js には5つのライフサイクルフック関数があり、created、ready、watch、attached、detachedである。"},{"t":"l","c":"- created(): コンポーネントが作成されたときに呼び出されます。この時点では、まだシャドウルートがレンダリングされていません。初期設定を行うことができますが、シャドウルート内の要素にアクセスすることはできません。\n\n- ready(): シャドウルートのレンダングが完了した後に呼び出されます。通常、コンポーネントの初期化ロジックに使用されます。この段階では、シャドウルート内の要素にアクセスして操作することができ、レンダリングが完了後に実行する他の操作も実行できます。\n\n- watch: watchオブジェクトを定義してデータの変更を監視します。readyが完了すると、watchが1度トリガーされ、dataの値に対応します。その後、対応するキーの値が変更されるたびに、watch内の対応する関数がトリガーされます。\n\n- attached(): コンポーネントがドキュメントに追加されるときに呼び出されます。この時点では、外部環境とのインタラクション、例えばコンポーネントの外観の取得や共有データの初期化ロジックなどが行えます。\n\n- detached(): コンポーネントがドキュメントから削除されるときに呼び出されます。この段階では、クリーンアップ作業や外部環境とのインタラクションの解除、リソースの解放などを行うことができます。"}],"form-data":[0,{"t":"h1","c":"フォームデータ"},{"t":"p","c":"多くのアプリケーションでは、フォームデータの処理は一般的なタスクです。このプロセスを簡素化するため、ofa.jsはフォームデータの処理を2次抽象化し、formDataメソッドを提供しています。このメソッドを使用すると、フォーム要素の値をオブジェクトにマッピングし、フォーム要素の値が変更されると自動的にオブジェクトのデータが更新されるなど、簡単に行うことができます。"},{"t":"p","c":"shadow 属性を使用すると、コンポーネントの Shadow DOM のルートノードの内容を取得できます。これにより、コンポーネント内で Shadow DOM の要素やスタイルにアクセスしたり操作したりすることができます。"},{"t":"p","c":"この例では、formDataメソッドを使用して、フォームデータをオブジェクトfdataに自動マッピングする方法を示しています。これにより、fdataオブジェクトを操作してフォーム要素の値を取得または変更できるため、これらの変更は自動的に対応するフォーム要素にも同されます。"}],"use-page":[0,{"t":"h1","c":"ページコンポーネントを使用する"},{"t":"p","c":"一度、ofa.js がロードされると、グローバルに o-page という名前のページコンポーネントが自動的に追加されます。このコンポーネントは、ページモジュールをロードするために使用されます。ページモジュールは特別なコンポーネントモジュールであり、カスタムタグして登録されず、o-page コンポーネントを介してロードされます。"},{"t":"p","c":"ページモジュールは、コンポーネントモジュールに似ていますが、いくつかの違いがあります。ページモジュールでは、pageプロパティを使用してテンプレートを定義しますが、componentプロパティではありません。ページモジュールの開発ロジックは、コンポーネントジュールと同じであり、同じテンプレート構文やテンプレートコンポーネントなどを使用します。ただし、ページモジュールでは attrs 属性を使用することができません。これは、ページのパラメータは通常URL経由で渡されるためです。"},{"t":"p","c":"この例では、o-pageコンポーネントを使用してpage.htmlページモジュールをロードしている。 テンプレートは page 属性を使用してページモジュールで定義され、データを設定するためにJavaScript関数を通してオブジェクトが返される。URLからのクエリパラメータ count はページモジュールに渡され、データを初期化するために使用される。 ページ内のボタンをクリックするイベントによってデータが更新され、ページ内にレンダリングされる。"}],"use-app":[0,{"t":"h1","c":"appコンポーネントの使用"},{"t":"p","c":"ofa.js では、o-app コンポーネントを使用してアプリケーションのレイアウト構造を作成し、異なるページモジュールを読み込むことができます。o-app コンポーネント、o-page コンポーネント、およびページモジュールを使用することで、アプリケーション全体のページ造を構築し、ページ間のナビゲーションを実現することができます"},{"t":"p","c":"o-page コンポーネントが o-app 内に存在する場合、olink 属性を持つ <a> タグを使用してページ遷移を実現することができます。この遷移は現在のページに影響を与えず、o-app 内でのみ遷移が行われるため、 <iframe> を使用するのと似ています。"},{"t":"p","c":"o-page コンポーネントがo-appの中にある場合は、以下を使うこともできる："},{"t":"l","c":"- gotoメソッドを使用してページ遷移を行います。\n- backメソッドは前のページに戻ります。\n- replaceメソッドを使用して現在のページを置換する形で遷移します。"},{"t":"p","c":"o-appコンポーネントを使用すると、アプリ全体のレイアウト構造を構築し、異なるページモジュールを読み込むことができます。さらに、o-appが提供するルーティング機能により、ページ間の移動がより便利で柔軟になります。"},{"t":"p","c":"この例では、o-appコンポーネントを使用してアプリレイアウトを作成し、その中にpage1.htmlというページモジュールを読み込みます。"},{"t":"p","c":"page1.htmlのページモジュールでは、タイトルとボタンが定義されており、ボタンをクリックすると別のページモジュールであるpage2.htmlに移動します。また、olink属性を持つリンクも追加されており、リンクをクリックすると同様にpage2.htmlにナビゲートされます。"},{"t":"p","c":"page2.htmlのページモジュールでは、タイトルとボタンを定義しています。ボタンをクリックすると前のページに戻り、ページのナビゲーションが実現されます。"}],"app-config":[0,{"t":"h1","c":"アプリパラメータの設定"},{"t":"p","c":"o-appタグに外部モジュールを個別に設定することで、アプリのパラメータを設定できます。"},{"t":"p","c":"これらのパラメータはESモジュールであり、以下のパラメータを設定することができます。"},{"t":"l","c":"- home: アプリのホームページ、つまり初期ロード時に表示されるページ。\n- loading: アプリのページをクリックして遷移する際、モジュールの読み込みが完了する前に表示されるロード中のコンテンツ。ローディングコンテンツとして文字列を返すことができます。\n- pageAnime: ページの遷移時のアニメーション効果で、CSSスタイル属性を含むオブジェクトを使用します。\n  - current: ページが現在のページである場合のスタイルを表します。\n  - next: ページが入場前のスタイルを表します。\n  - previous: ページが退出する際のスタイルを表します。"},{"t":"p","c":"アプリのニーズに応じて、ホームページとローディングスタイル、ページ遷移のアニメーションなどのパラメータをカスタマイズすることで、アプリにより個性的な体験をもたらすことができます。"}],"app-loading":[0,{"t":"h1","c":"アプリのカスタムローディングを作成します。"},{"t":"p","c":"以下は o-app コンポーネントのカスタムローディングの例です。この例では、ローディングのために美しいプログレスバーを作成し、ページの読み込み中に徐々に成長し、読み込みが完了したら直ちに100％に到達し、その後、ローディング要素を削除します。"},{"t":"p","c":"以下は、お客様のアプリケーションのローディング効果をカスタマイズするためにコピーして使用できるコードです："},0,{"t":"p","c":"このコードを使用すると、ユーザーがページの切り替え中により良い体験を得ることができる、アプリに独自のローディングエフェクトを追加することができます。"}],"custom-form-element":[0,{"t":"h1","c":"自定义フォームコンポーネント"},{"t":"p","c":"使用 ofa.js，カスタムのフォーム要素コンポーネントを簡単に開発することができます。これにより、カスタムコンポーネントに value 属性を追加し、name 属性を設定するだけで、自作のコンポーネントを標準のフォーム要素として使用することができます。コンポーネトの value 属性を更新することで、フォーム要素とのインタラクションを実現することができます。"},{"t":"p","c":"formData の初期化時には、カスタムコンポーネントのセレクターの特徴をパラメータに追加する必要があります（ただし、formData メソッドのデフォルトパラメータは「\"input,select,textarea\"」です）。これにより、formData はカスタムコンポーネントと連動することができま。"},{"t":"p","c":"この例では、カスタム入力コンポーネント custom-input を使用して編集可能なテキスト入力フィールドを作成します。このコンポーネントはフォーム要素として使用され、データのやり取りに value 属性が使用されます。formData メソッドを使用する際に、パラメータとし \"input,custom-input\" を追加して、フォームデータを正しく初期化します。"}],"set404":[0,{"t":"h1","c":"404ページの設定"},{"t":"p","c":"アプリケーションの設定モジュールでは、「fail」関数を設定して、ページのロードに失敗した場合に表示されるコンテンツをカスタマイズします。"},{"t":"p","c":"この例では、ページの読み込みに失敗した場合、エラーメッセージの最初の行が表示されます。"},0],"use-hash-router":[0,{"t":"h1","c":"使用ハッシュルーター"},{"t":"p","c":"只需要使用 o-router コンポーネント、app コンポーネント内のルートを現在のウェブページと関連付けることができます。ページとルートがバインドされると、ページのルートの状態をページが再読み込みされても保持することができます。"},{"t":"p","c":"この例では、<span style='font-family: \"iconfont\"'>&#xe7cb;</span> ボタンをクリックして新しいページとして開き、試してみてください。"},0],"nested-page":[0,{"t":"h1","c":"嵌套ページ"},{"t":"p","c":"複数のアプリケーションのUIは、階層化された複数のページで構成されています。例えば、共通のトップやサイドのナビゲーションが含まれます。現在のページの親ページを示すために、parent属性を使用することができます。"},{"t":"p","c":"親ページの制作方法はコンポーネント開発に似ています。全体のフレームワークレイアウトを含むページを作成し、それから内部のサブページをslotに配置します。"},{"t":"p","c":"この例では、page1.htmlとpage2.htmlが子ページであり、layout.htmlが親ページであるネストページの作成方法を示しています。親ページのlayout.htmlにはフレームワーク全体のレイアウトが含まれており、子ページはparent属性を使用して親ページを指し示し、親ページにネスされるべきことを示しています。"},{"t":"p","c":"ページを切り替えると、 routerChange イベントが発生します。ページの初期化およびページの切り替え時には、app.current プロパティを使用して現在のページのアドレスを取得し、ページ内でタブのアクティブ状態を修正することができます。"}],"multi-nested":[0,{"t":"h1","c":"多重な入れ子のページ"},{"t":"p","c":"親ページによる複数のネストされたページ機能を使用する場合、親レベルのネストされたページモジュールに「parent」属性を設定し、その値をネストされたページモジュールのアドレスに設定するだけです。"},{"t":"p","c":"前の記事を参照してください。ネストに関連するパラメータとメソッドが提供されています。"}],"use-scsr":[0,{"t":"h1","c":"SCSRプログラムの利用"},{"t":"p","c":"この例では、<span style='font-family: \"iconfont\"'>&#xe7cb;</span> ボタンをクリックして、新しいページで開いて試してください。"},{"t":"p","c":"SCSRの完全な名前はStatic Client-Side Renderingです。これは、CSR（Client-Side Rendering）の一種であり、CSRのユーザー体験を維持しながら、ページを静的な状態で検索エンジンにクロールさせることができます。"},{"t":"p","c":"現在のウェブサイトは、SCSRプランで構築されています。"},{"t":"p","c":"SCSRは、単一ファイルモードのページモジュールを直接実行し、o-pageタグを使用せずにページ上でのレンダリングを実現します。具体的には、ページモジュールのテンプレートコードをo-app内に直接ネストします。"},{"t":"h2","c":"注意"},{"t":"p","c":"すべてのSCSRプランを採用しているページについて、タイトル、メタディスクリプション、キーワードなどのページの説明的なコンテンツとページテンプレート以外の参照されるリソースは一貫している必要があります。これにより、ページの遷移や更新後のユーザーエクペリエンスが一貫したものになります。"}],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"別名（エイリアス）を設定することにより、ユーザーは共有リソースをより便利に利用することができます。特に異なるドメイン間で共有されるコンポーネントを同一バージョンのリソースで簡単に利用するために適しています。"},{"t":"p","c":"この例では、lm.configメソッドを使用して、@obookエイリアスをhttps://cdn.jsdelivr.net/npm/obookにマッピングする別名を設定しました。これにより、@obookプレフィックスを使用すると、自動的に指定されたURLにマッピングされます。"},0,0,0,0,{"t":"p","c":"エイリアス@obookを使用することで、l-mタグ内にリソース\"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\"を導入した。これにより、クロスドメインのコンポーネントがソースアドレスを詳細に知ることなく、共有リソースにアクセスしやすくなった。 これにより、コードの保守性が向上し、ドメイン間でのリソースの共有が容易になる。"},{"t":"h2","c":"注意"},{"t":"p","c":"別名（エイリアス）を設定する際は、以下の点に注意してください。"},{"t":"l","c":"- 別名のキーは@で始まる必要があります。例えば、@exampleです。"},0,{"t":"l","c":"- 同じ名前のエイリアスを繰り返し設定しないでください。エラーが発生します。"},0],"sync-state":[0,{"t":"h1","c":"ステータスの同期"},{"t":"p","c":"時々、複数のコンポーネントのインスタンスやページ間でデータを共有する必要があり、そのためには状態同期の機能が必要です。"},{"t":"p","c":"使用 $.stanz メソッドで共有可能なデータを作成します。このデータをコンポーネントで共有する必要がある場合は、データをコンポーネントにバインドするために、コンポーネントの attached 時にバインドする必要があります。"},{"t":"p","c":"注意：デタッチされた周期でバインドされたデータをクリアする必要があります。それ以外の場合、メモリーリークが発生する可能性があります。"},{"t":"p","c":"この例では、ステート同期機能を使用してダークモードの切り替えを実現する方法を示しました。まず、$.stanzメソッドを使用して、isDarkという名前のデータオブジェクトを作成します。このオブジェクトは複数のコンポーネント間で共有することができます。異なるコンポーネントインスタンスがデータを共有し、ダークモードを切り替えることができるようになります。"}]},"docs":{"introduce":[{"t":"h1","c":"ofa.js - プログレッシブ・フロントエンド・フレームワーク"},{"t":"h2","c":"ofa.jsとは"},{"t":"p","c":"ofa.jsは、開発者が最小限のコストでフロントエンドの開発と使用のプロセスに参加できるようにするためのプログレッシブフロントエンドフレームワークです。シンプルかつパワフルなツールとAPIを提供し、フロントエンドの開発をより効率的かつ便利にします。"},{"t":"h2","c":"目的"},{"t":"h3","c":"jQueryを置き換える"},{"t":"p","c":"多くの小規模なプロジェクトでは、ReactやVueのような大規模なフレームワークを導入する必要はなく、シンプルなフロントエンドの操作にはjQueryを使用することを好むかもしれない。ofa.jsはjQuery APIを改良し、jQueryのメソッドの多くを属性に置き換えることで、多くのシナリオでofa.jsを使用することをより適切にしている。"},{"t":"h3","c":"フロントエンド開発と利用プロセスの合理化"},{"t":"p","c":"ofa.jsの目標は、煩雑なフロントエンド開発プロセスを簡略化することです。これにより、開発者は複雑なNode.js、npm、およびフレームワークなどのツールを学ぶ必要がなく、より速くフロントエンドアプリケーションを構築することができます。ofa.jsを使用すると、ライブリを1つだけインポートして開発するだけで済むような体験に戻ることができます。"},{"t":"h3","c":"銀の弾丸となるフロントエンド開発フレームワーク"},{"t":"p","c":"ofa.jsは「銀の弾」となることを目指し、さまざまなフロントエンド開発の問題を解決し、包括的な解決策を提供することを目指しています。それは単なるツールライブラリにとどまらず、包括的なフロントエンド開発フレームワークであるとも言えます。"},{"t":"h2","c":"特徴"},{"t":"h3","c":"簡単に理解できるコンポーネント開発"},{"t":"p","c":"ofa.jsで開発されたコンポーネントはほとんど学習コストがありません。ofa.jsはシンプルで直感的なAPIを提供し、開発者は素早くコンポーネントを作成および統合できます。また、コードを整理し、メンテナンスしやすくすることができます。"},{"t":"h3","c":"内蔵モジュール化、ステータス更新、およびアプリケーション統合ソリューション"},{"t":"p","c":"ofa.js内部では、モジュール化、状態更新、アプリケーションの統合などのソリューションが組み込まれており、開発者はサードパーティのライブラリやツールをさがす必要なく、複雑なフロントエンド開発タスクを完了することができます。"},{"t":"h3","c":"公式のルーティングとSSG（静的サイト生成）ソリューションを提供しています"},{"t":"p","c":"ofa.jsは、ルーティングとSSG（静的サイトジェネレータ）についても公式の解決策を提供しており、開発者がフロントエンドのルーティングをより効果的に管理し、静的なウェブサイトを生成し、アプリケーションの性能とSEOの友好度を向上させるのに役立ちます。"},{"t":"h3","c":"コードサイズの合理化"},{"t":"p","c":"ofa.jsのコードは精巧に最適化され、圧縮された.minファイルは38kb（gzipでは14kb）です。これにより、ofa.jsは効率的なフロントエンドフレームワークとなり、さまざまなネットワーク環境で高速にロードおよび使用することができます。"}],"get-started":{"index":[{"t":"h1","c":"初めての使い方"},{"t":"h2","c":"使い方"},{"t":"h3","c":"直接見積もり"},{"t":"p","c":"CDNのアドレスを使用して直接ofa.jsをページにインポートすることができます。"},0,{"t":"h3","c":"npm経由でインストールする"},{"t":"p","c":"まず、プロジェクトに ofa.js をインストールします。"},0,{"t":"p","c":"その後、ofa.jsモジュールをプロジェクトにインポートします："},0,{"t":"h3","c":"使い方"},{"t":"p","c":"資源の引用の後、ofa.js はグローバルスコープに $ のプロパティを設定します。すべての機能は $ 上にあり、後のチュートリアルでその使用法を詳しく説明します。"},{"t":"p","c":"通常の場合は、直接引用する方法で ofa.js を追加することをお勧めしますが、React や Vue などのフレームワークとの互換性を確保する場合には、npm を使用する方法が適しています。"},{"t":"h3","c":"デバッグモード"},{"t":"p","c":"ofa.jsのscriptタグにdebug属性を追加することで、デバッグモードを有効にすることができます。デバッグモードでは、ロードされたコンポーネントモジュールやページモジュールにソースマップ機能が有効になり、ソースファイルから直接デバッグすることができます。"},0,{"t":"p","c":"デバッグモードを有効にすると、コンポーネントのコードをより簡単に追跡およびデバッグできます。これは、開発プロセスでのエラーのトラブルシューティングやコードのデバッグに非常に役立ちます。"}],"hello-world":[{"t":"h1","c":"最初のケース"},{"t":"p","c":"以下は、クリックするとテキストが \"Hello World \"に変わるボタンの例である："},0,0,0,0,{"t":"p","c":"「Hello World」という太字のテキストが表示されます。"},{"t":"p","c":"今、私たちは基本的な概念を詳しく説明します。"},{"t":"h2","c":"選択器"},{"t":"p","c":"'ofa.js'を使用すると、$シンボルはグローバルスコープに登録されます。$('xxx')を使用して、条件に一致する最初の要素を選択します。ここで、xxxは標準のCSSセレクターの内容です。具体的なセレクターの内容を確認るには、リンクをクリックしてください。"},{"t":"p","c":"以下は例です。"},0,0,0,0,{"t":"p","c":"上記の場合、ページが開いてから1秒後に、pタグ、#デスク、.ロガーのテキスト内容がそれぞれ変更される。"},{"t":"h2","c":"イベントバインディング"},{"t":"p","c":"選択した要素に成功した後、要素にイベントをバインドすることができます。先述の「Hello World」の例では、idが「btn」の要素にクリックイベントをバインドしました。ボタンをクリックすると、バインドされた関数が実行されます。"},{"t":"p","c":"イベントの例 セクションをクリックして、イベントバインディングのいくつかの例を見ることができます。"},{"t":"p","c":"すべての利用可能なイベントについては、「Web Events」を参照して、完全なイベントリストを確認してください。"},{"t":"h2","c":"属性"},{"t":"p","c":"上記の2つのケースでは、 html と text の使用方法をそれぞれ示しました。"},{"t":"p","c":"htmlまたはtext属性を使用して、要素の内容を取得することもできます。以下に示すように："},0,0,0,0,{"t":"p","c":"この例では、#t1の要素内のHTMLコンテンツが #t2 と #t3 の要素に割り当てられています。"}],"elements-and-events":[{"t":"h1","c":"エレメントとイベントに関連する情報を取得する。"},{"t":"p","c":"その章では、前の章の内容を理解するために、要素の選択とイベントのバインディングに焦点を当てることを目的としています。"},{"t":"h2","c":"選択要素"},{"t":"p","c":"以前の章では、$記号を使用して要素をグローバルから取得する方法を説明しました。次に、他の要素の取得方法について説明します。"},{"t":"h3","c":"要素内の要素を検索する方法"},{"t":"h4","c":"使用 $(\"xxx\").$('xxxx') の方法を使用します。"},{"t":"p","c":"$(\"xxx\").$('xxxx') は、最初に親要素を選択し、その中で条件に合う子要素を検索する方法です。ここで、$(\"xxx\") は親要素を選択し、その後 $('xxxx') を使用してその親要素内で条件に合う子要素を検索します。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"上記の例では、最初に $(\".parent\") を使用して parent クラスを持つ親要素を選択し、次にその親要素内で $(\".child\") を使用して child クラスを持つ子要素を検索しました。その後、子要素のテキスト内容を \"Modified child element\" に変更しました。"},{"t":"h3","c":"$('xxx xxxx')を使用する。"},{"t":"p","c":"$('xxx xxxx') は、第二のセレクタ条件に一致する要素をグローバルスコープ内で検索し、これらの要素内で第一のセレクタ条件に一致する要素を検索します。この方法では、条件に一致する子要素を直接的に取得することができます。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"上記の例では、 $('div .child') を使用して child クラスを持つ子要素を検索し、子要素のテキストコンテンツを \"Modified child element\" に変更しました。"},{"t":"h3","c":"複数の要素を選択することができます。"},{"t":"h4","c":"「$.all('xxx')」を使用して、グローバルの要素を検索します。"},{"t":"p","c":"$.all('xxx')メソッドは、セレクタ条件に一致するページ内のすべての要素を検索し、それらを要素のコレクションとして返します。これにより、複数の要素を一括操作することができます。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"上記の例では、$.all(\"p\") を使用してページ内のすべての p タグ要素を検索し、一括操作を行い、テキスト内容を \"Modified Paragraph 1\"、\"Modified Paragraph 2\"、\"Modified Paragraph 3\" に変更しました。"},{"t":"h3","c":"要素内のすべての条件に一致する要素を見つける。"},{"t":"p","c":"グローバルに要素を見つけることに加えて、$('xxx').all('xxxx')を使用して、与えられた要素内からすべての適格な子要素を見つけることも可能です。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"上記の例では、まず $(\".container\") を使用して container クラスを持つ要素を検索し、それからそのコンテナ内で item クラスを持つすべての子要素を .all(\".item\") で検索し、それらに対してバルク操作を行い、テキストコンテンツを \"Modified Item 1\"、\"Modified Item 2\"、およ \"Modified Item 3\" に変更しました。"},{"t":"h2","c":"事件"},{"t":"p","c":"以前、onを使用してイベントをバインドする方法について説明しました。これから、イベントに関連するいくつかの方法を紹介します。"},{"t":"h3","c":"オフメソッドの使用ドキュメント"},{"t":"p","c":"off メソッドは、 on メソッドでバインドされたイベントハンドラを削除するために使用されます。特定のイベントのハンドラが不要になった場合には、off メソッドを使用して要素から削除し、重複実行やメモリリークを防ぐことができます。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: イベントハンドラを削除する要素を選択します。\n- eventName: 削除するイベントの名前です。\n- eventHandler: 削除するイベントハンドラです。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"ボタンがクリックされたとき、ダイアログボックスに \"Button clicked!\" と表示されます。しかし、5秒後に off メソッドを使用してクリックイベントハンドラが削除されるため、ボタンを再度クリックしてもダイアログボックスが表示されません。"},{"t":"h3","c":"one 方法の使用文書"},{"t":"p","c":"one メソッドは、イベント処理関数をバインドするためのものですが、この処理関数はイベントが最初にトリガーされたときにのみ実行されます。一度実行されると、イベント処理関数は自動的に削除され、重複したトリガーを回避します。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: イベントハンドラをバインドする要素を選択します。\n- eventName: バインドするイベントの名称です。\n- eventHandler: 実行するイベントハンドラです。"},{"t":"h4","c":"サンプル"},0,0,0,0,{"t":"p","c":"上記の例では、ボタンをクリックすると、「ボタンが1回クリックされました！」というダイアログが表示されます。しかし、最初のクリック後にイベントハンドラが削除されるため、後続のボタンクリックではダイアログが表示されません。"},{"t":"h3","c":"emit メソッドの使用ドキュメント"},{"t":"p","c":"emitメソッドは、要素にバインドされた特定のイベントを手動でトリガーするために使用されます。emitメソッドを使用すると、実際の操作を行わずにイベント処理関数を実行することができます。"},{"t":"h4","c":"语法"},0,{"t":"l","c":"- selector: イベントをトリガする要素を選択します。\n- eventName: トリガするイベントの名前。"},{"t":"h4","c":"サンプル"},0,{"t":"p","c":"上記の例では、emitメソッドを使用してボタンのクリックイベントを手動でトリガーしています。実際にボタンをクリックしていなくても、ダイアログボックスに「ボタンがクリックされました！」と表示されます。"},{"t":"p","c":"注意：emitメソッドを使用してもマウスクリックや他の実際のイベントはシミュレートされません。ただ、すでにバインドされたイベントハンドラを直接呼び出すだけです。したがって、特定の場合にイベントを発生させたい場合は、emitメソッドを使用することができす。"},{"t":"p","c":"イベントがバインドされた後、イベントのさらなる伝播（バブリング）を防止したり、イベントのデフォルトの動作をキャンセルしたりすることがあるかもしれません。次に、イベントがトリガーされた後にバブリングを禁止し、デフォルトのイベントをキャンセルする法について説明します。"},{"t":"h3","c":"イベントのバブリングを無効にする"},{"t":"p","c":"事件冒泡は、要素上のイベントが発生した場合、DOMツリーを上方向にバブリングし、親要素の同じタイプのイベントを順番にトリガすることを指します。特定の要素でイベントを処理した後、バブリングを続行させないようにするには、event.stopPropagation() メソッドを使用します。"},{"t":"p","c":"サンプルコード："},0,{"t":"p","c":"上記の例では、「Click Me」というボタンをクリックすると、「Button Clicked!」と表示されますが、「Inner Div Clicked!」と「Outer Div Clicked!」はトリガーされません。これは、ボタンのクリックイベントハンドラーでevent.stopPropagation()を呼び出して、イベントのさらなる伝播を防しているためです。"},{"t":"h3","c":"イベントのデフォルトの動作をキャンセルする"},{"t":"p","c":"いくつかの要素では、イベントがトリガーされた時にデフォルトの動作があります。たとえば、送信ボタンをクリックするとフォームが送信され、リンクをクリックするとリンク先に移動します。イベントのデフォルトの動作を阻止したい場合は、event.preventDefault() メソドを使用することができます。"},{"t":"p","c":"サンプルコード："},0,{"t":"p","c":"上記の例において、\"Submit\" ボタンをクリックした後、\"Hello, {name}! Form submission prevented.\" が表示されますが、\"Form Submitted!\" アラートはトリガーされません。これは、event.preventDefault() を呼び出すことで、フォームのデフォルトの送信動作が阻止されているためです。"}],"basic-concept":[{"t":"h1","c":"インスタンスの基本的な概念"},{"t":"p","c":"$ インスタンスは、ページ上の要素をカプセル化するためのものであり、既存の要素を選択するためだけでなく、新しい要素を直接作成して操作することもできます。この章では、新しい要素の作成方法と $ インスタンスの操作について説明します。"},{"t":"h2","c":"新しい要素を作成する"},{"t":"p","c":"インスタンス $ を使えば、例えば、新しい要素を直接作成したり、それを操作したりすることができる："},0,0,0,0,{"t":"p","c":"上記の例では、$('<div style=\"color:red\">I am text</div>')を使用して新しいdiv要素を作成し、bodyに追加しました。"},{"t":"h2","c":"子要素の取得"},{"t":"p","c":"インスタンスは、$を介して取得された場合、DOM要素とは異なり、 children属性を持ちません。ただし、配列インデックスを使用してインスタンスの直接の子要素にアクセスすることができます。"},0,0,0,0,{"t":"p","c":"上記の例では、div要素を取得し、インデックスを使用して最初の2つのp要素にアクセスしました。同時に、$div.lengthを使用して子要素の数を取得しました。"},{"t":"h2","c":"オペレーショナル・サブエレメンツ"},{"t":"p","c":"例を通じて、私たちは$インスタンスを使用して、直接配列のメソッドを使用してサブ要素を操作することもできます。例えば、pushやpopです。"},0,0,0,0,{"t":"p","c":"上記の例では、すべての p 要素の $ インスタンスを取得し、push メソッドを使用して新しい div 要素を子要素として追加し、そして pop メソッドを使用して最後の子要素を削除しました。"},{"t":"p","c":"上記の例を通じて、$ のインスタンスの基本的な操作、新しい要素の作成、子要素のアクセスと操作を理解することができます。$ のインスタンスは、ページ上の要素を操作するための便利な方法を提供しています。"}],"common-properties":[{"t":"h1","c":"よく使用するプロパティまたはメソッド"},{"t":"p","c":"「$」の例では、要素を選択する以外にも、要素の操作や検索を容易にするためのいくつかの便利な方法が提供されています。"},{"t":"p","c":"ちょっと見ておくと、必要な場合にはいつでも API ドキュメントを参照できます。"},{"t":"h2","c":"常用の属性"},{"t":"l","c":"- tag：目標のタグ名を取得します\n- ele：インスタンスの実際のネイティブ要素を取得します\n- index：ターゲット要素が親要素内での順序を取得します\n- text：ターゲット要素のテキストを取得または設定します\n- html：ターゲット要素のHTMLコードを取得または設定します\n- css：ターゲット要素のスタイルを取得または設定します\n- style：ターゲット要素のネイティブスタイルを取得します\n- classList：ターゲット要素のネイティブクラスリストを取得します\n- data：ターゲット要素のネイティブデータセットを取得します"},{"t":"h3","c":"ノードの操作"},{"t":"l","c":"- before：ターゲットインスタンスの前に要素を追加します\n- after：ターゲットインスタンスの後に要素を追加します\n- remove：ターゲット要素を削除します\n- attr：ターゲット要素のattributesを取得または設定します"},{"t":"h2","c":"重要な機能"},{"t":"l","c":"- フォームデータ：フォームデータの簡単なバインディングと取得を行います。"},{"t":"p","c":"OFA.jsのAPIについてさらに詳しく学びたい場合は、APIドキュメントを参照してください。"}]},"create-component":{"index":[{"t":"h1","c":"コンポーネントの作成と使用"},{"t":"p","c":"ofa.js は、コンポーネントを定義するために基本的な HTML と JavaScript ファイルを使用し、学習コストを減らすために新しいファイルタイプを導入しないようにしています。HTML の基礎的な知識があれば、ofa.js コンポーネントの開発と使用は簡単に行えます。"},{"t":"h2","c":"準備する前に、コンポーネントの作成手順を確認してください。"},{"t":"p","c":"コンポーネントを作成する前に、いくつかの準備作業に注意する必要があります。コンポーネントの作成には、ブラウザがリソースをリクエストする操作が関係しているため、HTMLファイルをダブルクリックして開くだけでは、\"file\"プロトコルで表示されます。\"file\"プトコルでは、JavaScriptモジュールの読み込み時にエラーが発生する可能性があります。したがって、コンポーネントを正しく表示するために、静的サーバーを準備する必要があります。"},{"t":"p","c":"Visual Studio Code エディタを使用している場合、簡単に静的サーバーをサポートするプラグインをインストールすることができます。Live Server プラグインを使用することをお勧めします。"},{"t":"p","c":"插件をインストールした後、demo.htmlファイル上で右クリックし、「Open with Live Server」を選択するだけで、プラグインはファイルを静的サーバーモードで自動的に開きます。"},{"t":"p","c":"もし他のエディタを使用している場合、NginxまたはApacheサーバーを作成することもできます。それが静的HTMLの表示をサポートしていれば、これによってコンポーネントのプレビューや開発を正常に行うことができます。"},{"t":"h2","c":"ボタングループコンポーネントを作成します"},{"t":"p","c":"下記では、シンプルボタンという名前のシンプルなボタンコンポーネントを作成します。このコンポーネントは、ネイティブのボタンよりも見た目が美しいスタイルを持ちます。"},{"t":"p","c":"最初に、simple-button.html という名前のファイルを作成し、template タグを使用して、component 属性を追加してコンポーネントとして識別します。"},{"t":"p","c":"そして、template内でコンポーネントのテンプレートコードを記述します。その後、テンプレートの内容の下に、scriptタグを追加し、コンポーネントのJavaScriptコードをそこに配置します。"},0,{"t":"p","c":"ofa.jsの導入に成功すると、load-moduleコンポーネントが自動的に登録されます。これはモジュールを宣言的に参照するためのコンポーネントで、スクリプトタグに似ています。このコンポーネントは、指定されたsrcのモジュールをプロキシしてロードし、ロードする必要あるモジュールを前処理します。この例では、テンプレートをロードしてsimple-buttonコンポーネントを登録します。"},{"t":"p","c":"load-module コンポーネントは l-m の省略形でも使用でき、コード量を減らすことができます。"},0,{"t":"p","c":"load-module コンポーネントは、カスタムの宣言的なローダーライブラリであり、さまざまな種類のファイルのサポートを拡張したり、JavaScript モジュールを中継処理したりする強力な機能を提供します。このコンポーネントは、独立したプロジェクトに分割されています。具体的な使用方法については、https://github.com/kirakiray/drill.js のドキュメントを参照してください。"},{"t":"h3","c":"デュアル・ドキュメント・モード"},{"t":"p","c":"静的テンプレートとロジックコードを分けて、コンポーネントをより明確にする、デュアルファイルモードです。"},{"t":"p","c":"ロジックコードはjsファイルに配置され、このjsは export const type = $.COMP;というようにマークされる必要があります。これにより、ページにこれがコンポーネントモジュールであることが通知されます。この分割モードでは、モジュールコードは importなどのESモジュール標準構文を使用できます。"},{"t":"p","c":"ボタンコンポーネントは2つのファイルで構成されます。"},{"t":"l","c":"1. simple-button.html: ボタンコンポーネントのHTMLテンプレートとスタイル。"},0,{"t":"l","c":"2. simple-button.mjs：ボタンコンポーネントの登録ロジックコード。"},0,{"t":"p","c":"依赖にそのコンポーネントを使用する場所では、l-mでこのモジュールをインポートします。以下は、simple-buttonを使用した例のページ（デュアルファイルモード）です。"},0],"parameter-description":[{"t":"h1","c":"コンポーネントの登録パラメータの詳細"},{"t":"p","c":"ofa.jsでは、コンポーネントモジュールで特定の登録パラメータを定義することができ、コンポーネントをより柔軟に設定することができます。以下に各登録パラメータの詳細とそれに対応する例示を示します。"},{"t":"h2","c":"基本パラメータ"},{"t":"p","c":"基本パラメータは、コンポーネントの登録の基本的な設定を示します。以下のいくつかの属性が含まれます。"},{"t":"h3","c":"tag"},{"t":"p","c":"tag は登録されたコンポーネントの名前を表します。tag 属性が定義されていない場合、登録されたコンポーネントの名前はファイル名と同じになります。"},{"t":"p","c":"例：サンプル"},0,{"t":"h3","c":"data"},{"t":"p","c":"data はオブジェクトタイプの属性であり、コンポーネントの生成後にデフォルトで追加されるカスタムデータを作成するために使用されます。"},{"t":"p","c":"例：サンプル"},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs はオブジェクト型の属性であり、data にも含まれますが、このデータは要素の属性に反映され、属性の変更はコンポーネントの data にも動的に反映されます。キーが大文字の場合、コンポーネントのプロパティに反映される際にはキャメルケースの命名に変わります。"},{"t":"p","c":"例：サンプル"},0,{"t":"h3","c":"proto"},{"t":"p","c":"コンポーネントの登録パラメータには、protoオブジェクトを追加することができます。これにより、コンポーネントのプロトタイプに追加する必要があるメソッドを定義できます。これにより、コンポーネントのインスタンスを作成する際に、これらのプロパティとメソドがインスタンスのプロトタイプに追加され、すべてのインスタンスでこれらのメソッドにアクセスして共有することができます。"},0,{"t":"h3","c":"watch"},{"t":"p","c":"watch はオブジェクトタイプのプロパティであり、data の変化を監視するためのリスナーファンクションをここに配置します。成功した場合、監視対象の値は即座に実行されます。"},{"t":"p","c":"watch で登録された関数は、1回のスレッドの変更でのみトリガされます。そのため、1つのスレッドでこの監視されている値を複数回変更しても、1回のみトリガされます。"},{"t":"l","c":"- 最初のパラメータは現在の値です。\n- 2番目のパラメータは、watchers データセットを持つオブジェクトであり、通常、watchers には1つのオブジェクトが含まれます。このオブジェクトから oldValue を取得することができます。1回のスレッドでこの監視されている値が複数回変更された場合、このデータセットには複数の変更が記録されます。"},{"t":"p","c":"例：サンプル"},0,{"t":"h3","c":"temp"},{"t":"p","c":"通常の場合、この変数を設定する必要はありません。ただし、これは分離モードで使用され、コンポーネントのテンプレートの場所を指定するために使用されます。 temp が未定義の場合、デフォルトでは現在のモジュールと同じ名前の HTML ファイルが読み込まれます。このファイルは同じディレクトリに配置する必要があります。"},{"t":"h2","c":"変数をデフォルトにマージします"},{"t":"p","c":"defaultにすべてのエクスポート変数を書くことができます。これにより、より簡単に書くことができます。"},0,{"t":"h2","c":"サンプルコード："},{"t":"p","c":"以下は完全なサンプルコードであり、基本パラメータの定義とコンポーネントのテンプレートが含まれています。"},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"あなたは default データを定義するために非同期関数を使用することもできます。これにより、コンポーネントの登録パラメータを動的に返すことができます。"},{"t":"p","c":"関数の function はオブジェクトを返します。このオブジェクトには、load、url、および query が含まれています。"},{"t":"l","c":"- load メソッドは非同期で関数を読み込むためのものであり、非同期の import と同じように使用します。const data = await load(xxx) のようにして非同期モジュールを読み込むことができます。\n- load で読み込まれたモジュールは、load-module で読み込まれたものと同じ効果あります。load メソッドは load-module コンポーネントの関数版であり、具体的な使用方法についてはhttps://github.com/kirakiray/drill.jsのドキュメントを参照してください。\n- url は現在のモジュールのファイル名です。\n- query はこのモジュールを読み込む際の URL パラメータをオブジェクトに変換したものです。"},{"t":"p","c":"以下はdefaultを使用した例です："},0,{"t":"p","c":"この例では、ofa.jsの登録パラメータを使用してコンポーネントの動作をカスタマイズする方法を示しています。これらのパラメータを適切に設定することで、さまざまなコンポーネントの要件により適応し、より柔軟なコンポーネント開発を実現することができます。"}],"life-cycle":[{"t":"h1","c":"コンポーネントのライフサイクル"},{"t":"p","c":"ofa.jsの中で、コンポーネントのライフサイクルは特定のタイミングでトリガされるフック関数です。これらのフック関数を使用すると、より詳細な制御とインタラクションが可能であり、ofa.jsには5つの主要なライフサイクルフックがあります：created、ready、watch、loaded、attachedおよびdetached。それぞれが異なるタイミングでトリガされます。"},{"t":"h2","c":"ライフサイクルフック"},{"t":"h3","c":"created"},{"t":"p","c":"created フックは、コンポーネントが作成されるときにトリガーされます。この段階では、コンポーネントのデータは初期化されておらず、テンプレートの内容もレンダリングされていません。この段階で、初期化操作を行ったり、後続の段階で使用するデータを準備たりすることができます。"},{"t":"h3","c":"ready"},{"t":"p","c":"readyの生命周期フックは、コンポーネントのデータとテンプレートが初期化された直後にトリガーされ、コンポーネントの準備が整ったことを示します。この段階では、コンポーネントのデータにアクセスすることができ、またテンプレートもレンダリングされているた、画面との相互作用に関連する操作を実行することができます。"},{"t":"p","c":"如果テンプレートに他のコンポーネントへの依存関係がある場合、この段階では依存関係の読み込みを待つことはありません。したがって、この段階ではコンポーネントにLoadingのスタイルを追加することが適していますが、依存関係の読み込みが完了してから関連する操を実行するように注意する必要があります。"},{"t":"h3","c":"watch"},{"t":"p","c":"ready フェーズが完了すると、関連付けられた watch オブジェクトのリスナー関数が一度だけトリガーされる。 その後、データの値が変更されると、対応するキーのリスナー関数が再び起動される。"},{"t":"h3","c":"loaded"},{"t":"p","c":"loaded ライフサイクルフックは、コンポーネントテンプレート内のすべての依存関係がロードされた後にトリガーされます。この段階では、コンポーネントのレンダリング前に、すべての依存関係が完全にロードされていることが保証されます。この時点では、ready フェーズで追加されたローディングスタイルを削除するのに適しています。"},{"t":"h3","c":"attached"},{"t":"p","c":"attachedライフサイクルフックは、コンポーネントがドキュメントに追加されたときにトリガーされます。この段階では、コンポーネント内の要素のサイズに関連する情報の取得、データバインディング、グローバルイベントの操作に適しています。"},{"t":"h3","c":"detached"},{"t":"p","c":"detached のライフサイクルフックは、コンポーネントがドキュメントから削除される時にトリガーされます。この段階では、イベントの監視を解除したり、リソースを解放したりして、メモリリークを防ぐためにクリーンアップ操作を実行することができます。"},{"t":"h2","c":"例示デモ"},{"t":"p","c":"以下は、これらのライフサイクルフックを使用する方法の例です："},0,{"t":"h2","c":"生命周期フローチャート"},0],"template-syntax":[{"t":"h1","c":"モデルの構文"},{"t":"p","c":"ofa.jsは、コンポーネントのインターフェース要素とデータをより柔軟に操作するための強力なテンプレート構文を提供しています。これらのテンプレート構文は、豊富なインターフェース効果とインタラクティブな体験を実現するのに役立ちます。"},{"t":"l","c":"- テキストレンダリング：テンプレートファイルにテキストを素早くレンダリングします。\n- class：テンプレートファイルにクラス名を素早くレンダリングします。\n- sync：データをテンプレートファイルに素早く同期します。\n- 条件レンダリング：必要に応じてテンプレートファイルにコンテンツをレンダリングします。\n- リストレンダリング：配列データをテンプレートファイルに素早くレンダリングします"}],"web-components":[{"t":"h1","c":"コンポーネント化ルーチン"},{"t":"p","c":"ofa.js は Web Components テクノロジーをベースにしたラッパーライブラリであり、コンポーネント開発プロセスを簡素化し、加速することを目的としています。複雑な技術の詳細を隠蔽することで、開発者が高品質なコンポーネントとアプリケーションの構築に注力できるようになります。"},{"t":"p","c":"コンポーネントをより効果的に開発するために、Web Components の知識を学ぶ必要があります。以下に紹介されている知識は、ofa.js だけでなく、他の Web Components を使用するフレームワークでも同様に役立ちます。"},{"t":"h2","c":"Shadow DOM コンテナ"},{"t":"p","c":"Web Componentsでは、Shadow DOMはコンポーネントの内部のスタイルと構造をカプセル化するための隔離されたコンテナを提供します。これにより、コンポーネントの内部のスタイルとDOMの構造が外部のスタイルと構造と干渉しないため、コンポーネントの予測可能性と保守性が保されます。"},{"t":"p","c":"ofa.jsでは、各コンポーネントにはShadow DOMコンテナがあり、コンポーネントの内部コンテンツを分離するために使用されます。 このコンテナの中にテンプレートの内容がレンダリングされます。 また、$で取得したコンポーネントインスタンスは、shadow属性を使ってコンポーネント内部のShadow DOMコンテナにアクセスすることができます。"},0,{"t":"h2","c":"Web Components における一般的なCSSセレクタ"},{"t":"p","c":"Web Componentsは、コンポーネント内の異なる部分を選択してスタイルを適用するための特別なCSSセレクタを提供します。以下は一部の一般的なセレクタです。"},{"t":"h3","c":":host セレクタ"},{"t":"p","c":":focusのセレクタは、コンポーネント自体の外部コンテナを選択するために使用されます。このセレクタを使用して、コンポーネントのスタイルを定義することができます。"},0,{"t":"h3","c":"::slotted() ピッカー"},{"t":"p","c":"::slotted()セレクタは、スロットされた内容がラップされている要素を選択するために使用されます。このセレクタをコンポーネント内のスタイルで使用して、スロットされたコンテンツにスタイルを適用することができます。"},0,{"t":"h2","c":"スロット（Slot）の使用"},{"t":"p","c":"スロットは、Web Components内でコンポーネント内に外部コンテンツを挿入するためのメカニズムです。スロットを使用すると、開発者はカスタムのコンテンツをコンポーネント内に渡して、より柔軟なコンポーネント構造を実現することができます。"},{"t":"h3","c":"単一のスロット"},{"t":"p","c":"コンポーネントのテンプレートでは、<slot> 要素を使用してスロットを定義することができます。外部から渡された内容はスロット内に挿入されます。"},0,0,{"t":"h3","c":"複数の名前つきスロット"},{"t":"p","c":"デフォルトのスロット以外にも、複数の名前付きスロットを定義することができます。名前付きスロットを使用すると、異なるコンテンツを異なるスロット位置に挿入することができます。"},0,0,{"t":"h2","c":"slotchange イベントの使用"},{"t":"p","c":"slotchangeイベントは、スロットの内容が変化した時にトリガされます。このイベントを監視して、スロットの内容に関連する操作を実行することができます。"},0]},"create-app":{"index":[{"t":"h1","c":"介绍"},{"t":"p","c":"機能豊富なアプリケーションの開発に加えて、ofa.js はコンポーネントの開発にも利用できます。"},{"t":"p","c":"ofa.js はアプリケーションを o-app コンポーネントとして統合するためのものであり、このタグを直接使用することで、アプリケーションを簡単かつ効率的に作成することができます。この方法により、アプリケーションの作成が簡単で効率的になります。"},{"t":"p","c":"また、ofa.js公式は完全なルーティングとSSG（静的サイト生成）のソリューションも提供しており、開発者がより健全なアプリケーションを構築するのを助けます。これらの機能により、開発プロセスを加速し、アプリケーションのロジックとユーザーエクスペリエスにより集中することができ、下層の詳細に過度に心配する必要はありません。"},0,{"t":"p","c":"上記は、簡単なアプリケーションチュートリアルのコード例です。次に、アプリの開発プロセスを逐次説明します。"}],"page":[{"t":"h1","c":"Pageコンポーネントの使用"},{"t":"p","c":"o-pageというカスタムコンポーネントをofa.js内で構築しました。これはページの開発を簡単にするためのものです。このコンポーネントはアプリケーション開発で重要な役割を果たします。コンポーネントのテンプレート構文を使用したいが、新しいコンポーネントを作成たくない場合、o-pageコンポーネントは最適な選択肢となります。"},{"t":"h2","c":"ページモジュール"},{"t":"p","c":"シングルファイルのページモジュールを作成する場合、コンポーネントモジュールの作成と同じです。template タグを使用してページのテンプレートコードを囲み、page 属性を追加します。このタグ内では、テンプレートの文法と他のコンポーネントやページモジュールのインタラクションを自由に行うことができます。"},0,{"t":"p","c":"HTML ファイルでは、o-page タグの src 属性を使用してページモジュールのファイルパスを指定します。コンポーネント内でページの内容がレンダリングされます。"},0,{"t":"h2","c":"デュアル・ドキュメント・モード"},{"t":"p","c":"静的テンプレートとロジックコードを分離するダブルファイルモードは、ページのコンテンツをより明確にします。"},{"t":"p","c":"以下は、o-page コンポーネントとページモジュールを使用する手順です。"},{"t":"l","c":"1. ページモジュールの作成:"},{"t":"p","c":"ページモジュールを作成する際には、コンポーネントモジュールの作成と似ていますが、type 属性を $.PAGE に設定します。ページモジュールで使用できるパラメータには、temp、data、proto、watch が含まれます。"},0,{"t":"l","c":"2. ページテンプレートの作成:"},{"t":"p","c":"同じディレクトリに my-page-template.html という名前のページテンプレートファイルを作成します。このテンプレートファイルでは、前述のコンポーネントテンプレートの文法と同様に、テンプレート文法を使用して対話型処理を行うことができます。"},0,{"t":"p","c":"あなたのHTMLファイルで、<o-page>タグを使用してo-pageコンポーネントを使用し、src属性を使用してページモジュールのファイルパスを参照します。ページのコンテンツはこのコンポーネント内でレンダリングされます。"},0,{"t":"p","c":"これにより、ページを開くと、o-pageコンポーネントがmy-page.mjsというページモジュールを動的にロードし、モジュール内のテンプレートとデータに基づいてページコンテンツをレンダリングします。ページモジュールのライフサイクルとテンプレートの文法はコンポーントモジュールと同じであり、ページの開発と管理がより統一的で柔軟になります。"}],"app":[{"t":"h1","c":"o-app コンポーネントの使用"},{"t":"p","c":"o-appタグを使用すると、簡単に完全なアプリケーションウィンドウを作成することができます。以下は、アプリケーションを作成し、設定するための手順です："},{"t":"p","c":"テキストはやや退屈に見えますが、実際に試してみるために アプリケーションの使用例デモ にアクセスすることをお勧めします。"},{"t":"h2","c":"基本コード"},{"t":"l","c":"1. HTMLファイルを作成し、o-appタグをアプリケーションの表示ウィンドウに設定します。o-appに対してフルスクリーンのスタイルを設定して、アプリケーションがビューポート全体を占有するように確認してください。"},0,{"t":"l","c":"2. esモジュールを作成し、アプリケーションの設定データを設定します。設定データには以下のオプションが含まれます：\n\n   - home：文字列型で、アプリケーションのホームページのページモジュールのアドレスです。\n   - loading：関数型で、新しいページをロードす際にこの関数が実行され、その内容がロード中のヒントとしてアプリケーションに挿入されます。ページのロードが完了すると、このloading要素は自動的に削除されます。\n   - fail：関数型で、アプリケーションのページのロードに失敗した場合にこの関数が実行され、その値がロード失敗のヒントとしてアプリケーションに表示されます。関数にはロード失敗ページのsrcアドレスとエラー報告オブジェクトが含まれます。\n   - pageAnime：ページ間の切り替え時のアニメーション設定。"},{"t":"p","c":"以下はアプリケーションの設定データの例です："},0,{"t":"l","c":"3. HTMLファイルでo-appタグを使用し、src属性を使用してesモジュールの設定データを参照します。"},0,{"t":"p","c":"以上の手順で、o-appコンポーネントを使用したアプリケーションウィンドウを作成することができました。o-appコンポーネントは、設定データに基づいてページをロードし、ローディング中のメッセージやロード失敗のメッセージを表示し、ページの切り替えアニメーションをサポートします。これにより、完全な機能を備え、インタラクティブなアプリケーションを素早く構築することができます。"},{"t":"h2","c":"ルートジャンプ"},{"t":"p","c":"o-app アプリでは、ページモジュールから別のページモジュールに簡単にルートを移動することができます。以下では、ルートの移動方法についていくつかの異なる方法を紹介します。"},{"t":"h3","c":"<a> タグを使ったジャンプのルーティング"},{"t":"p","c":"ページのHTMLで、<a>タグを使用してルーティングのリンクを実現することができます。href属性を対象ページのモジュールのパスに設定し、olink属性を追加して、o-appコンポーネントにこれがルーティングリンクであることを通知する必要があります。"},0,{"t":"h3","c":"goto"},{"t":"p","c":"ページのテンプレートで on:click 属性を使用してクリックイベントをバインドし、モジュール上の goto メソッドを呼び出してルーティングを実行できます。"},0,{"t":"p","c":"もしくは、対象の要素を直接アンインストールすることもできます。"},0,{"t":"h3","c":"替換のジャンプと戻りページ"},{"t":"p","c":"goto メソッド以外、o-app は replace メソッドと back メソッドもサポートしています。"},{"t":"p","c":"replaceメソッドは、遷移を置き換えるために使用されます。これは、現在のページのルーティングを置き換え、新しいページを現在のページのルーティングにします。"},0,{"t":"l","c":"- 前のページに戻るための back メソッドです。"},0,{"t":"p","c":"アプリ内では、コンポーネントのルート状態が保持されますが、ルートデータは現在のブラウザタブにバインドされません。これにより、アプリ内で簡単にページ間のジャンプやナビゲーションを実装することができます。"},{"t":"p","c":"もし、ルーティングとページのバインディングを実現したい場合は、o-routerコンポーネントを使用することができます。後のセクションで詳しく説明します。"},{"t":"p","c":"以上の方法を通じて、o-appアプリケーションで柔軟なルーティングの移動を実現し、ユーザーにさまざまなページコンテンツを簡単に閲覧できるようにすることができます。"},{"t":"h2","c":"アプリと現在のページへのアクセス"},{"t":"p","c":"アプリ内のすべての要素（コンポーネントを含む）は、app 属性を使用してそれらが所属する o-app インスタンスにアクセスします。これは、アプリ全体とのインタラクションが必要な操作に非常に便利です。"},{"t":"p","c":"app.currentプロパティを使用すると、現在アクティブなページモジュールのアドレスを取得できます。"},{"t":"p","c":"以下は使用例です："},0,{"t":"p","c":"上記の例では、セレクター .app でアプリタグが取得され、app.current 属性で現在のアクティブなページのアドレスが取得されます。"},{"t":"h2","c":"使い方のヒント：次のページをあらかじめキャッシュしておく"},{"t":"p","c":"次のページにユーザーがジャンプすることが予想される場合、ユーザーエクスペリエンスを向上させるために、次のページのモジュールを事前にキャッシュすることができます。これにより、実際のジャンプ時にすぐに読み込むことができ、ユーザーの待ち時間を減らしよりスムーズな体験を提供します。"},{"t":"p","c":"現在のページのJavaScriptコード内で、loadメソッドを呼び出し、次のページのモジュールパスを渡します。そのモジュールはロードされキャッシュされます。"},0],"subrouting":[{"t":"h1","c":"子ルーティングモード"},{"t":"p","c":"ofa.jsでは、サブルーティングの方法は他のフロントエンドフレームワークとは少し異なります。ofa.jsでは、より直感的な方法を使用して、ページモジュールに親ページを設定することで、コンテナとして機能し、サブルーティングの要件を実現しています。"},{"t":"h2","c":"親ページコンテナの設定"},{"t":"p","c":"子ルートを作成するためには、まず、子ページのページモジュールに parent パラメータを設定し、親ページのページモジュールのアドレスを指定する必要があります。これにより、子ページの読み込み時に、ofa.js は自動的に子ページを親ページのコンテナで囲みます。"},0,{"t":"p","c":"上述の例では、サブページのページモジュールは parent パラメータを使用して親ページコンテナのアドレスを指定しています。"},{"t":"h2","c":"父ページのコンテナテンプレートの設定"},{"t":"p","c":"父ページのコンテナのテンプレートには、<slot> 要素を設定する必要があります。これにより、子ページを親ページの指定位置に挿入できます。同時に、<slot> 要素のコンテナ要素を position: relative に設定することも重要です。なぜなら、子ページは親ページのコンテナで絶対位置に配置されるからです。"},{"t":"p","c":"以下は親ページのコンテナのサンプルテンプレートです："},0,{"t":"p","c":"上記の例では、slot を持つコンテナ要素を設定することで、サブページはそのコンテナに挿入されます。コンテナ要素に相対配置が設定されていることを確認してください。そうすれば、サブページはコンテナに基づいて配置されます。"},{"t":"p","c":"子ルートを設定するために、この方法を使用することで、親ページのコンテナと子ページの関連を設定して、子ページの読み込みと描画を実現することができます。"},{"t":"h2","c":"親ページのルートリスニング"},{"t":"p","c":"ある場合において、複数のページが同じ親ページをコンテナとして共有し、これらのページ間で移動すると親ページはリフレッシュされません。この場合、親ページはまだルートの変更を監視することができ、ページのリフレッシュなしで適切な操作を実行することがでます。"},{"t":"h3","c":"ルート変更のリスニング"},{"t":"p","c":"父ページのモジュールでは、routerChange関数を設定することができます。これは、ルートの変更を監視するために使用されます。親ページをリフレッシュせずにページのルートが変更されると、routerChangeイベントが発生します。このイベントには、現在のページの情報と移方法（type）が渡されます。"},{"t":"p","c":"以下は親ページのモジュールの例であり、routerChange 関数を設定してルートの変更を監視する方法を示しています。"},0,{"t":"p","c":"上記の例では、「routerChange」関数は2つの引数を受け取ります。「current」は現在のページのアドレスを示し、「type」は遷移方法を示します。ページのルーティングが切り替わると、この関数がトリガーされ、対応する情報が出力されます。"}],"o-router":[{"t":"h1","c":"o-routerコンポーネントの使用"},{"t":"p","c":"o-router コンポーネントは、o-app 内のルートを現在のブラウザのタブにバインドするためのコンポーネントです。これを使用すると、ページのルートと表示をより簡単に管理することができます。"},{"t":"h2","c":"o-routerコンポーネントのロード"},{"t":"p","c":"まず、ページで o-router コンポーネントを参照する必要があります。以下の方法で router.mjs ファイルを参照することができます："},0,{"t":"h2","c":"o-router コンポーネントの使用"},{"t":"p","c":"使用 o-router 组件は、o-app コンポーネントの外側にラップすることで実現されます。これにより、アプリ内のルーターが現在のブラウザータブにバインドされます。"},0,{"t":"h2","c":"fix-body 属性"},{"t":"p","c":"o-routerコンポーネントは、fix-body属性を提供しており、この属性を設定すると、コンポーネントは自動的に<html>タグにスタイルを追加し、アプリケーションのサイズをページ全体と同じにして、アプリケーションの内容をウィンドウ全体で表示します。"},0],"scsr":[{"t":"h1","c":"静的クライアントサイドレンダリング (SCSR)"},{"t":"h2","c":"SCSRとは？"},{"t":"p","c":"SCSRのフルネームは、Static Client-Side Renderingで、静的なクライアントサイドレンダリングと呼ばれます。静的なクライアントサイドレンダリング(SCSR)は、CSR(Client-Side Rendering)の一種であり、CSRのユーザーエクスペリエンスを保ちながら、ページを静的な状態でクローラーが取できるようにすることができます。"},{"t":"h2","c":"SCSRの使い方"},{"t":"p","c":"以下の方法で SCSR ライブラリを引用することができます。"},0,{"t":"h2","c":"SCSRの仕組み"},{"t":"p","c":"SCSRは、o-pageタグを使わずに直接シングルファイルモードでページモジュールを実行することで、ページのレンダリングを可能にします。 具体的には、ページモジュールのテンプレートコードは o-app の中に直接置かれます。"},{"t":"p","c":"以下は、SCSRの例です。この例では、ページモジュールの内容を直接レンダリングする方法を示しています。"},0,{"t":"p","c":"template タグ内の内容は、SCSRによって直接ページ上にレンダリングされます。この部分の内容は、実際にはシングルファイルモードのページモジュールです。"},{"t":"p","c":"以前の home.html ページの例に従って、help ページを作成します："},0,{"t":"p","c":"「home.html」のページで「GO TO HELP」をクリックすると、スムーズに「help.html」のページに遷移し、クライアント側でのレンダリングによるスムーズなページ遷移効果が実現されています。"},{"t":"h2","c":"注意"},{"t":"p","c":"すべてのSCSRスキームを使用したページについて、ページの説明的なコンテンツ（タイトル、メタディスクリプション、キーワードなど）とページテンプレートのコンテンツ以外の参照リソースは、ページの遷移とリロード後の一貫した体験を確保するために一致させる必があります。"},{"t":"h2","c":"SSRプログラムについて"},{"t":"p","c":"現在のSCSRの仕組みは実際にはSSG（Static Site Generation）の一種に似ています。なぜなら、ページを静的なコンテンツとして事前にレンダリングし、その後クライアントで相互作用するからです。ofa.jsは、独立したコンポーネントラッピングの仕組みを提供しており、フロンエンド開発者はコンポーネントをラップし、従来のバックエンドページレンダリングの仕組み（Node.js、Go、Java、PHPなどの言語のウェブサイトレンダリングフレームワークなど）と組み合わせることで、バックエンド開発者はこれらのラップされたコンポーネントを使って高品質なウェブページを素早く構築することができます。"},{"t":"p","c":"我々は将来的に完全なSSR（サーバーサイドレンダリング）ソリューションを提供する予定です。 このソリューションの原理は、まず次のページの要素の内容を取得し、現在のページのタグの内容と比較することで、動的な追加、削除、属性値の変更などを行うことです。 ただし、このSSRのソリューションは時間がかかる可能性があることに注意してください。なぜなら、このプロセスには複雑な要素の比較と変更が関与するからです。"},{"t":"p","c":"ofa.jsは新興のフレームワークであり、また作者の余暇も限られているため、まだこのSSRのソリューションを完全に開発していません。しかし、将来的にofa.jsがより多くのユーザーに利用され、SSRのソリューションに対する強い需要が生じた場合、作者はこのソリューショを改善し続ける予定です。現時点では、作者はフレームワークの安定性と機能拡張に重点を置き、またユーザーのフィードバックと提案も歓迎します。これにより、将来的にユーザーのニーズにより良く応えることができます。"}]},"others":{"data-sharing":[{"t":"h1","c":"データ共有"},{"t":"p","c":"ofa.jsは他のサードパーティフレームワークとは異なり、伝統的な状態管理モードを採用していません。状態の更新は感知されず、データの変更後に自動的にデータ更新がトリガーされるべきと作者は考えています。"},{"t":"p","c":"ofa.jsは本質的に優れたデータ共有機能を持っており、そのインスタンスはデータ共有ライブラリStanzをベースに開発されている。 インスタンス上のオブジェクトはすべて同期可能です。 データを共有するには、単に別のStanzオブジェクトを作成し、すべてのコンポーネントがそれを直接参照するようにします。"},{"t":"p","c":"以下の例は、データの共有方法を示しています："},0,0,0,0,{"t":"p","c":"上記の例で、2つのコンポーネントは「attached」ライフサイクルにおいて、データをコンポーネント自体に書き込みます。そして、コンポーネントの「obj」が共有データとなります。そして、「detached」ライフサイクルの後、以前に共有されたデータを「null」に設定して、ータが回収されることを確保します。"},{"t":"h2","c":"注意"},{"t":"p","c":"データは共有されているため、適切なタイミングでデータを回収し、メモリリークを防止する必要があります。"},0],"about-micro-frontend":[{"t":"h1","c":"マイクロフロントエンドについて"},{"t":"p","c":"マイクロフロントエンドはフロントエンドのアーキテクチャパターンであり、チームが大規模かつ複雑なフロントエンドアプリケーションを構築および保守するための支援を目的としています。これはマイクロサービスアーキテクチャの考え方を借り、フロントエンドアリケーションをより小さな独立した部分に分割し、各部分を異なるチームが開発、テスト、デプロイできるようにします。"},{"t":"p","c":"従来のモノリシックなフロントエンド・アプリケーションは拡張を続けると、保守や拡張が困難になる可能性があります。 マイクロフロントエンドの目標は、アプリケーションをより小さく管理しやすいモジュールに分解し、開発チームがこれらのモジュールを独立して開発・デプロイできるようにすることで、チームの効率とアプリケーションの保守性を向上させることです。"},{"t":"p","c":"ofa.jsは、マイクロフロントエンドの機能を持って生まれたフレームワークで、他のフレームワークとの違いは、ofa.jsで開発されたコンポーネント、ページ、およびアプリケーションは事前にコンパイルする必要がありません。React、Vue、Angularなどの一部のフレームワーク比較して、これらのフレームワークはNode.js環境でのビルドが必要であり、クライアント側で実行するためのコードを生成する必要があります。しかし、ofa.jsの開発コードは静的サーバーに直接配置することができ、追加のビルド手順なしでリアルタイムに表示、使用、実行することができます。"},{"t":"p","c":"ofa.jsはマイクロ・フロントエンドに準拠しています："},{"t":"l","c":"1. 独立デプロイ: 各コンポーネントやページは個別に開発、テスト、デプロイすることができるため、チームは新機能のリリースや問題の解決を迅速に行うことができます。\n    \n2. 統合: ofa.jsで開発されたアプリケーションは、さまざまなモジュールを組み合わることができます。これはアプリ、ページ、コンポーネントなどを使用して組み合わせることができます。\n\n3. 独立チーム: 各フロントエンドモジュール（コンポーネント/ページ/アプリ）は独立したチームによって開発およびメンテナンスされることができます。これにより、自律性とイノベーションの促進が図られます。\n\n4. 共有リソース: ofa.jsプロジェクトでは、スタイル、コンポーネント、ページなどの共有リソースが存在する場合があります。これにより、一貫性と効率が確保されます。\n\n5. オンデマンドロード: ofa.jsアプリケーションは、必要に応じてモジュールをロードすることができるため、アプリケーションのパフォーマンスとロード速度が向上します。"},{"t":"p","c":"ofa.jsは、VueやReactのようなフレームワークで開発されたコンポーネントを直接使用することはできませんが、ofa.jsに基づいて開発されたコンポーネントは、VueやReactで使用することができ、異なる技術スタックの開発者により高い柔軟性とスケーラビリティを提供します。"},{"t":"p","c":"VueでWebコンポーネントを使う"},{"t":"l","c":"- Vue Web Component Wrapper\n- VueとWeb Componentsの統合\n- VueでWeb Componentsを使用する方法"},{"t":"p","c":"Reactでウェブ・コンポーネントを使う："},{"t":"l","c":"- ReactとWeb Componentsの連携\n- ReactでのWeb Componentsの使用方法\n- ReactにWeb Componentsを統合する方法"}],"coexist-with-jquery":[{"t":"h1","c":"jQuery との共存"},{"t":"p","c":"ofa.js（≥4.3.40）を使用する場合、jQueryと共存することができます。主な選択肢は2つあります："},{"t":"h2","c":"1. 「noConflict」を使用する"},{"t":"p","c":"jQueryの導入後にnoConflictメソッドを呼び出すことで、$変数を解放し、衝突を避けることができます。"},0,{"t":"h2","c":"2. ライブラリを順番にインポートする"},{"t":"p","c":"もう一つの方法は、順番にライブラリをインポートし、後でインポートされたライブラリが $ 変数を占有する方法です。この場合、グローバル変数の ofa を元の $ の代わりに使用することができます。"},0,{"t":"p","c":"jQuery と ofa.js が同一のページ上で衝突しないようにするには、次のいずれかの方法を使用します。"}]}},"api":{"index":[{"t":"h1","c":"APIの紹介"},{"t":"p","c":"以下はofa.js APIの概要です。必要な場合に備えて最初に一度ご覧いただき、詳細なドキュメントを参照する際に再度ご確認ください。"},{"t":"h2","c":"インスタンス関連"},{"t":"l","c":"- $：インスタンスを取得するためのメソッド\n- all：関連するすべてのインスタンスを取得する\n- prev：対象要素の前のインスタンスを取得する\n- prevs：対象要素の前のすべてのインスタンスを取得する\n- next：対象要素の後ろのインスタンスを取得する\n- nexts：対象要素の後ろのすべてのインスタンスを取得する\n- siblings：対象要素のすべての隣接する要素のインスタンスを取得する\n- parent：親要素のインスタンスを取得する\n- parents：すべての親要素のインスタンスの集合を取得する\n- clone：インスタンスをクローンするためのメソッド\n- ele：インスタンスの実際のネイティブ要素を取得する\n- shadow：カスタムコンポーネントの影のルートノードを取得する\n- root：対象インスタンスのルートノードを取得する\n- 子元素：数字で子要素を直接取得する\n- host：対象の app 要素のインスタンスを取得する"},{"t":"h2","c":"ノード操作"},{"t":"l","c":"- 子ノードの追加または削除\n- before：ターゲットインスタンスの前に要素を追加する\n- after：ターゲットインスタンスの後ろに要素を追加する\n- remove：ターゲット要素を削除する\n- wrap：ターゲット要素を要素で包む\n- unwrap：ターゲット要素から包んでいる要素を取り除く"},{"t":"h2","c":"プロパティ操作"},{"t":"l","c":"- text：ターゲット要素のテキストを取得または設定します\n- html：ターゲット要素のHTMLコードを取得または設定します\n- attr：ターゲット要素のattributesを取得または設定しま\n- css：ターゲット要素のスタイルを取得または設定します\n- style：ターゲット要素のネイティブスタイルを取得します\n- classList：ターゲット要素のネイティブclassリストを取得します\n- data：ターゲット要素のネイティブデータセットを取得します"},{"t":"h2","c":"イベントに関連する"},{"t":"l","c":"- on：イベントをターゲット要素にバインドする\n- one：ターゲット要素に一度だけイベントをバインドする\n- emit：イベントを自発的にトリガーする\n- off：バインドされているイベントを解除する"},{"t":"h2","c":"テンプレート構文"},{"t":"l","c":"- テキストのレンダリング：テンプレートファイルでテキストを素早くレンダリングします。\n- クラス：テンプレートファイルでクラス名を素早くレンダリングします。\n- 同期：データをテンプレートファイに素早く同期します。\n- 条件付きレンダリング：テンプレートファイルで必要な場合にコンテンツをレンダリングします。\n- リストのレンダリング：テンプレートファイルで配列データを素早くレンダリングします"},{"t":"h2","c":"ライフサイクル"},{"t":"l","c":"- created：コンポーネントが作成され、コンテンツがレンダリングされていない状態でトリガーされます。\n- ready：コンポーネントが作成され、コンテンツがレンダリングされた後にトリガーされます。\n- watch：コポーネントの初期化が完了し、値が変更された後にトリガーされます。\n- loaded：コンポーネントの埋め込みリソースがロードされた後にトリガーされます。\n- attached：コンポーネントがドキュメントに追加された後にトリガーされます。\n- detached：コンポーネントがドキュメントから削除された後にトリガーされます。\n- routerChange：アプリケーションのルートが変更された時に、内包された親ページでトリガーされます。"},{"t":"h2","c":"ほか"},{"t":"l","c":"- ボックスモデル：対象要素の関連するすべてのサイズに関するデータを取得します\n- formData：フォームデータを便利にバインドおよび取得します\n- タグ：対象のタグ名を取得します\n- インデックス：対象要素の親要素内での順序を取得します\n- is：対象要素がCSSセレクタ式に一致するかどうかを判断します\n- refresh：コンポーネントのインターフェースをアクティブに更新します\n- PATH：コンポーネントまたはページの登録ファイルのアドレスを取得します\n- extend：インスタンスのデータまたはメソッドを拡張します；ofa.jsの下層のデータまたはメソッドを拡張します；\n- version：インポートされているofa.jsのバージョン番号を取得します\n- インスタンスデータの特徴：インスタンスデータのサブオブジェクトデータの特性、データの変更をどのように監視するかを紹介します"}],"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"$メソッドはofa.jsの中心的な関数で、DOM要素のインスタンスを操作するために使用されます。以下では、$の主な役割について紹介します。"},{"t":"h2","c":"要素のインスタンスを取得する"},{"t":"p","c":"メソッドを使うと、cssセレクタにマッチするページ上の要素の最初のインスタンスを取得し、それを操作することができます。 以下はその例です："},0,0,0,0,{"t":"p","c":"上記の例では、$記号を使用して、idが「target1」の要素インスタンスを選択し、text属性を設定してそのテキスト内容を変更しました。"},{"t":"h2","c":"子要素の検索の例"},{"t":"p","c":"インスタンスも $ メソッドを持っており、インスタンス上の $ メソッドを使用して、要素インスタンスの最初の条件に一致する子要素のインスタンスを取得できます。"},0,0,0,0,{"t":"h2","c":"元素インスタンスの特性"},{"t":"p","c":"元素インスタンスを直接他の場所に挿入しないでください。この操作は元の要素に影響を与える可能性があります。コピーを作成する必要がある場合は、cloneメソッドを使用してください。"},0,0,0,0,{"t":"h2","c":"影子ノードの内部にある子要素を取得する。"},{"t":"p","c":"shadowプロパティを使用してインスタンスを取得し、$メソッドを使用して必要な要素を取得できます。"},0,{"t":"h2","c":"直接インスタンス化要素"},{"t":"p","c":"あなたは以下の方法で、ネイティブ要素を$インスタンスオブジェクトとして初期化することができます。"},0,0,{"t":"p","c":"このように、既存のHTML要素を $ インスタンスに変換し、$ が提供する機能を使用して操作や処理を行うことができます。"},{"t":"h2","c":"元素インスタンスの生成"},{"t":"p","c":"新たな要素インスタンスを作成し、ページに追加するために、$ は既存の要素インスタンスを取得する以外にも使用することができます。"},{"t":"h3","c":"文字列から生成"},{"t":"p","c":"$ 関数を使用して、文字列から新しい要素インスタンスを作成することができます。以下のようになります："},0,0,0,0,{"t":"p","c":"この例では、指定されたスタイルとテキストの内容を持つ新しい要素インスタンスを作成し、それを既存の要素インスタンスである \"target1\" のidを持つ要素に追加するために $ 関数を使用しました。"},{"t":"h3","c":"オブジェクトを通して生成される"},{"t":"p","c":"あなたは$関数を使用して、オブジェクトを介して新しい要素のインスタンスを生成することもできます。以下はその例です。"},0,0,0,0,{"t":"p","c":"この例では、オブジェクトの形式で$関数を使用して新しい要素インスタンスを定義しました。これにはタグのタイプ、テキストの内容、スタイルの属性が含まれており、それを既存の要素インスタンスであるidが \"target1\"であるものに追加しています。"}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"all メソッドを使用すると、CSS セレクタ に一致するページ上のすべての要素を取得し、これらの要素を含む配列を返すことができます。"},0,0,0,0,{"t":"h2","c":"子要素の取得"},{"t":"p","c":"インスタンスも all メソッドを持っており、インスタンス上の all メソッドを使用してサブエレメントを選択して取得することができます。"},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"prevプロパティを使用すると、要素の前の隣接する要素のインスタンスを取得できます。"},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"prevs属性を使用すると、現在の要素の前にあるすべての隣接要素のインスタンスを簡単に取得できます。これらの要素は配列の形式で返されます。"},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"next 属性を使用することで、要素の次の隣接要素のインスタンスを取得することができます。"},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"使用 siblings属性では、現在の要素のすべての隣接要素のインスタンスを簡単に取得することができます。これらの要素は配列の形式で返されます。"},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"nexts属性を使用することで、現在の要素の後にあるすべての隣接要素のインスタンスを簡単に取得することができます。これらの要素は配列の形式で返されます。"},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"parent属性を使用すると、インスタンスの親要素のインスタンスを取得できます。"},0,0,0,0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"ele属性を使うと、インスタンスの実際の要素を取得して、ネイティブのプロパティやメソッドを使うことができる。"},0,0,0,0,{"t":"p","c":"上記の例では、ele 属性を使用して要素を取得し、その内部の HTML コンテンツを変更し、記録用の要素の tagName を変更しました。これにより、ネイティブの JavaScript メソッドを使用して要素をより複雑な操作に組み合わせることができます。"}],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"cloneというメソッドを使用することで、要素のインスタンスを複製し、新しいインスタンスを生成することができます。"},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"parents 属性を使えば、現在の要素の親のインスタンスをすべて簡単に取得することができ、配列として返される。"},0,0,0,0],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"shadow プロパティを使用すると、要素のシャドウルートノードのインスタンスを取得できます。"},0,0,0,{"t":"p","c":"注意すべきは、テンプレートの構文を持つ要素の中で直接影のノード内の要素を変更しないことです。これにより、操作の一貫性とメンテナンス性が保たれます。"},{"t":"h2","c":"外部からコンポーネントのシャドウ要素内の要素インスタンスを取得する"},{"t":"p","c":"あなたはカスタム要素のインスタンスを外部から取得し、shadowプロパティを介してシャドウドム内の要素にアクセスすることもできます。以下のようになります："},0],"root":[{"t":"h1","c":"root"},{"t":"p","c":"ルートのプロパティを使用して要素のルートノードを取得します。"},{"t":"p","c":"画面上では、一般的な要素のルートノードは document インスタンスです。"},0,0,0,0,{"t":"h2","c":"シャドウ・ノード内の要素"},{"t":"p","c":"げんいんコンポーネントの内 げんそうは そとげんきょうから かくりつして できており、シャドウノードのうちの もとぞくせいは シャドウコンポーネントです。"},0,0,0],"children":[{"t":"h1","c":"子要素"},{"t":"p","c":"子要素のインスタンスの取得は非常に簡単です。インスタンスを配列のように扱い、番号で子要素のインスタンスを取得するだけです。"},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"目标要素の子要素の数を取得します。例は上記のようになります。"},0],"host":[{"t":"h1","c":"host"},{"t":"p","c":"host属性を使うと、要素のホストコンポーネントのインスタンスを取得することができます。 これは、コンポーネントの内部からそのコンポーネントのホストコンポーネントのデータやメソッドにアクセスするのに便利である。"},{"t":"p","c":"以下は、host属性を使用してホストコンポーネントのインスタンスを取得する方法を示す例です。"},0,0,0,{"t":"p","c":"この例では、host-demoというカスタムコンポーネントを作成し、その内部でホストコンポーネントのインスタンスにアクセスし、それらが等しいかどうかを比較します。"},{"t":"p","c":"もし要素がコンポーネント内に存在しない場合、host の値は null になります。例えば："},0,0,0,0,{"t":"p","c":"この例では、#target要素はbodyの下にあり、コンポーネントやページの中にはないので、$(\"#target\").hostの値はnullである。"}],"app":[{"t":"h1","c":"app"},{"t":"p","c":"在 o-app 内の要素は、o-app 内の o-page の影のノード内の要素、または内部の子コンポーネントを含みます。これらの要素の app 属性は、この o-app の要素インスタンスを指すものです。"},{"t":"p","c":"以下は、o-app 内の要素で app 属性にアクセスする方法を示す例です："},0,{"t":"p","c":"コードは次の通りです："},0,0,0,{"t":"p","c":"上記の例では、o-app 要素の app 属性には、o-page 要素と test-comp カスタムコンポーネントの要素が含まれています。これは、それらがすべて app 属性を介して o-app 要素のデータとメソッドにアクセスできることを意味します。"}]},"operation":{"array-like":[{"t":"h1","c":"子要素の追加または削除"},{"t":"p","c":"元素のインスタンスは配列のような特性を持っており、ノードの追加や削除は配列の操作メソッドを使用するだけで行うことができます。push、unshift、pop、shift、spliceメソッドを使用する場合、内部で$メソッドの初期化操作が自動的に実行されまので、具体的な要素の文字列やオブジェクトを直接記入することができます。"},{"t":"p","c":"それと同様に、forEach、map、someなど、他の配列メソッドも使用できます。"},{"t":"p","c":"注意してください。「テンプレート構文がある要素で、子要素を追加または削除しないでください。」"},{"t":"h2","c":"push"},{"t":"p","c":"要素の末尾に子要素を追加します。"},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"配列の先頭に子要素を追加します。以下は例です："},0,0,0,0,{"t":"h2","c":"pop"},{"t":"p","c":"リストから要素を削除します。"},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"配列の先頭からサブ要素を削除します。"},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"子要素を削除または置換することもできますし、新しい子要素を追加することもできます。これは配列の splice メソッドと似たような方法で使用されます。以下は例です。"},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"before メソッドは、対象の要素の前に要素を追加するためのものです。before 操作を実行する前に、自動的に $ メソッド の初期化操作が実行されるため、具体的な要素の文字列やオブジェクトを直接入力することができます。"},{"t":"p","c":"注意してください、テンプレートの文法が含まれている要素を操作しないでください。"},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"after メソッドは、対象の要素の後に要素を追加するために使用されます。after 操作を実行する前に、自動的に $ メソッド の初期化操作が行われますので、具体的な要素の文字列またはオブジェクトを直接入力することができます。"},{"t":"p","c":"注意してください、テンプレートの文法が含まれている要素を操作しないでください。"},0,0,0,0],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"目標ノードを削除する；"},{"t":"p","c":"注意してください、テンプレートの文法が含まれている要素を操作しないでください。"},0,0,0,0],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"wrap メソッドは、対象の要素の外側に要素をラッピングするために使用されます。wrap 操作の前に、自動的に $ メソッド の初期化操作が実行されるため、具体的な要素文字列またはオブジェクトを直接指定することができます。"},{"t":"p","c":"以下は例です："},0,0,0,0,{"t":"h2","c":"注意"},{"t":"p","c":"目標要素は親ノードを持っている必要があります。そうでない場合、包括操作は失敗します。"},0,{"t":"p","c":"注意してください、テンプレートの文法が含まれている要素を操作しないでください。"}],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"unwrap メソッドは、ターゲット要素から外部のラップ要素を削除するために使用されます。"},{"t":"p","c":"以下は例です："},0,0,0,0,{"t":"h2","c":"注意"},{"t":"p","c":"目標要素は親ノードを持っている必要があります。そうでない場合、包括操作は失敗します。"},0,{"t":"p","c":"その要素に他の兄弟要素がある場合、unwrap を実行することはできません。"},0,{"t":"p","c":"注意してください、テンプレートの文法が含まれている要素を操作しないでください。"}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"text メソッドは、要素のテキスト内容を取得または設定するために使用されます。"},{"t":"h2","c":"直接使用する"},{"t":"p","c":"あなたは要素のテキストコンテンツを直接取得または設定することができます。以下は例です："},0,0,0,0,{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"以下は、モデル内で :text 属性を使用して、ターゲット要素に対応する属性値を設定する方法です。これは、コンポーネントのレンダリングに特に便利です。以下はサンプルです："},0,0,0],"html":[{"t":"h1","c":"html"},{"t":"p","c":"目標の内部にHTMLコードを設定します。"},0,0,0,0,{"t":"h2","c":"注意"},{"t":"p","c":"htmlは比較的危険な方法です。scriptに埋め込まれると、内部のjavascriptコードが自動的に実行されてしまいますので、使用する際はXSSに対する予防策に注意してください。"},{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"あなたはテンプレート内で、目的の要素に対応する属性値を設定するために :html 属性を使用することもできます。これはコンポーネントのレンダリングに特に役立ちます。以下は例です"},0,0,0],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"attr メソッドは、要素の attributes を取得または設定するために使用されます。"},{"t":"h2","c":"直接使用する"},{"t":"p","c":"attrメソッドを使用して、要素の属性を直接取得または設定することができます。以下は例です：%"},0,0,0,0,{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"attr:aaa=\"bbb\" のように、テンプレート内で使用することもできます。これにより、対象要素の aaa 属性をコンポーネント bbb の値に設定することができます。この方法は、コンポーネントのレンダリングに特に役立ちます。以下に例を示します。"},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"cssメソッドは、対象の要素のスタイルを取得または設定するために使用されます。"},{"t":"h2","c":"直接使用する"},{"t":"p","c":"cssメソッドを使用して、要素のスタイルを取得または設定することができます。以下は例です。"},0,0,0,0,{"t":"h2","c":"グローバル設定"},{"t":"p","c":"取得した css オブジェクトを使用して、要素に直接設定されたスタイル値を取得することができます。以下は例です："},0,0,0,0,{"t":"p","c":"css オブジェクトの特性を使用すると、ターゲット要素のスタイルを簡単に調整することができます。"},{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"あなたはテンプレートの文法を使用して、ターゲット要素のスタイルを設定することもできます。以下は例です。"},0,0,0,{"t":"h2","c":"css設定のヒント"},{"t":"p","c":"$ele.css = {...$ele.css, color:'red'}という方法を使用して、要素の特定のスタイルプロパティを変更することができます。他のスタイルプロパティに影響を与えることはありません。この方法は、全体のスタイルを書き換えることなく、1つのプロパティのみを変更することがでます。"},{"t":"h3","c":"サンプル"},0,{"t":"p","c":"上記の例では、{ ...myElement.css, color: 'red' }を使用して、要素の色のスタイルのみを変更し、他のスタイルプロパティを変更しないようにしました。これは要素のスタイルを柔軟に変更するための便利なテクニックです。"}],"style":[{"t":"h1","c":"style"},{"t":"p","c":"style属性を使用し、ネイティブの一貫性を保つ；"},{"t":"p","c":"注意：style 属性は実際のスタイル値を取得できず、単にstyle 属性に設定された値しか取得できません。style メソッドは css メソッド に似ていますが、全体のスタイルのオーバーライドはできません。css と比較して、style メソッドの内部実行効率が高いです。"},{"t":"p","c":"下記は style の使い方を示す例です："},0,0,0,0,{"t":"p","c":"style メソッドは、style 属性の値を取得および設定するだけであり、実際の計算されたスタイルではありませんので、お気をつけください。"}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"classList 属性は、ネイティブと同じです。"},{"t":"p","c":"以下は classList の使用方法を示す例です。"},0,0,0,0,{"t":"p","c":"classList 属性は、要素のスタイルを動的に変更するために、クラス名の追加、削除、切り替えを簡単に行うことができます。より詳しい操作方法については、classListをご覧ください。"}],"data":[{"t":"h1","c":"data"},{"t":"p","c":"要素の dataset を取得するには、data プロパティを使用し、ネイティブの dataset と一致させてください。"},0,0,0,0]},"event":{"on":[{"t":"h1","c":"on"},{"t":"p","c":"on メソッドを使用すると、対象の要素にイベントハンドラを登録できます。これにより、ユーザーのインタラクションを簡単にキャプチャし、応答することができます。"},{"t":"p","c":"下記は、ボタン要素にクリックイベントハンドラを登録する方法を示すサンプルです。"},0,0,0,0,{"t":"p","c":"在この例では、onメソッドを使用してボタン要素にクリックイベントハンドラを追加しました。ユーザーがボタンをクリックすると、イベントハンドラがトリガされ、カウンターが増加し、結果がページに表示されます。"},{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"target elementにメソッドをバインドするために、テンプレート構文を使用することもできます。以下は例です。"},0,0,0,{"t":"p","c":"この例では、on:clickというイベントをボタン要素にバインドし、addCountというメソッドを呼び出します。ユーザーがボタンをクリックすると、このメソッドが呼び出され、カウンタの値が増えてページ上に表示されます。この方法を使うことで、イベントハンドラをンポーネントのメソッドと関連付けて、より複雑なインタラクションを実現することができます。"},{"t":"h2","c":"event"},{"t":"p","c":"\b\b注册日時の後、呼び出される関数は、eventを引数に取り、オリジナルと同じです。"},0,0,0,0],"one":[{"t":"h1","c":"one"},{"t":"p","c":"使用 one 方法，目标要素に一度だけイベントハンドラを登録することができます。これは、イベントハンドラが最初に発生した後に自動的にバインドが解除され、再び発生しないことを意味します。"},{"t":"p","c":"下記は、ボタン要素にクリックイベントハンドラを登録するためにoneメソッドを使用する方法のデモです。"},0,0,0,0,{"t":"p","c":"この例では、oneメソッドを使用してボタン要素にクリックイベントハンドラを追加しました。ユーザーがボタンをクリックすると、イベントハンドラがトリガーされますが、その後はもう一度トリガーされません。イベントハンドラは既にバインド解除されています。"},{"t":"h2","c":"テンプレート構文の使用方法"},{"t":"p","c":"あなたは、テンプレート構文を使用して、対象要素に一度だけのイベントハンドラをバインドすることもできます。以下は例です："},0,0,0,{"t":"p","c":"この例では、ボタン要素に one:click を使用して、addCount というメソッドをバインドしています。ユーザーがボタンをクリックすると、このメソッドが呼び出されますが、その後は再度トリガーされないため、一度だけのイベントハンドラです。"}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"emit メソッドを使用することで、イベントを自発的にトリガーすることができます。また、トリガーされたイベントはバブリングメカニズムを持っています。バブリングメカニズムとは、イベントが内部要素から外部要素へとバブリングすることを意味します。つまり、側から外側の階層でイベントがトリガーされます。"},{"t":"p","c":"以下は、emitメソッドを使ってカスタムイベントをトリガーし、バブリングメカニズムを使って外部エレメントにイベントを渡す方法の例である："},0,0,0,0,{"t":"p","c":"この例では、<ul>要素と<li>要素に同じカスタムイベントcustom-eventのハンドラーを登録しました。emitメソッドを使用してイベントをトリガーすると、そのイベントは<li>要素から<ul>要素にバブリングし、2つのイベントハンドラーがトリガーされます。"},{"t":"h2","c":"カスタムデータ"},{"t":"p","c":"dataパラメーターを使用することで、カスタムデータをイベントハンドラに渡すことができます。"},0,0,0,0,{"t":"p","c":"この例では、dataパラメータを使用してカスタムデータをイベントハンドラに渡します。イベントハンドラはevent.dataを使用して渡されたデータにアクセスできます。"},{"t":"h2","c":"バブリングなしでイベントをトリガーする"},{"t":"p","c":"イベントがバブリングさせたくない場合は、イベント発生時に bubbles: false パラメータを指定することができます。"},0,0,0,0,{"t":"p","c":"この例では、bubbles: false パラメータを使用してカスタムイベントをトリガーしました。このイベントは親要素までバブリングされないため、<li> 要素のイベントハンドラだけがトリガーされます。"},{"t":"h2","c":"ルートノードを貫通"},{"t":"p","c":"デフォルトでは、カスタムイベントはシャドウDOM内の要素には伝播しません。ただし、composed: trueを設定することで、カスタムイベントをルートノードを通じて伝播させ、ルートノード以外の要素をトリガーすることができます。"},0,0,0,0,0,{"t":"p","c":"この例では、composed-testというカスタムコンポーネントを作成しました。このコンポーネントには、シャドウ DOM内の要素とイベントをトリガするボタンが含まれています。デフォルトでは、イベントはシャドウ DOMを通過せずにルートノードに渡されません。しかし、イベントが発生する際に composed: true パラメータを使用することにより、イベントはルートノードにまで伝播し、ルートノード外の要素もトリガされます。"}],"off":[{"t":"h1","c":"off"},{"t":"p","c":"使用offメソッドを使用すると、登録されたイベントハンドラを解除し、イベントの監視をキャンセルすることができます。"},{"t":"p","c":"下面は、off メソッドを使用してイベントリスナーを解除する方法を示す例です。"},0,0,0,0,{"t":"p","c":"この例では、ボタンがクリックされたときにクリック数を #logger に表示するクリックイベントハンドラ f を登録している。 off` メソッドを使って、クリック数が 3 になったらイベントのリッスンを中止する。"}]},"temp-syntax":{"text-render":[{"t":"h1","c":"テキストレンダリング"},{"t":"p","c":"{{{xxx}}}の形式でテンプレート内でテキストをレンダリングすることができます。ここで、xxxはコンポーネントまたはページ自体の属性です。これにより、属性の値を直接ページにレンダリングすることができます。"},{"t":"p","c":"以下は、テキストをテンプレートにレンダリングする方法を示した例です："},0,0,0,{"t":"p","c":"この例では、{{txt}} はプロパティ txt の値に置き換えられ、最終的にページに表示されます。"}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"あなたは class 構文を使用して、テンプレート内のクラス名を簡単に切り替えることができます。 class:aaa=\"bbb\" では、 bbb 式（またはコンポーネント自体の bbb プロパティ）が true の場合、対象の要素に aaa という className が追加されます。"},{"t":"p","c":"注意してください、className には大文字を含めることはできません。ハイフン - を区切り文字として使用してください。"},{"t":"p","c":"以下は、テンプレートで要素のクラス名を切り替えるために class 構文を使用する方法を示す例です。"},0,0,0,{"t":"h2","c":"class直接使用する"},{"t":"p","c":"class メソッドを使用して要素の className を直接変更することができます。以下の例では、class メソッドを使用してクラス名を動的に追加および削除する方法を示しています。"},0,0,0,0,{"t":"p","c":"この例では、まず class メソッドを使用して color-red クラスを要素に追加し、1秒後にクラスを削除し、さらに0.5秒後に color-blue クラスを要素に追加します。これにより、対象の要素のスタイルが動的に変更されます。"},{"t":"p","c":"私たちは、classList プロパティを使用してクラス名を操作することをお勧めします。これはより一般的で標準的な方法です。"}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"sync構文を使用してコンポーネントに双方向データバインディングを設定"},0,0,0,{"t":"p","c":"sync は、埋め込まれたコンポーネントのインスタンスプロパティともバインドできます。具体例については、双方向データバインディング をご覧ください。"}],"condition":[{"t":"h1","c":"条件レンダリング"},{"t":"p","c":"条件レンダリングは、3つの条件コンポーネントによって実現されます："},{"t":"h2","c":"x-if"},{"t":"p","c":"x-if は主要な条件文コンポーネントであり、value の値を設定する必要があります。value の条件が満たされる場合、それに包まれた内容が表示されます。"},{"t":"h2","c":"x-if-else"},{"t":"p","c":"x-if-else は x-if または x-if-else の後に続けることができ、value 値を設定する必要があります。前の条件のコンポーネントが満たされず、自分自身の value が true の場合、包括している内容が表示されます。"},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else は x-if または x-if-else の後に続けることができ、最後に配置されます。前の条件がすべて満たされない場合、自身の内容が表示されます。value の設定は必要ありません。"},{"t":"h2","c":"サンプル"},0,0,0,{"t":"p","c":"この例では、これらの条件に基づいてコンポーネントをレンダリングし、count の値に応じて表示するコンテンツを選択します。count が3で割り切れる場合、x-if 条件が満たされ、赤いテキストが表示されます。 (count + 1) が3で割り切れる場合、x-if-else 条件が満たされ、緑色のテキストが表示されます。それ以外の場合、青いテキストが表示されます。"}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"x-fill コンポーネントを使用してリストをレンダリングすることができます。配列データを埋めるために value 属性を設定します。"},{"t":"p","c":"x-fillの内部では、特殊変数$indexは現在のリストアイテムのインデックスを表し、そして$dataはリストアイテム自体のデータを表します。"},{"t":"p","c":"下記は、x-fill を使用して配列をレンダリングする方法を示す例です："},0,0,0,{"t":"p","c":"この例では、x-fill コンポーネントを使用して配列 arr をレンダリングし、各リストアイテムにインデックスとデータを表示します。"},{"t":"h2","c":"テンプレートリストのレンダリング"},{"t":"p","c":"あなたは、template要素を使ってコンポーネント内の一時的なテンプレートをカスタマイズすることができます。x-fillを使う際には、name属性を使用して埋め込むテンプレート名を指定します。"},{"t":"p","c":"以下は、テンプレートリストのレンダリング方法を示す例です："},0,0,0,{"t":"p","c":"この例では、\"easyLi\"という名前のテンプレートを作成し、x-fillを使用して配列arrのデータを埋め込み、各リスト項目にインックスとデータの名前を表示しています。"},{"t":"h2","c":"入れ子リストのレンダリング"},{"t":"p","c":"ネストされたリストのレンダリングを行う場合、2番目の階層からは、テンプレートを使用して埋める必要があります。この設計は、複数階層のネストされたリストのレンダリングコードを複雑にするのを避けるためです。"},{"t":"p","c":"以下は、ネストされたリストのレンダリング方法を示す例である："},0,0,0,{"t":"p","c":"この例では、配列 arr を持つ2つのオブジェクトがあります。各オブジェクトには name プロパティとネストされたサブアイテムを含む可能性がある childs プロパティがあります。リストを埋めるために x-fill を使用し、サブアイテムをテンプレート \"easyLi\" でレンダリグします。アイテムにサブアイテムがある場合は、x-if を使用してネストされたリストを作成します。"},{"t":"h2","c":"再帰的リスト・レンダリング"},{"t":"p","c":"テンプレートのレンダリングでは、再帰的なレンダリングも行うことができます。これは、ツリー構造のリストを構築する際に非常に有用です。"},{"t":"p","c":"下記は、再帰的なリストのレンダリングの例のデモです："},0,0,0,{"t":"p","c":"この例では、arrという配列があります。配列には2つのオブジェクトが含まれています。各オブジェクトにはnameプロパティと、ネストされたサブアイテムが含まれている可能性のあるchildsプロパティがあります。リストを埋めるためにx-fillを使用し、子アイテムをテンプレート\"easyLi\"でレンダリングしています。アイテムにサブアイテムがある場合、再帰的にサブリストをレンダリングするためにx-fillを使用しています。これにより、再帰的なリストのレンダリングが実現されています。"},{"t":"h2","c":"replace-temp"},{"t":"p","c":"時々、select や table にリストをレンダリングしようとすると、ブラウザが <x-fill> 要素を自動的に削除してしまい、リストのレンダリングがうまくいかないことがあります。この場合、replace-temp を使用してレンダリングする方法があります。replace-temp を使用する方法は、<template> タグで is=\"replace-temp\" を設定し、このテンプレートをブラウザが自動的に修正する要素内に置くことです。"},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created フックは、コンポーネントが作成されるときにトリガーされます。この段階では、コンポーネントのデータは初期化されておらず、テンプレートの内容もレンダリングされていません。この段階で、初期化操作を行ったり、後続の段階で使用するデータを準備たりすることができます。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"ready フェーズが完了すると、関連付けられた watch オブジェクトのリスナー関数が一度だけトリガーされる。 その後、データの値が変更されると、対応するキーのリスナー関数が再び起動される。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"loaded ライフサイクルフックは、コンポーネントテンプレート内のすべての依存関係がロードされた後にトリガーされます。この段階では、コンポーネントのレンダリング前に、すべての依存関係が完全にロードされていることが保証されます。この時点では、ready フェーズで追加されたローディングスタイルを削除するのに適しています。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"readyの生命周期フックは、コンポーネントのデータとテンプレートが初期化された直後にトリガーされ、コンポーネントの準備が整ったことを示します。この段階では、コンポーネントのデータにアクセスすることができ、またテンプレートもレンダリングされているた、画面との相互作用に関連する操作を実行することができます。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"detached のライフサイクルフックは、コンポーネントがドキュメントから削除される時にトリガーされます。この段階では、イベントの監視を解除したり、リソースを解放したりして、メモリリークを防ぐためにクリーンアップ操作を実行することができます。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"attachedライフサイクルフックは、コンポーネントがドキュメントに追加されたときにトリガーされます。この段階では、コンポーネント内の要素のサイズに関連する情報の取得、データバインディング、グローバルイベントの操作に適しています。"},{"t":"h2","c":"サンプルコード："},0,0,0,0,0,{"t":"h2","c":"生命周期フローチャート"},0],"router-change":[{"t":"h1","c":"routerChange イベント"},{"t":"p","c":"routerChange イベントは、o-page 要素に特化したイベントであり、o-page の親ページでのみトリガーされます。このイベントは、アプリケーションのルートが変更されたときにトリガーされます。新しいページに遷移する場合でも、以前のページに戻る場合でも、このイベトは発生します。"},{"t":"p","c":"これはアプリケーションのルーティングの変更をリッスンして応答する方法を提供し、通常はネストされたページの親ページで使用されます。 ルーティングが変更されると、routerChange イベントをリスニングして、ページのコンテンツやナビゲーションの状態を更新するなど、適切なアクションを実行することができます。"},{"t":"p","c":"このイベントは、複数のネストされたページを持つアプリケーションの構築に非常に役立ちます。ページ間のナビゲーションとコミュニケーションがより簡単になります。"},{"t":"h2","c":"サンプル"},{"t":"p","c":"ネストページへ移動してください；"}]},"others":{"page":[{"t":"h1","c":"o-pageコンポーネント"},{"t":"p","c":"o-page は ofa.js の中でのコアのコンポーネントの一つであり、独立したページまたはページモジュールを表します。以下は o-page のいくつかの主な属性とメソッドです。"},{"t":"h2","c":"src 属性"},{"t":"p","c":"src属性は、ページのモジュールの具体的なアドレスを指定するために使用されます。これはページの内容や動作を指定するための重要な属性であり、特定のページのコンテンツをどこから読み込むかをアプリケーションに伝えます。"},0,{"t":"h2","c":"goto メソッド"},{"t":"p","c":"goto メソッドは、現在のページから別のページに移動するために使用されます。app の goto メソッドと比較して、page の goto メソッドでは相対アドレスを使用して他のページにナビゲーションすることができます。"},0,{"t":"h2","c":"replace メソッド"},{"t":"p","c":"replace メソッドは、現在のページを別のページで置き換えるために使用されます。これは app の replace メソッドと似ていますが、ページ内での置換操作を行います。"},0,{"t":"h2","c":"back メソッド"},{"t":"p","c":"back メソッドは、前のページに戻るために使用されます。これによりユーザーが前のページに戻り、ブラウザの戻る操作と同様に操作が行われます。"},0],"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app は ofa.js の中での核心的なコンポーネントであり、アプリケーション全体の設定と管理を行います。以下に、app のいくつかの重要なプロパティとメソッドを示します："},{"t":"h2","c":"src"},{"t":"p","c":"src属性は、アプリケーションのパラメータ設定モジュールの具体的なアドレスを指定するために使用されます。詳しい例については、ケースを参照してください。"},0,{"t":"h2","c":"current"},{"t":"p","c":"current 属性を使用すると、現在表示されているページのインスタンスを取得できます。これにより、表示されているページにアクセスして操作することができます。たとえば、コンテンツの更新や特定の操作の実行などができます。"},0,{"t":"h2","c":"goto"},{"t":"p","c":"goto メソッドは、指定されたページにジャンプするために使用されます。目標ページのアドレスを渡すことができ、アプリケーションはそのページをロードして表示します。これはアプリケーションのナビゲーションにおける重要なメソッドです。"},0,{"t":"h2","c":"replace"},{"t":"p","c":"replace メソッドは goto と似ていますが、現在のページを置き換えるために使用されます。新しいページをスタックに追加するのではなく、ページの置換を実現するために使用できます。"},0,{"t":"h2","c":"back"},{"t":"p","c":"back メソッドは、前のページに戻るために使用され、ページナビゲーションの戻る操作を実現します。これによりユーザーは前のページに戻ります。"},0,{"t":"h2","c":"routers"},{"t":"p","c":"routersプロパティには、アプリケーションのルート構成情報が含まれています。これは重要なプロパティであり、アプリケーション内の各ページのルート規則とマッピングを定義します。ルートの設定は、ページ間のナビゲーションとURLの処理方法を決定します。"},0],"box":[{"t":"h1","c":"ボックスモデル"},{"t":"p","c":"ウェブ開発では、要素のサイズは重要な概念であり、コンテンツ領域、パディング、ボーダー、マージンを含みます。以下は要素のサイズを示す関連するプロパティです。"},{"t":"h2","c":"width"},{"t":"p","c":"widthは要素のコンテンツ領域の幅を表しますが、内側のパディング、ボーダー、およびマージンは含まれません。"},{"t":"h2","c":"height"},{"t":"p","c":"height は要素のコンテンツ領域の高さを表します。内側の余白、枠線、および外側の余白は含まれません。"},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidthは、要素の可視コンテンツ領域の幅を表し、内側のパディングを含みますが、ボーダーやマージンは含まれません。"},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeightは要素の可視コンテンツ領域の高さを表し、内部余白を含みますが、ボーダーや外部余白は含まれません。"},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"offsetWidthは、要素の全体の幅を表し、内容領域、パディング、ボーダー、マージンを含みます。"},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"offsetHeightは要素の全体の高さを表します。これにはコンテンツ領域、パディング、ボーダー、マージンが含まれます。"},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidthは、要素の全体の幅を表します。これにはコンテンツ領域も含まれます。"},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"formDataメソッドは、フォーム要素とバインドされたオブジェクトデータを生成し、フォーム要素の処理を簡単かつ効率的に行うためのものです。このメソッドは、対象要素内のすべてのフォーム要素の値を含むオブジェクトを生成し、そのオブジェクトはフォーム要素の更をリアルタイムに反映します。"},{"t":"p","c":"下記の例では、formDataメソッドを使用してフォーム要素にバインドされたオブジェクトデータを生成する方法を示しています。"},0,0,0,0,{"t":"p","c":"この例では、テキスト入力ボックス、ラジオボタン、テキストエリアを含むフォームを作成し、 formData メソッドを使用してこれらのフォーム要素の値を持つ data オブジェクトを作成しました。また、データの変更を監視し、データをリアルタイムに表示するために watch メソッドも使用しています。ユーザーがフォーム要素の値を変更すると、 data オブジェクトが適切に更新され、データ処理が非常に簡単かつ効率的になります。"},{"t":"h2","c":"反向データバインディング"},{"t":"p","c":"生成されたオブジェクトデータも逆方向のバインディング能力を持っており、つまり、オブジェクトのプロパティを変更すると、関連するフォーム要素の値も自動的に更新されます。これはフォームデータを処理する際に非常に便利であり、双方向データバインディング簡単に実現することができます。"},{"t":"p","c":"次の例では、formData メソッドによって生成されたオブジェクトデータの使い方と、逆データバインディングの方法を示します："},0,0,0,0,{"t":"p","c":"この例では、まずテキストボックス、ラジオボタン、テキストエリアを含むフォームを作成し、formData関数を使用してデータオブジェクトdataを生成します。次に、dataオブジェクトのプロパティを変更することで、双方向のデータバインディングを実現し、フォーム要素の値がオブジェクトのプロパティの変更とともに自動的に更新されるようにします。この双方向のデータバインディング機能により、フォームデータとのやり取りがより便利になります。"},{"t":"h2","c":"特定のフォームを監視する。"},{"t":"p","c":"デフォルトでは、formData() メソッドはターゲット要素内のすべての input、select、textarea 要素を監視します。ただし、特定のフォーム要素のみを監視したい場合は、CSS セレクタ を渡すことで実現できます。"},{"t":"p","c":"次の例では、CSSセレクタを渡して特定のフォーム要素をリッスンする方法を示します："},0,0,0,0,{"t":"p","c":"この例では、クラスが \"use-it\" であるフォーム要素のみを監視したいため、formData() メソッドにパラメータとして \".use-it\" を渡しました。このようにして、このクラス名を持つフォーム要素だけが監視され、生成されたデータオブジェクトに含まれます。フォーム要素を選択的に監視する際に非常に役立ち、フォームデータをより正確に管理するのに役立ちます。"},{"t":"h2","c":"カスタムフォーム"},{"t":"p","c":"カスタムフォームコンポーネントの使用は非常に簡単で、カスタムコンポーネントに valueプロパティ を追加し、 name属性 を設定するだけです。"},{"t":"p","c":"下記の例では、「custom-input」という名前のカスタムフォームコンポーネントを作成しています。このコンポーネントは編集可能なテキストボックスであり、テキストが変更されると即座に value 属性が更新されます。"},0,0,0,0,{"t":"p","c":"カスタムフォームコンポーネントを使用する場合、それをフォームに追加し、必要な name 属性を設定するだけです。"},0,{"t":"p","c":"上記の例では、<custom-input> 要素を追加し、name属性を設定してカスタムフォームコンポーネントを使用しています。その後、formData() メソッドを使用して入力要素とカスタムコンポーネントの値を監視し、フォームデータをリアルタイムで取得および処理します。この方法を使用することで、特定のニーズに対応するために、カスタムフォームコンポーネントを簡単に拡張できます。"},{"t":"h2","c":"アセンブリやページでフォームデータを使う"},{"t":"p","c":"時には、コンポーネントやページ内でフォームデータを使用し、ready ライフサイクル期間でデータを生成し、コンポーネントにバインドする必要があるかもしれません。"},{"t":"p","c":"例では、フォームデータを使用してカスタムコンポーネント内でどのように動作するかを示しています。このコンポーネントにはテキスト入力フィールドが含まれており、コンテンツを入力すると、データがリアルタイムでログに更新されます。"},0,0,0,{"t":"p","c":"在 ready 周期生命周期中，コンポーネントが準備完了した後、this.shadow.formData() メソッドを使用してフォームデータオブジェクト fdata を生成しました。その後、fdata の変化を監視するために watch を使用し、データが変化した場合には JSON 文字列に変換して logtext を更新し、フォームデータのリアルタイム表示機能を実現しています。"}],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"tag 属性は要素のタグを取得し、小文字の文字列を返します。"},{"t":"p","c":"以下の例では、tagメソッドを使用して要素のタグを取得する方法を示します。"},0,0,0,0],"index":[{"t":"h1","c":"index"},{"t":"p","c":"index 属性は、要素が親要素の中での位置を取得するために使用されます。この位置は0から数え始められますので、つまり最初の要素の位置は0であり、2番目の要素は1となります。"},{"t":"p","c":"下記の例では、index属性を使用して、要素が親要素内での位置を取得する方法を示しています："},0,0,0,0,{"t":"p","c":"この例では、最初に id が \"target\" の <li> 要素が選択されます。そして、index 属性を使用して、この要素が親要素の <ul> の中でどの位置にあるかを取得します。つまり、2番目の要素であるため、index の値は1です。その後、この値を id が \"logger\" の <div> 要素に表示します。"}],"is":[{"t":"h1","c":"is"},{"t":"p","c":"要素が式に合致するかどうかを検出するために使用されます。"},0,0,0,0],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"コンポーネントのレンダリングビューをアクティブに更新するためのメソッドです。データが更新されていない場合、このメソッドを使用してコンポーネントのビューを更新することができます。"},0,0,0],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extendはインスタンスの属性やメソッドを拡張するための高度なメソッドです。"},0,0,0,0,{"t":"h2","c":"拡張 $ 下層"},{"t":"p","c":"よく似たように、fn.extendを使用してベースインスタンスのプロパティやメソッドを拡張することもできます。fnから拡張されたプロパティやメソッドは、すべてのインスタンスに適用されます。"},0,0,0,0,{"t":"h2","c":"拡張テンプレートの文法"},{"t":"p","c":"extend 属性や関数を使用することで、テンプレートの文法を追加したり、コンポーネントに独自のテンプレートのシンタックスシュガーを提供したりすることができます。ただし、非公式のテンプレート言語を使用することは避けるべきです。非公式のテンプレート言語は学習コストを増やし、開発体験を低下させる可能性があるためです。"},{"t":"h3","c":"拡張プロパティ"},{"t":"p","c":"あなたは、テンプレート内で : を使用して属性を拡張することができます。以下では、red 属性を追加して、redが true の場合にフォントの色を赤に変更します。"},0,0,0,0,0,{"t":"p","c":"この例では、テンプレートの文法に red 属性を追加しました。count % 3 が 0 でない場合、フォントの色が赤色になります。"},{"t":"h3","c":"拡張機能テンプレート"},{"t":"p","c":"extendメソッドを使用して、テンプレートの構文で利用できるようにすることもできます。メソッド名はコロンの前の部分です。ここでは、colorテンプレート構文を拡張しました。後に続くパラメータは定義された拡張メソッドに渡されます。"},{"t":"p","c":"ここでは、always 属性が true に設定されており、コンポーネントが画面を更新するタイミングで常にこの定義されたメソッドが呼び出されることを意味します。always を設定しない場合、このテンプレートの関数は一度だけ実行されます。"},{"t":"p","c":"optionsを使用すると、よりカスタマイズ性の高いテンプレート構文を開発することができます。"},0,0,0,0,0,{"t":"h2","c":"テンプレート構文の原理"},{"t":"p","c":"現時点では、多くのテンプレート構文が extend を使って拡張されていることが、あなたには理解できているはずです。"},{"t":"l","c":"- class、attr メソッドはビューを更新するたびに実行されます。\n- on、one という関数バインディングは一度だけ実行されます。"},{"t":"p","c":"以下は、ofa.jsのテンプレート・レンダリングの原則をよりよく理解するために使用できる例です："},0,0,0],"version":[{"t":"h1","c":"version"},{"t":"p","c":"ofa.version プロパティを介して、現在インポートされている ofa.js のバージョン番号を取得することができます。"},0,0,0,0,0,{"t":"p","c":"それにより、現在の使用中のofa.jsバージョンがページに表示されます。"}],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"PATHプロパティは通常、カスタムコンポーネントやページコンポーネントで使用され、コンポーネントの登録ファイルのアドレスを取得するために使用されます。これは、開発プロセスでコンポーネントの出所を理解するのに役立ちます。特に、他のリソースファイルを照またはロードする必要がある場合に、PATHプロパティを使用してファイルパスを構築することができます。"},{"t":"p","c":"以下は、カスタムコンポーネントで PATH プロパティを使用する方法を示す簡単な例です:"},0,{"t":"p","c":"この例では、\"myCustomComponent\"というidを持つmy-comp要素を選択し、PATH属性を使用してこのカスタムコンポーネントのファイルパスを取得しています。必要に応じて、スクリプトの部分でcomponentPath変数を使用して、他のリソースファイルのパスを構築したり他の操作をったりすることができます。"}],"stanz":[{"t":"h1","c":"インスタンスデータの特徴"},{"t":"p","c":"$ を通じて取得または作成されたインスタンスオブジェクトは、完全な stanz のデータ特性を持っています。なぜなら、$ インスタンスは stanz から継承されているからです。つまり、stanz が提供するデータ操作方や特性を利用して、インスタンスオブジェクトのデータを操作したり監視したりすることができます。"},0,{"t":"h2","c":"watch"},{"t":"p","c":"実例は、watchメソッドを使用して値の変更を監視できます。オブジェクトの子オブジェクトの値を変更しても、オブジェクトのwatchメソッドで変更を監視できます。"},{"t":"p","c":"以下は、$ インスタンスと watch メソッドの使用方法をデモンストレーションする例です。"},0,0,0,0,{"t":"p","c":"この例では、まず$インスタンスオブジェクトtargetを作成し、watchメソッドを使用してその変更を監視します。オブジェクトのサブオブジェクトの値（target.bbb.child.valなど）を変更しても、watchメソッドはこれらの変更を検知し、logger要素の内容を更新します。これより、$インスタンスオブジェクトがオブジェクトの変更を簡単に監視できる強力な機能を示しています。"},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick と watch メソッドは機能が似ていますが、watchTick の内部にはスロットル処理があり、単一のスレッドで一度だけ実行されるため、一部のパフォーマンス要件の高いシーンでデータの変更をより効率的に監視することができます。"},{"t":"p","c":"以下は、$ インスタンスの watchTick メソッドの使い方の例である："},0,0,0,0,{"t":"p","c":"この例では、まず $ インスタンスオブジェクト target を作成します。次に、watch メソッドと watchTick メソッドを使用してオブジェクトの変更を監視します。watch メソッドはデータの変更があるたびに即座に実行され、watchTick メソッドは単一スレッドで一度だけ実行されるため、監視操作の頻度を制限することができます。データの変化を監視するために watch メソッドまたは watchTick メソッドを選択することができます。"},{"t":"h2","c":"unwatch"},{"t":"p","c":"unwatch メソッドは、データの監視をキャンセルするために使用され、以前に登録された watch または watchTick のリスナーを取り消すことができます。"},{"t":"p","c":"下記は、$ の unwatch メソッドを使用する方法の例です："},0,0,0,0,{"t":"p","c":"この例では、まず $ インスタンスオブジェクト target を作成し、watch メソッドと watchTick メソッドを使用して2つのリスナーを登録します。その後、unwatch メソッドを使用して以前保存したリスナーの戻り値 tid1 と tid2 を渡すことで、これらのリスナーを取り消しす。これにより、最初の setTimeout 内のプロパティの変更は、リスナーが取り消されているためにトリガーされません。"},{"t":"h2","c":"監視されない値"},{"t":"p","c":"インスタンスでは、アンダースコア _ で始まるプロパティ名は、その値が watch メソッドや watchTick メソッドによってリッスンされないことを示す。 これは、一時的なプロパティやプライベートなプロパティで、リスナーをトリガーすることなく自由に変更できる場合に便利です。"},{"t":"p","c":"以下は、下線で始まる属性値を使用して盗聴を回避する方法を示す例です。"},0,0,0,0,{"t":"p","c":"この例では、$ インスタンスオブジェクト target を作成し、watch メソッドを使用してプロパティの値の変更を監視します。setTimeout の中で、_aaa プロパティの値を変更しようとしますが、この変更は監視をトリガーしません。これは、監視をトリガーせずにプロパテの値を更新する必要がある場合に非常に便利です。"},{"t":"h2","c":"基本特徴"},{"t":"p","c":"インスタンスに設定されたオブジェクトデータは、Stanzインスタンスに変換され、このStanzインスタンスを監視できるようになります。"},0,{"t":"p","c":"私たちは$.stanzを使って、インスタンスにバインドされていないStanzデータを作成することもできます。"},0,{"t":"p","c":"これらの例は、オブジェクトデータをStanzインスタンスに設定して監視するための基本的な特徴を示しています。"},{"t":"p","c":"詳細な機能については、stanzを参照してください。"}]}}}