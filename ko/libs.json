{"cases":{"index":[0,{"t":"h1","c":"빠른 시작"},{"t":"p","c":"시작하려면 CDN 주소를 통해 ofajs 프로젝트를 당신의 프로젝트에 통합하면 됩니다."},0,{"t":"p","c":"이것은 ofa.js를 사용하여 DOM 요소의 내용을 수정하는 방법을 보여주는 간단한 예제입니다."},{"t":"h2","c":"사용 방법"},{"t":"p","c":"ofa.js를 가져온 후에 전역 범위에서 $ 기호가 등록됩니다. $('xxx')를 사용하여 조건에 맞는 첫 번째 요소를 선택할 수 있습니다. 여기서 xxx는 표준의 CSS 선택자 내용입니다."},{"t":"p","c":"위의 예에서는 $ 기호를 사용하여 다른 id를 가진 세 가지 요소를 선택하고 text, html, 및 value 속성을 설정하여 내용을 수정했습니다."},{"t":"p","c":"API 문서를 참조하여 사용 가능한 속성과 메소드에 대해 더 자세히 알아보세요."}],"simple-component":[0,{"t":"h1","c":"컴포넌트의 생성과 사용"},{"t":"p","c":"완료된 ofa.js의 로드 후에는 전역으로 'load-module'이라는 컴포넌트가 등록됩니다. 이를 참조하기 위해 'l-m'이란 약어를 사용할 수 있습니다. 이는 'script' 태그와 비슷한 방식으로 작동하며, 개발한 컴포넌트 주소를 'src' 속성을 통해 참조합니다."},{"t":"p","c":"지금 우리는 우리 자신의 구성 요소를 만들기 시작합시다. 먼저 HTML 파일을 생성하고, 파일 이름은 구성 요소의 이름과 일치해야 합니다."},{"t":"p","c":"컴포넌트 파일에서는 먼저 template 요소를 추가하고 component 속성을 추가합니다. 컴포넌트가 렌더링해야하는 내용은 이 template 요소 내에 배치됩니다. 마지막으로 이 내용은 컴포넌트의 Shadow DOM 내에 렌더링되며, Shadow DOM은 외부 환경 오염을 방지하기 위해 외부 환경과 격리됩니다."},{"t":"p","c":"다음으로, 개발한 컴포넌트를 인용하기 위해 l-m 구성 요소를 사용하면 됩니다. 페이지에서는 정의한 컴포넌트 태그를 직접 사용하면 됩니다."},{"t":"p","c":"주의할 점은 등록된 컴포넌트 이름은 소문자 영문자와 - 기호만 사용할 수 있으며, 적어도 하나의 -를 포함해야 합니다. 이 네이밍 규칙을 따라야 합니다."},{"t":"p","c":"나를 타입해주세요."}],"event":[0,{"t":"h1","c":"이벤트 응답"},{"t":"p","c":"on 메서드를 사용하여 이벤트를 바인딩할 수 있습니다. 이벤트는 개발에서 가장 기본적인 개념으로, 응용 프로그램은 이벤트의 트리거를 통해 피드백을 생성하여 상호 작용을 구현합니다."},{"t":"p","c":"다음은 클릭 이벤트를 바인딩하는 방법을 보여주는 예제입니다."},{"t":"p","c":"이 예에서는 $를 사용하여 button 요소를 선택하고 click 이벤트를 바인딩했습니다. 버튼을 클릭하면 콜백 함수가 트리거되어 target 요소의 텍스트 내용이 \"안녕하세요, 세계!\"로 변경됩니다."},{"t":"p","c":"이벤트에 대해 더 많이 알고 싶다면 Events 문서를 참조하십시오."}],"slot":[0,{"t":"h1","c":"컴포넌트 슬롯"},{"t":"p","c":"자리 표시자 <slot></slot> 태그를 템플릿에 추가함으로써 컴포넌트를 사용할 때 내용을 해당 컴포넌트 태그의 롯에 배치할 수 있습니다."},{"t":"p","c":"자체적으로 정의 된 구성 요소는 기본적으로 display 속성이 정의되어 있지 않기 때문에 구성 요소를 수동으로 정의해야합니다. 구성 요소 스타일에서 :host 선택기를 사용하여 구성 요소 자체의 스타일을 추가 할 수 있습니다."},{"t":"p","c":"이 예제는 simple-btn이라는 컴포넌트를 만드는 방법을 보여줍니다. 컴포넌트 템플릿에는 컴포넌트에 내용을 삽입할 수있는 슬롯이 포함되어 있습니다. 컴포넌트에 스타일을 추가하기 위해 컴포넌트의 스타일에 :host 선택기를 추가합니다. 다른 페이지에서 l-m 컴포넌트를 사용하여 simple-btn 컴포넌트를 참조하고 내용을 삽입합니다."}],"render-text":[0,{"t":"h1","c":"텍스트 렌더링"},{"t":"p","c":"구성 요소 파일에서는 script 태그를 추가하여 구성 요소의 논리 코드를 작성할 수 있습니다. 노출된 default 객체를 통해 구성 요소 매개 변수를 설정할 수 있습니다."},{"t":"p","c":"그 중 data 매개변수는 컴포넌트 요소의 기본 데이터를 정의하는 데 사용됩니다. 인스턴스가 생성되면 템플릿 문법을 사용할 수 있습니다."},{"t":"p","c":"텍스트 렌더링은 두 개의 중괄호로 감싸서 처리됩니다. {{xxx}} 형태로 사용되며, 여기서 xxx는 컴포넌트의 속성 이름을 나타냅니다."},{"t":"p","c":"예제에서는 컴포넌트 요소의 val 속성을 렌더링하는 방법을 보여줍니다."}],"attribute-transmission":[0,{"t":"h1","c":"특성 전달"},{"t":"p","c":"attrs 매개변수와 data 매개변수는 기능적으로 유사하며, attrs에 설정된 데이터는 data에 병합되지만 attrs에 지정된 데이터는 컴포넌트 자체의 특성에 표시됩니다."},0,{"t":"p","c":"외부에서 컴포넌트를 사용할 때 특성을 통해 데이터를 컴포넌트 내부로 전달할 수도 있습니다. 주의할 점은 특성을 통해 전달되는 데이터는 문자열 유형만 가능하다는 것입니다."}],"get-set-comp":[0,{"t":"h1","c":"컴포넌트 인스턴스의 값을 가져오고 수정하기"},{"t":"p","c":"외부에서도 컴포넌트의 데이터를 가져오거나 수정할 수 있습니다."},{"t":"p","c":"컴포넌트 데이터를 외부에서 조작하는 방법을 보여주는 예제입니다;"}],"inject-host":[0,{"t":"h1","c":"inject-host 구성 요소"},{"t":"p","c":"Web Components의 격리성 때문에 컴포넌트 슬롯 내 요소의 스타일을 직접 수정하기 어렵습니다. 이 문제에 대처하기 위해 ofa.js는 'inject-host'라는 컴포넌트를 제공합니다. 'inject-host' 컴포넌트는 호스트 레이어에 스타일을 주입하여 컴포넌트의 외관을 더 유연하게 구성할 수 있습니다."},{"t":"p","c":"주의해야 할 점은 이 구성 요소를 사용하면 호스트 레이어의 스타일에 영향을 줄 수 있다는 것입니다. 따라서 스타일을 침범할 때는 호스트의 스타일에 영향을 주지 않도록 이름 지정 규칙을 지켜야 합니다."},{"t":"p","c":"예제에서는 comp-two 컴포넌트를 정의하고 내부에서 inject-host 컴포넌트를 사용하여 스타일을 주입합니다. 이를 통해 주입된 스타일을 통해 comp-two 컴포넌트 내부의 요소에 스타일을 설정할 수 있으며 다른 컴포넌트에는 영향을 주지 않습니다."},{"t":"p","c":"동시에 다음 내용도 특히주의하여야 합니다."},{"t":"l","c":"- 'inject-host' 내에 <style> 태그를 추가함으로써 컴포넌트 내에서 특정한 스타일을 정의할 수 있습니다. 이러한 스타일은 현재 컴포넌트의 요소에만 영향을 미치고 다른 컴포넌트에는 영향을 주지 않습니다.\n- 스타일을 주입할 때 일반적인 선택기(selector)를 사용하지 않도록 주의해야 합니다. 선택기의 고유성과 특정성을 유지해야 합니다.\n- 'inject-host'는 <link rel=\"stylesheet\" href=\"target/style.css\"> 방식을 통해 외부의 스타일시트 파일을 주입할 수도 있습니다."},{"t":"p","c":"전체 예제에서는 comp-two 컴포넌트 내에서 inject-host를 사용하여 다른 컴포넌트 스타일을 파괴하지 않고도 컴포넌트 내부 스타일을 유연하게 설정하고 적용할 수 있습니다."}],"bind-event":[0,{"t":"h1","c":"이벤트 바인딩"},{"t":"p","c":"구성 요소 내에서 on 속성을 사용하여 상호 작용 기능을 제공하는 이벤트를 바인딩할 수 있습니다. 여기에서는 구성 요소 내에서 상호 작용 효과를 구현하는 방법을 보여줍니다."},{"t":"p","c":"proto 파라미터는 컴포넌트 자체의 메소드를 정의하는 데 사용되며, 이러한 메소드는 컴포넌트 내에서 사용되거나 선택기를 통해 컴포넌트를 가져온 후에 외부에서 실행될 수 있습니다."},{"t":"p","c":"on:click=\"xxx\" 뒤에는 컴포넌트 내에서 정의된 메서드 이름 또는 함수 표현식을 사용할 수 있습니다. 함수 표현식을 사용하는 경우 this 키워드를 명시적으로 작성할 필요가 없으며, 변수의 범위는 자동으로 컴포넌트에 바인딩됩니다."},{"t":"p","c":"이벤트에 대해 더 많이 알고 싶다면 Events 문서를 참조하십시오."}],"property-transmission":[0,{"t":"h1","c":"속성 전달"},{"t":"p","c":"속성 전달을 사용하여 템플릿 문법으로 컴포넌트의 데이터를 템플릿 내의 요소 속성에 적용할 수 있습니다."},{"t":"p","c":"사용 방법은 속성에 :name=\"key\"를 추가하는 것입니다. 여기서 name은 설정할 대상 요소의 속성 이름이며 key는 사용자 정의 컴포넌트에서 전달할 속성 키 이름입니다."},{"t":"p","c":"전에는 속성 설정 방법으로 선택기를 사용하는 것에 대해 언급했는데, 여기서는 속성 전달 구문을 사용한 속성 설정 방법을 소개합니다;"}],"event-passing":[0,{"t":"h1","c":"이벤트 전달"},{"t":"p","c":"on을 사용하여 원시 이벤트를 듣는 것 외에도 on은 사용자 정의 이벤트를 듣는 데에도 사용될 수 있으며, 이는 컴포넌트간에 이벤트 통신을 구현하는 데에 매우 중요합니다. 사용자 정의 이벤트는 emit 메서드를 통해 트리거됩니다. 사용자 정의 이벤트를 트리거함으로써 사용자 정의 데이터를 수신측에 전달할 수 있습니다."},{"t":"p","c":"Shadow DOM 경계를 넘어 이벤트를 발생시키기 위해 composed 속성을 추가할 수 있습니다."},{"t":"p","c":"아래 예제에서는 중첩된 컴포넌트 간에 이벤트 전달을 하는 방법을 배우게 됩니다."}],"sync":[0,{"t":"h1","c":"실시간 데이터 연결"},{"t":"p","c":"sync 구문을 사용하여 사용자 인터페이스의 상호 작용 요소 (예 : 입력 상자 또는 사용자 정의 구성 요소)와 데이터 모델 간에 실시간 양방향 연결을 설정할 수 있습니다."},{"t":"p","c":"이하의 예제에서는 sync 속성을 사용하여 입력 상자와 데이터 모델 간의 양방향 데이터 바인딩을 구현하는 방법을 보여줍니다."},{"t":"l","c":"- '데이터' 매개변수에서는 'testText'라는 이름의 데이터를 정의하고 초기값을 'I am testText'로 설정합니다.\n- 'sync:value=\"testText\"'를 사용하여 입력 상자의 값과 'testText' 데이터 사이에 양방향 데이터 바인딩이 설정됩니다. 따라서 사용자가 입력 상자에 내용을 입력할 때마다 'testText' 데이터가 실시간으로 업데이트되며 그 반대도 마찬가지입니다.\n- 마찬가지로, 'sync:txt=\"testText\"'를 사용하여 사용자 정의 컴포넌트의 'txt' 속성과 'testText' 데이터 사이에 양방향 데이터 바인딩이 설정됩니다. 컴포넌트의 'txt' 속성이 변경되면 'testText' 데이터가 실시간으로 업데이트되며 그 반대도 마찬가지입니다."},{"t":"p","c":"양방향 데이터 바인딩을 통해 사용자 인터페이스와 데이터 모델 사이에 연결을 쉽게 설정할 수 있으므로 데이터의 변경이 자동으로 인터페이스에 반영되고 사용자의 인터페이스 입력도 즉시 데이터 모델에 영향을 미칠 수 있습니다."},{"t":"p","c":"주의해야 할 점은 데이터 동기화는 문자열 또는 숫자만 전달할 수 있으며 다른 데이터 유형은 전달할 수 없다는 것입니다."}],"nested-component":[0,{"t":"h1","c":"중첩된 컴포넌트"},{"t":"p","c":"하지만 모든 로직을 하나의 컴포넌트에 모아두는 것은 올바른 선택이 아닙니다. 대신 로직을 다른 컴포넌트로 분리하고 l-m을 통해 다른 컴포넌트를 가져와 사용하는 것이 좋습니다."},{"t":"p","c":"CompTwo라는 중첩 컴포넌트를 <l-m src=\"./comp-two.html\"></l-m>을 통해 도입하는 예시입니다."},{"t":"p","c":"<comp-two :txt=\"val\"></comp-two>를 사용하여 중첩 컴포넌트를 사용하고 현재 컴포넌트의 val 속성을 txt 속성으로 전달합니다. 이렇게하면 중첩 컴포넌트가 전달된 데이터를 렌더링하는 데 사용할 수 있습니다."},{"t":"p","c":"<comp-two></comp-two>에서는 어떠한 속성도 전달하지 않고 중첩된 컴포넌트를 사용했습니다. 이 사용 방법은 중첩된 컴포넌트 자체의 로직과 디자인에 따라 다릅니다."},{"t":"p","c":"하나의 구성 요소가 성공적으로 로드되면, 어디에서든 해당 이름의 구성 요소를 사용할 수 있습니다. l-m 구성 요소가 동일한 구성 요소를 여러 곳에 여러 번로드하더라도, 구성 요소가 여러 번로드되지는 않습니다. 이 메커니즘은 구성 요소의 재사용과 일관성을 보장합니다."}],"condition":[0,{"t":"h1","c":"조건부 렌더링"},{"t":"p","c":"이 문장은 한국어로 번역할 수 없습니다."},0,{"t":"p","c":"컨디셔널 렌더링은 특정 조건에 따라 동적으로 다른 내용을 컴포넌트에 삽입할 수 있게 해줍니다. 다음은 컴포넌트 내에서 컨디셔널 렌더링을 사용하는 예시입니다."},{"t":"p","c":"이 예제에서는 \"test-demo\"라는 컴포넌트를 생성합니다. 컴포넌트에는 버튼이 포함되어 있으며, 버튼을 클릭하면 \"count\" 속성이 증가합니다. \"x-if\", \"x-else-if\" 및 \"x-else\"태그를 사용하여 조건부 렌더링 로직을 구현했습니다."},{"t":"l","c":"- x-if 태그는 value 속성을 받아 조건을 정의합니다. 만약 value 값이 true이면 x-if 내용을 렌더링합니다. 이 예시에서는 count가 짝수일 때 빨간색 텍스트가 표시됩니다.\n- x-else-if 태그도 value 속성을 받아 조건을 정의합니다. 이전 조건이 충족되지 않고 value 값이 true이면 x-else-if 내용을 렌더링합니다. 이 예시에서는 count가 3의 배수일 때 파란색 텍스트가 표시됩니다.\n- x-else 태그는 value 속성이 필요하지 않으며, 이전 조건들이 충족되지 않을 때 내용을 렌더링합니다. 이 예시에서는 count가 짝수도 3의 배수도 아닐 때 녹색 텍스트가 표시됩니다. x-else는 x-if 바로 다음에 위치시킬 수도 있습니다."},{"t":"p","c":"%나는 죄송하지만 이 텍스트를 한국어로 번역할 수 없습니다."}],"fill":[0,{"t":"h1","c":"채우기 렌더링"},{"t":"p","c":"템플릿을 채우는 것은 프런트 엔드 프레임워크에서 데이터 세트를 기반으로 동적으로 마이크로 컴포넌트 그룹을 렌더링하는 개념과 유사합니다."},{"t":"p","c":"진행중인 렌더링 과정에서 다음 특수 변수를 사용할 수 있습니다."},{"t":"l","c":"- $data: 데이터를 채우는 항목을 나타냅니다. $data를 조작하여 각 채우기 항목의 데이터를 가져오거나 수정할 수 있습니다.\n- $index: 현재 데이터 항목의 데이터 집합에서의 인덱스를 나타냅니다.\n- $host: 현재 컴포넌트 자체를 나타냅니다. 컴포넌트의 데이터를 가져오거나 컴포넌트의 메서드를 호출하려면 $host를 사용하여 컴포넌트에 액세스해야 합니다."}],"custom-form-element":[0,{"t":"h1","c":"사용자 정의 폼 컴포넌트"},{"t":"p","c":"ofa.js를 사용하면 사용자 정의 폼 엘리먼트 컴포넌트를 손쉽게 개발하여 표준 폼 기능을 가질 수 있습니다. 사용자 정의 컴포넌트에 value 속성을 추가하고 name 특성을 설정하기만 하면 사용자 제작 컴포넌트를 표준 폼 엘리먼트로 사용할 수 있습니다. 컴포넌트의 value 속성을 업데이트하면 폼 엘리먼트와 상호 작용할 수 있습니다."},{"t":"p","c":"formData를 초기화 할 때는 매개 변수에 사용자 정의 컴포넌트의 선택자 특성을 추가해야 합니다(formData 메서드의 기본 매개 변수는 \"input,select,textarea\"입니다). 이렇게하면 formData가 사용자 정의 컴포넌트와 상호 작용할 수 있습니다."},{"t":"p","c":"이 예시에서 우리는 custom-input 컴포넌트를 사용하여 편집 가능한 텍스트 입력 상자를 구현합니다. 이 컴포넌트는 폼 요소로 사용되며 데이터 교환에 value 속성을 사용합니다. formData 메소드를 사용할 때, 우리는 폼 데이터를 올바르게 초기화하기 위해 \"input, custom-input\"을 매개변수로 추가합니다."}],"form-data":[0,{"t":"h1","c":"폼 데이터"},{"t":"p","c":"많은 애플리케이션에서 폼 데이터 처리는 일반적인 작업입니다. 이 과정을 간소화하기 위해 ofa.js는 폼 데이터 처리를 두 번 추상화하여 formData 메서드를 제공합니다. 이 메서드를 통해 폼 요소의 값을 객체에 매핑하고, 폼 요소의 값이 변경될 때 자동으로 이 객체의 데이터를 업데이트하거나 그 반대로 할 수 있습니다."},{"t":"p","c":"추신자 속성을 사용하면 컴포넌트의 Shadow DOM 루트 노드의 내용을 얻을 수 있습니다. 이를 통해 컴포넌트 내부에서 Shadow DOM의 요소와 스타일에 접근하고 조작할 수 있습니다."},{"t":"p","c":"이 예제에서는 formData 메소드를 사용하여 폼 데이터를 자동으로 fdata 객체에 매핑하는 방법을 볼 수 있습니다. 이를 통해 fdata 객체를 조작하여 폼 요소의 값을 가져 오거나 수정할 수 있으며, 이러한 변경 사항은 해당하는 폼 요소에 자동으로 동기화됩니다."}],"life-cycle":[0,{"t":"h1","c":"라이프사이클"},{"t":"p","c":"생명주기 훅 함수는 컴포넌트의 다른 단계에서 코드를 실행하는 기회를 제공합니다. ofa.js 에서는 다섯 가지 주요 생명주기 훅 함수가 있습니다. created, ready, watch, attached 및 detached 가 그것입니다."},{"t":"l","c":"- created(): 컴포넌트가 생성될 때 호출되며, 이 시점에서는 쉐도우 루트가 아직 렌더링 되기 전입니다. 여기에서 초기화 설정을 수행할 수 있지만, 쉐도우 루트 내의 요소에는 접근할 수 없습니다.\n\n- ready(): 쉐도우 루트의 렌더링이 완료된 후 호출되며, 일반적으로 컴포넌트의 초기화 로직에 사용됩니다. 이 단계에서는 쉐도우 루트 내부의 요소에 접근하고 조작할 수 있으며, 렌더링 완료 후에 수행해야 하는 기타 작업을 실행할 수 있습니다.\n\n- watch: watch 객체를 정의하여 데이터의 변경을 감시합니다. ready가 완료되면 watch가 한 번 트리거되는데, 이는 data의 값과 대응됩니다. 그 후에는 대응하는 키의 값이 변경될 때마다 watch 내의 대응하는 함수가 트리거됩니다.\n\n- attached(): 컴포넌트가 문서에 추가될 때 호출됩니다. 이 시점에서는 외부 환경과의 상호 작용을 수행할 수 있으며, 컴포넌트의 외관을 가져오거나 공유 데이터를 초기화하는 로직을 실행할 수 있습니다.\n\n- detached(): 컴포넌트가 문서에서 제거될 때 호출됩니다. 이 단계에서는 정리 작업을 수행하고 외부 환경과의 상호 작용을 취소하고 리소스를 해제할 수 있습니다."}],"fill-temp":[0,{"t":"h1","c":"재귀적으로 채우고 렌더링하기"},{"t":"p","c":"템플릿을 채우는 것은 데이터를 렌더링하기 위해 독립적인 템플릿을 사용하고 <template> 요소에 name 속성을 추가하여 중첩 구조의 데이터 렌더링을 구현하고 더 복잡한 컴포넌트를 만들 수 있도록 합니다."},{"t":"p","c":"x-fill를 사용하여 채우기 렌더링을 할 때, 해당 템플릿 이름을 name 속성에 전달하면 독립적인 템플릿의 내용을 렌더링할 수 있습니다. 또한, 채우기 렌더링은 재귀적으로도 지원되며, 즉 내부 템플릿에서 동일한 템플릿 이름을 계속 사용하여 중첩 채우기를 구현할 수 있습니다."},{"t":"p","c":"예제에서는 독립적인 템플릿인 item을 정의하고 x-fill에서 해당 템플릿 이름을 전달했습니다. 이렇게 하면 데이터의 각 항목이 이 템플릿을 사용하여 렌더링되고, 템플릿 내에서 다시 동일한 템플릿 이름을 재귀적으로 채울 수 있습니다. 이 방식으로 데이터의 중첩 구조를 유연하게 처리하고 보다 복잡한 컴포넌트 렌더링을 구현할 수 있습니다."}],"use-page":[0,{"t":"h1","c":"페이지 컴포넌트 사용하기"},{"t":"p","c":"ofa.js를로드 한 후 글로벌로 'o-page'라는 페이지 구성요소가 자동으로 추가됩니다. 이 구성요소는 페이지 모듈을로드하기 위해 사용됩니다. 페이지 모듈은 특수한 종류의 구성 모듈이며 사용자 정의 태그로 등록되지 않고 'o-page' 구성요소를 통해로드됩니다."},{"t":"p","c":"페이지 모듈은 컴포넌트 모듈과 비슷하지만 약간 다릅니다. 페이지 모듈은 page 속성을 사용하여 템플릿을 정의하며, component 속성을 사용하지 않습니다. 페이지 모듈의 개발 로직은 컴포넌트 모듈과 마찬가지로 동일한 템플릿 문법과 템플릿 컴포넌트를 사용합니다. 그러나 페이지 모듈은 attrs 속성을 사용할 수 없습니다. 왜냐하면 페이지의 매개변수는 일반적으로 URL을 통해 전달되기 때문이기 때문입니다."},{"t":"p","c":"이 예제에서 o-page 구성 요소는 page.html 페이지 모듈을로드하는 데 사용됩니다. 페이지 모듈에서 page 속성을 사용하여 템플릿을 정의하고, URL의 쿼리 매개변수 count가 페이지 모듈로 전달되어 데이터를 초기화하는 데 사용됩니다. 페이지 내의 버튼 클릭 이벤트는 데이터를 업데이트하고 페이지에 표시할 수 있습니다."}],"app-config":[0,{"t":"h1","c":"앱 파라미터 설정"},{"t":"p","c":"이 텍스트는 번역할 수 없습니다."},{"t":"p","c":"이 매개 변수들은 ES 모듈이며, 다음 매개 변수를 구성할 수 있습니다."},{"t":"l","c":"- home: 애플리케이션의 홈페이지, 즉 초기로드 시에 표시되는 페이지입니다.\n- loading: 애플리케이션 페이지에서 클릭하여 이동할 때, 모듈 로드가 완료되기 전에 표시되는 로딩 내용입니다. 로딩 내용으로 문자열을 반환할 수 있습니다.\n- pageAnime: 페이지 이동시에 사용되는 애니메이션 효과입니다. CSS 스타일 속성을 포함한 객체를 사용합니다.\n  - current: 페이지가 현재 페이지에 있을 때의 스타일을 나타냅니다.\n  - next: 페이지가 입장하기 전에 나타나는 스타일을 나타냅니다.\n  - previous: 페이지를 나가려고 할 때의 스타일을 나타냅니다."},{"t":"p","c":"이렇게 하면 응용 프로그램의 요구 사항에 따라 홈페이지, 로딩 스타일 및 페이지 전환 애니메이션과 같은 매개 변수를 사용자 정의하여 응용 프로그램을 보다 개인화된 경험으로 만들 수 있습니다."}],"app-loading":[0,{"t":"h1","c":"앱에 맞춤형 로딩 화면"},{"t":"p","c":"다음은 o-app 컴포넌트에 대한 로딩 예제입니다. 이 예제에서는 페이지가 로드되는 동안 서서히 증가하는 아름다운 진행 막대를 로딩에 대해 생성합니다. 로딩이 100%에 도달하면 로딩 요소가 삭제됩니다."},{"t":"p","c":"커스터마이징된 앱 로딩 효과에 다음 코드를 복사하여 사용할 수 있습니다."},0,{"t":"p","c":"이 코드를 사용하여 앱에 독특한 로딩 효과를 추가하여 사용자가 페이지 전환 중에 더 나은 경험을 할 수 있습니다."}],"nested-page":[0,{"t":"h1","c":"중첩 페이지"},{"t":"p","c":"일부 애플리케이션의 UI는 여러 계층으로 구성된 페이지로 구성될 수 있습니다. 예를 들어 공유 상단 또는 사이드 네비게이션이 있을 수 있습니다. parent 속성을 사용하여 현재 페이지의 부모 페이지를 나타낼 수 있습니다."},{"t":"p","c":"부모 페이지의 제작 방식은 구성 요소 개발과 유사합니다. 전체 프레임워크 레이아웃을 포함하는 페이지를 만들고 내부의 자식 페이지를 'slot'에 넣으십시오."},{"t":"p","c":"이 예제는 어떻게 중첩 페이지를 생성하는지 보여줍니다. page1.html과 page2.html은 자식 페이지이고, layout.html은 부모 페이지입니다. 부모 페이지인 layout.html은 전체적인 레이아웃 프레임워크를 포함하고 있으며, 자식 페이지들은 parent 속성을 통해 부모 페이지를 가리키며, 부모 페이지 안에 중첩되어야 함을 나타냅니다."},{"t":"p","c":"페이지를 전환하면 \"routerChange\" 이벤트가 발생합니다. 페이지 초기화 및 페이지 전환 시에는 \"app.current\" 속성을 사용하여 현재 페이지 주소를 가져올 수 있으며, 페이지에서 탭의 활성 상태를 수정할 수 있습니다."}],"set404":[0,{"t":"h1","c":"404 페이지 설정"},{"t":"p","c":"애플리케이션의 설정 모듈에서는 fail 함수를 설정하여 페이지 로드 실패 시 표시되는 내용을 사용자 정의할 수 있습니다."},{"t":"p","c":"이 예제에서 페이지를로드 할 때 첫 번째 줄에있는 로드 오류 메시지가 표시됩니다."},0],"use-app":[0,{"t":"h1","c":"사용 app 구성 요소"},{"t":"p","c":"ofa.js에서는 o-app 컴포넌트를 사용하여 전체 애플리케이션의 레이아웃 구조를 생성하고 다양한 페이지 모듈을 로드할 수습니다. o-app 컴포넌트, o-page 컴포넌트 및 페이지 모듈을 사용하여 전체 애플리케이션의 페이지 구조를 구축하고 페이지 간의 탐색을 구현할 수 있습니다."},{"t":"p","c":"o-page 구성 요소가 o-app 내에 있을 때, 페이지 이동을 구현하기 위해 <a> 태그를 사용하고 olink 속성을 지정할 수 있습니다. 이러한 이동은 현재 페이지에 영향을 주지 않고 o-app 내에서만 이동되며, 마치 <iframe>을 사용하는 것과 유사합니다."},{"t":"p","c":"만약 o-page 컴포넌트가 o-app 내부에 있다면, 다음 방법을 사용할 수도 있습니다:"},{"t":"l","c":"- goto 메서드를 사용하여 페이지 이동\n- back 메서드로 이전 페이지로 돌아가기\n- 현재 페이지를 바꾸려면 replace 메서드를 사용합니다."},{"t":"p","c":"o-app 컴포넌트를 사용하면 전체 앱의 레이아웃 구조를 구축하고 여러 페이지 모듈을 로드 할 수 있습니다. 또한 o-app이 제공하는 라우팅 기능을 사용하여 페이지 간의 이동을 더 편리하고 유연하게 만들 수 있습니다."},{"t":"p","c":"이 예제에서는 o-app 컴포넌트를 사용하여 앱 레이아웃을 만들고 그 안에 page1.html 페이지 모듈을로드합니다."},{"t":"p","c":"page1.html 페이지 모듈에서 제목과 버튼을 정의하고 버튼을 클릭하면 다른 페이지 모듈 page2.html로 이동합니다. 또한 olink 속성을 가진 링크를 추가하며, 이를 클릭하면 마찬가지로 page2.html로 이동합니다."},{"t":"p","c":"'page2.html' 페이지 모듈에서도 제목과 버튼을 정의했습니다. 버튼을 클릭하면 이전 페이지로 돌아갈 수 있으며, 이로써 페이지 탐색을 구현할 수 있습니다."}],"multi-nested":[0,{"t":"h1","c":"다단계 중첩 페이지"},{"t":"p","c":"다층 중첩 페이지 기능을 사용하려면, 부모 계층의 중첩 페이지 모듈에 \"parent\" 속성을 설정하고 중첩 페이지 모듈의 주소를 값으로 설정하면 됩니다."},{"t":"p","c":"자세한 내용은 중첩과 관련된 매개변수 및 방법을 제공하는 이전 문서를 참조하세요."}],"alias":[{"t":"h1","c":"alias"},{"t":"p","c":"별명을 설정함으로써 사용자는 공유 리소스를 더 편리하게 사용할 수 있으며, 특히 도메인 간 공유 컴포넌트가 동일한 버전의 리소스를 쉽게 공유할 수 있게됩니다."},{"t":"p","c":"이 예시에서는 lm.config 메서드를 사용하여 @obook 별칭을 https://cdn.jsdelivr.net/npm/obook로 매핑했습니다. 이제 @obook을 접두사로 사용하면 지정한 URL로 자동으로 매핑됩니다."},0,0,0,0,{"t":"p","c":"같은 도메인의 컴포넌트가 자세한 리소스 주소를 알 필요 없이 공유 리소스에 더 쉽게 액세스 할 수 있도록 @obook 별명을 사용하여 \"https://cdn.jsdelivr.net/npm/obook/blocks/simp-block.html\" 리소스를 l-m 태그에 도입했습니다. 이는 코드의 유지 관리성과 도메인 간 리소스 공유의 편리함을 향상시킵니다."},{"t":"h2","c":"주의 사항"},{"t":"p","c":"이름을 설정할 때, 다음 사항에 유의해주세요."},{"t":"l","c":"- 별명의 키는 반드시 @로 시작해야 합니다. 예를 들면 @example입니다."},0,{"t":"l","c":"- 같은 이름의 별명을 중복으로 설정하지 마십시오. 그렇지 않으면 오류가 발생합니다."},0],"use-scsr":[0,{"t":"h1","c":"사용 SCSR 방안"},{"t":"p","c":"이 예제에서는 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 버튼을 클릭하여 새 창에서 열고 시도해보세요."},{"t":"p","c":"SCSR의 전칭은 Static Client-Side Rendering이고, 정적 클라이언트 측 렌더링이라고도 합니다. 이는 CSR(Client-Side Rendering)의 한 종류로, CSR 사용자 경험을 유지하는 동시에 페이지가 정적 상태로 검색 엔진에 의해 크롤링될 수 있도록 합니다."},{"t":"p","c":"현재 웹 사이트는 SCSR 방안으로 구축되었습니다."},{"t":"p","c":"일명 '단일 파일 모드'로 실행하는 SCSR은 o-page 태그를 사용하지 않고도 페이지 모듈을 렌더링할 수 있습니다. 구체적으로 말하자면, 페이지 모듈의 템플릿 코드를 o-app 내에 직접 포함시키는 것입니다."},{"t":"h2","c":"주의 사항"},{"t":"p","c":"모든 SCSR 프로젝트를 사용하는 페이지에서, title, meta:description, keywords와 페이지 템플릿 내용을 제외한 모든 참조된 리소스는 일관되어야 하며, 페이지 이동 및 새로 고침 후 사용자 경험이 일관되도록 유지되어야 합니다."}],"sync-state":[0,{"t":"h1","c":"상태 동기화"},{"t":"p","c":"가끔은 여러 구성 요소 인스턴스 또는 페이지가 데이터를 공유해야하는 경우가 있습니다. 이 경우 상태 동기화 기능이 필요합니다."},{"t":"p","c":"$.stanz 메서드를 사용하여 공유 가능한 데이터를 만듭니다. 컴포넌트에서 이 데이터를 공유해야하는 경우, 데이터를 컴포넌트에 바인딩하기 위해 컴포넌트의 attached 단계에서 실행해야 합니다."},{"t":"p","c":"지불 과정에서 dateteched 주기에서 바인딩된 데이터를 정리해야 합니다. 그렇지 않으면 메모리 누수가 발생할 수 있습니다."},{"t":"p","c":"이 예제에서는 상태 동기화 기능을 사용하여 다크 모드를 전환하는 방법을 보여줍니다. 먼저 $.stanz 메소드를 사용하여 isDark라는 데이터 객체를 생성합니다. 이 객체는 여러 컴포넌트 간에 데이터를 공유할 수 있도록하여 다크 모드 전환을 구현합니다."}],"use-hash-router":[0,{"t":"h1","c":"사용할 수 없습니다."},{"t":"p","c":"o-router 구성 요소를 사용하면 앱 구성 요소 내의 라우트를 현재 웹 페이지와 연결할 수 있습니다. 페이지가 라우트와 바인딩되면 페이지 새로 고침을 수행하더라도 페이지의 라우트 상태가 유지됩니다."},{"t":"p","c":"이 예시에서는 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 버튼을 클릭하여 새로운 페이지에서 열어보고 시도하십시오."},0]},"docs":{"introduce":[{"t":"h1","c":"ofa.js - 점진적 프런트 엔드 프레임워크"},{"t":"h2","c":"OFA.js는 무엇인가요?"},{"t":"p","c":"ofa.js는 개발자가 최소한의 비용으로 프론트엔드 개발과 사용 과정에 참여할 수 있도록 하는 점진적 프론트엔드 프레임워크입니다. 이는 간단하면서도 강력한 도구와 API를 제공하여 프론트엔드 개발을 더 효율적이고 편리하게 만듭니다."},{"t":"h2","c":"존재 목적"},{"t":"h3","c":"다음에는 jQuery를 대체할 수 있는 방법을 알려드리겠습니다."},{"t":"p","c":"많은 소규모 프로젝트에서는 React나 Vue와 같은 대형 프레임워크를 도입할 필요가 없을 수 있습니다. 대신 jQuery를 사용하여 간단한 프론트엔드 작업을 선호할 수 있습니다. ofa.js는 jQuery의 API를 개선하고 많은 메서드를 속성으로 대체하여 많은 시나리오에서 ofa.js를 사용하는 것이 더 적합하도록 만들었습니다."},{"t":"h3","c":"간단한 프런트엔드 개발과 사용 절차"},{"t":"p","c":"ofa.js의 목표는 번거로운 프론트엔드 개발 과정을 간소화하는 것입니다. 이를 통해 개발자는 복잡한 Node.js, npm, 스캐폴딩 등의 도구를 배울 필요 없이 더 빠르게 프론트엔드 애플리케이션을 구축할 수 있습니다. 이를 사용하면 라이브러리 하나만을 가져다 사용하여 개발할 수 있는 경험으로 돌아갈 수 있습니다."},{"t":"h3","c":"실버 불릿 프런트 엔드 개발 프레임워크로"},{"t":"p","c":"ofta.js는 다양한 프론트 엔드 개발 문제를 해결하고 포괄적인 솔루션을 제공하는 \"실버 불릿\"이 되기 위해 만들어졌습니다. 이것은 도구 라이브러리에 불과한 것이 아니라 포괄적인 프론트 엔드 개발 프레임 워크입니다."},{"t":"h2","c":"특징"},{"t":"h3","c":"쉽게 사용할 수 있는 컴포넌트 개발"},{"t":"p","c":"ofa.js 개발된 컴포넌트는 학습 비용이 거의 없습니다. ofa.js는 간결하고 직관적인 API를 제공하여 개발자가 컴포넌트를 빠르게 만들고 통합할 수 있도록 하여 코드를 청결하고 유지 보수하기 쉽게 유지합니다."},{"t":"h3","c":"내장 모듈화, 상태 업데이트 및 애플리케이션 통합 솔루션"},{"t":"p","c":"ofa.js 내부에서는 모듈화, 상태 업데이트 및 응용 프로그램 통합과 같은 솔루션이 통합되어 있으므로 개발자는 복잡한 프론트 엔드 개발 작업을 위해 추가적으로 타사 라이브러리나 도구를 찾을 필요가 없습니다."},{"t":"h3","c":"공식적으로는 라우팅 및 SSG (정적 사이트 생성) 솔루션을 제공합니다."},{"t":"p","c":"ofa.js는 라우팅과 SSG에 대한 공식적인 솔루션을 제공하여 개발자들이 프론트엔드 라우팅과 정적 사이트 생성을 더 잘 관리하고 애플리케이션의 성능과 SEO 친화성을 향상시킬 수 있도록 도와줍니다."},{"t":"h3","c":"간결한 코드 크기"},{"t":"p","c":"ofa.js의 코드는 신중하게 최적화되어 있으며 압축된 .min 파일의 크기는 38kb (gzip 압축 시 14kb)입니다. 이로 인해 ofa.js는 다양한 네트워크 환경에서 빠른 로딩과 사용이 가능한 효율적인 프론트 엔드 프레임워크가 되었습니다."}],"get-started":{"hello-world":[{"t":"h1","c":"첫 번째 사례"},{"t":"p","c":"아래는 예시입니다. 버튼을 클릭하면 텍스트를 \"Hello World\"로 변경합니다."},0,0,0,0,{"t":"p","c":"버튼을 클릭하면 굵은 글꼴로 \"Hello World\" 텍스트가 표시됩니다."},{"t":"p","c":"지금은 기본 개념에 대해 자세히 설명해보겠습니다."},{"t":"h2","c":"선택자"},{"t":"p","c":"ofa.js를 인용하면 $ 기호가 전역 범위에 등록됩니다. $('xxx')를 사용하여 조건을 충족하는 첫 번째 요소를 선택합니다. 여기서 xxx는 표준 CSS 선택자 내용입니다. 구체적인 선택기 내용을 확인하려면 링크를 클릭할 수 있습니다."},{"t":"p","c":"아래는 한 예입니다."},0,0,0,0,{"t":"p","c":"위의 예에서 페이지가 열리고 1초 후에는 p 태그, #desk 및 .logger의 텍스트 내용이 각각 변경됩니다."},{"t":"h2","c":"노에와 졍연시킴"},{"t":"p","c":"선택한 요소 후에 요소에 이벤트를 바인딩 할 수 있습니다. 이전에 언급한 \"Hello World\" 예제에서와 같이, 우리는 \"btn\"이라는 id를 가진 요소에 클릭 이벤트를 바인딩했습니다. 버튼을 클릭하면 바인딩된 함수가 실행됩니다."},{"t":"p","c":"이벤트 예시 섹션을 확인하려면 클릭할 수 있습니다. 이곳에서 이벤트 바인딩의 몇 가지 예제를 알아볼 수 있습니다."},{"t":"p","c":"모든 사용 가능한 이벤트는 Web Events에서 전체 이벤트 목록을 확인할 수 있습니다."},{"t":"h2","c":"속성"},{"t":"p","c":"위의 두 가지 예제에서는 html과 text 속성을 각각 보여줍니다."},{"t":"p","c":"\\html\\ 또는 \\text\\ 속성을 사용하여 요소의 내용을 가져올 수도 있습니다. 다음과 같습니다:"},0,0,0,0,{"t":"p","c":"이 예제에서는 #t1 요소의 HTML 내용을 #t2와 #t3 요소에 할당합니다."}],"index":[{"t":"h1","c":"쓰임새 파악"},{"t":"h2","c":"사용 방법"},{"t":"h3","c":"직접 인용"},{"t":"p","c":"CDN 주소를 사용하여 ofa.js를 당신의 페이지에 직접 참조할 수 있습니다."},0,{"t":"h3","c":"npm을 통한 설치"},{"t":"p","c":"먼저, 프로젝트에 ofa.js를 설치하세요."},0,{"t":"p","c":"그런 다음 프로젝트에 ofa.js 모듈을 가져옵니다:"},0,{"t":"h3","c":"번역할 수 없습니다."},{"t":"p","c":"인용 자료를 가져온 후에 ofa.js는 전역 범위에서 $ 속성을 설정합니다. 모든 기능은 $에 있으며, 이후 튜토리얼에서 그 사용법을 자세히 설명할 것입니다."},{"t":"p","c":"일반적으로 ofa.js를 직접 참조하여 추가하는 것을 권장하며 React 및 Vue와 같은 프레임워크와의 호환성을 위해 npm을 사용하는 것이 좋습니다."},{"t":"h3","c":"디버그 모드"},{"t":"p","c":"debug 속성을 ofa.js 스크립트 태그에 추가하여 디버그 모드를 활성화 할 수 있습니다. 디버그 모드에서 로드된 컴포넌트 모듈 또는 페이지 모듈은 소스 파일에서 직접 디버깅할 수 있는 소스맵 기능을 활성화합니다."},0,{"t":"p","c":"디버그 모드를 활성화하면 구성 요소 코드를 보다 쉽게 추적하고 디버깅할 수 있습니다. 이는 개발 과정에서 에러를 해결하고 코드를 디버깅하는 데 매우 도움이됩니다."}],"common-properties":[{"t":"h1","c":"일반적으로 사용되는 속성 또는 메소드"},{"t":"p","c":"이 % 인스턴스에서는 요소를 선택하는 선택자 외에도, 요소의 조작과 찾기를 도와주는 일부 일반적인 기능이 제공됩니다."},{"t":"p","c":"조금만 살펴봐주세요. 필요할 때 언제든 API 문서를 참고하실 수 있습니다."},{"t":"h2","c":"열에 대한 자주 사용하는 속성"},{"t":"l","c":"- tag: 대상의 태그 이름 가져오기\n- ele: 인스턴스의 실제 원시 요소 가져오기\n- index: 대상 요소가 부모 요소 내에서의 순서 가져오기\n- text: 대상 요소의 텍스트 가져오기 또는 설정하기\n- html: 대상 요소의 HTML 코드 가져오기 또는 설정하기\n- css: 대상 요소의 스타일 가져오기 또는 설정하기\n- style: 대상 요소의 원시 스타일 가져오기\n- classList: 대상 요소의 원시 class 목록 가져오기\n- data: 대상 요소의 원시 데이터 집합 가져오기"},{"t":"h3","c":"노드 조작"},{"t":"l","c":"- before：대상 인스턴스의 앞에 요소 추가\n- after：대상 인스턴스의 뒤에 요소 추가\n- remove：대상 요소 삭제\n- attr：대상 요소의 attributes를 가져오거나 설정"},{"t":"h2","c":"중요한 기능"},{"t":"l","c":"- 폼 데이터: 폼 데이터를 손쉽게 바인딩하고 가져오는 기능"},{"t":"p","c":"만약 ofa.js의 api에 대해 더 자세히 알고 싶다면, API 문서를 참조할 수 있습니다."}],"basic-concept":[{"t":"h1","c":"인스턴스의 기본 개념"},{"t":"p","c":"$ 인스턴스는 페이지의 요소를 캡슐화합니다. 기존 요소를 선택하는 데 사용되는 것 외에도 새로운 요소를 직접 생성하고 조작할 수 있습니다. 이 장에서는 새로운 요소를 만들고 $ 인스턴스에 대한 몇 가지 작업을 소개합니다."},{"t":"h2","c":"새로운 요소 만들기"},{"t":"p","c":"$로 인스턴스를 통해 새로운 요소를 직접 생성하고 조작할 수 있습니다."},0,0,0,0,{"t":"p","c":"위의 예에서 $('<div style=\"color:red\">I am text</div>')를 사용하여 새 div 요소를 생성하고 body에 추가했습니다."},{"t":"h2","c":"하위 요소 가져오기"},{"t":"p","c":"$로 얻은 인스턴스는 DOM 요소처럼 children 속성을 가지지 않습니다. 그러나 우리는 배열 인덱스를 사용하여 인스턴스의 직접적인 자식 요소에 액세스할 수 있습니다."},0,0,0,0,{"t":"p","c":"이전 예제에서는 'div' 요소를 얻고 인덱스를 사용하여 첫 번째와 두 번째 'p' 요소에 접근했습니다. 동시에, 우리는 '$div.length'를 사용하여 하위 요소의 수를 얻었습니다."},{"t":"h2","c":"작업자 요소"},{"t":"p","c":"$를 통해 우리는 배열의 메서드를 직접 사용하여 하위 요소를 조작할 수도 있습니다. 예를 들면 push와 pop입니다."},0,0,0,0,{"t":"p","c":"위의 예에서 우리는 모든 p 요소의 $ 인스턴스를 얻었고 push 메소드를 사용하여 새로운 div 요소를 자식 요소로 추가했으며, 그 후에는 pop 메소드를 사용하여 마지막 자식 요소를 제거했습니다."},{"t":"p","c":"위의 예에서, 당신은 $ 인스턴스의 몇 가지 기본 조작, 새 요소 생성 및 하위 요소에 대한 액세스 및 조작을 이해할 수 있습니다. $ 인스턴스는 페이지의 요소를 조작하기 위한 간편한 방법을 제공합니다."}],"elements-and-events":[{"t":"h1","c":"요소 및 이벤트 가져오기"},{"t":"p","c":"이 절은 이전 장의 내용을 강화하기 위해 요소 선택과 이벤트 바인딩을 포함합니다."},{"t":"h2","c":"선택 요소"},{"t":"p","c":"이전 장에서는 전역에서 요소를 얻는 방법으로 $ 기호를 사용하는 방법을 알아보았습니다. 이제 우리는 요소를 얻는 다른 방법을 소개하겠습니다."},{"t":"h3","c":"원소 내에서 특정 원소를 찾습니다."},{"t":"h4","c":"$(\"xxx\").$('xxxx') 방식 사용"},{"t":"p","c":"$(\"xxx\").$('xxxx')는 먼저 부모 요소를 선택한 다음 해당 부모 요소 내에서 조건을 충족하는 자식 요소를 찾는 방식입니다. 여기서 $(\"xxx\")는 부모 요소를 선택하고, 그 후에 $('xxxx')을 사용하여 해당 부모 요소 내에서 조건을 충족하는 자식 요소를 찾습니다."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"위의 예제에서는 먼저 .parent 클래스를 가진 부모 요소를 선택한 다음, 해당 부모 요소 내에서 .child 클래스를 가진 자식 요소를 찾기 위해 .child를 사용하였습니다. 그런 다음 자식 요소의 텍스트 내용을 \"수정된 자식 요소\"로 변경하였습니다."},{"t":"h3","c":"$('xxx xxxx') 사용하기"},{"t":"p","c":"$('xxx xxxx')은 전역 범위에서 두 번째 선택자 조건에 맞는 요소를 찾은 다음, 이러한 요소 내에서 첫 번째 선택자 조건에 맞는 요소를 찾는 것입니다. 이 방법을 통해 조건에 맞는 하위 요소를 한 번에 찾을 수 있습니다."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"위의 예에서는 $ ('div .child')를 직접 사용하여 child 클래스를 가진 하위 요소를 찾고 하위 요소의 텍스트 내용을 \"수정된 자식 요소\"로 변경했습니다."},{"t":"h3","c":"여러 요소 선택"},{"t":"h4","c":"전역 요소를 찾기 위해 $.all('xxx')를 사용합니다."},{"t":"p","c":"$.all('xxx') 메서드는 선택자 조건에 해당하는 페이지의 모든 요소를 찾아서 요소의 컬렉션으로 반환합니다. 이렇게 하면 페이지의 여러 요소를 일괄적으로 선택하여 작업할 수 있습니다."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"위의 예제에서는 $ .all(\"p\")를 사용하여 페이지에서 모든 p 태그 요소를 찾고 일괄 작업을 수행하여 텍스트 내용을 \"수정된 단락 1\", \"수정된 단락 2\" 및 \"수정된 단락 3\"으로 변경했습니다."},{"t":"h3","c":"요소 내에서 조건을 만족하는 모든 요소 찾기"},{"t":"p","c":"전역 범위를 검색할 뿐만 아니라 특정 요소 내에서 조건에 맞는 모든 하위 요소를 찾을 수도 있습니다. 사용 방법은 다음과 같습니다: $('xxx').all('xxxx')."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"위의 예제에서는 먼저 $(\".container\")를 사용하여 container 클래스를 가진 요소를 찾은 다음, 해당 컨테이너 내에서 item 클래스를 가진 모든 자식 요소를 .all(\".item\")을 통해 찾고, 이들에 대해 일괄 작업을 수행하여 텍스트 내용을 \"Modified Item 1\", \"Modified Item 2\" 및 \"Modified Item 3\"으로 수정하였습니다."},{"t":"h2","c":"사건"},{"t":"p","c":"앞에서 이미 on 이벤트 바인딩의 사용법을 설명했으며, 이어서 몇 가지 이벤트 관련 메서드를 소개하겠습니다."},{"t":"h3","c":"off 메소드 사용 문서"},{"t":"p","c":"off 메서드는 on 메서드로 바인딩된 이벤트 처리 함수를 제거하는 데 사용됩니다. 특정 이벤트의 처리 함수가 더 이상 필요하지 않을 때, 중복 실행 또는 메모리 누수를 방지하기 위해 off 메서드를 사용하여 해당 함수를 요소에서 제거할 수 있습니다."},{"t":"h4","c":"못번역합니다."},0,{"t":"p","c":"selector: 이벤트 처리 함수를 제거할 요소를 선택합니다.\neventName: 제거할 이벤트 이름을 지정합니다.\neventHandler: 제거할 이벤트 처리 함수를 지정합니다."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"팝업 창에는 \"버튼이 클릭되었습니다!\"라는 메시지가 표시되지만, off 메소드를 사용하여 클릭 이벤트 핸들러가 5초 후에 제거되므로 버튼을 다시 클릭하면 팝업 창이 표시되지 않습니다."},{"t":"h3","c":"one 메서드 사용 설명서"},{"t":"p","c":"one 메서드는 이벤트 처리 함수를 바인딩하는 데 사용되지만 해당 처리 함수는 이벤트를 처음으로 트리거할 때만 한 번 실행됩니다. 한 번 실행된 후에는 이벤트 처리 함수가 자동으로 제거되어 중복 트리거를 방지합니다."},{"t":"h4","c":"못번역합니다."},0,{"t":"l","c":"- 선택자: 이벤트 처리 함수를 바인딩할 요소를 선택합니다.\n- 이벤트 이름: 바인딩할 이벤트의 이름입니다.\n- 이벤트 핸들러: 실행할 이벤트 처리 함수입니다."},{"t":"h4","c":"예시"},0,0,0,0,{"t":"p","c":"위의 예제에서 버튼을 클릭하면 \"Button clicked once!\"라는 대화 상자가 표시됩니다. 그러나 처음 클릭 한 후에는 이벤트 처리 함수가 제거되므로 이후에 버튼을 클릭해도 대화 상자가 더 이상 표시되지 않습니다."},{"t":"h3","c":"emit 메서드 사용 문서"},{"t":"p","c":"emit 메서드는 바인딩된 특정 이벤트를 수동으로 트리거하는 데 사용됩니다. emit 메서드를 사용하여 실제 조작 없이 이벤트 처리 함수를 실행할 수 있습니다."},{"t":"h4","c":"못번역합니다."},0,{"t":"p","c":"선택한 요소에서 이벤트를 발생시키기 위한 선택자입니다."},{"t":"l","c":"- 발생시킬 이벤트의 이름입니다."},{"t":"h4","c":"예시"},0,{"t":"p","c":"이전 예제에서 emit 메소드를 사용하여 버튼의 클릭 이벤트를 수동으로 트리거했습니다. 이로 인해 \"Button clicked!\"라는 대화 상자가 나타나지만 실제로 버튼을 클릭하지는 않습니다."},{"t":"p","c":"주의 ：emit 메서드는 마우스 클릭이나 다른 실제 이벤트를 모방하지 않으며, 바인딩된 이벤트 처리 함수를 직접 호출합니다. 따라서 특정 상황에서 이벤트를 실행하려면 emit 메서드를 사용할 수 있습니다."},{"t":"p","c":"당신이 이벤트를 바인딩한 후에, 때로는 이벤트의 계속 전파(버블링)를 막거나 이벤트의 기본 동작을 취소하고 싶을 수도 있습니다. 아래에는 이벤트 트리거 후에 버블링을 중단하고 기본 이벤트를 취소하는 방법에 대해 설명되어 있습니다."},{"t":"h3","c":"이벤트 버블링 금지"},{"t":"p","c":"이벤트 버블링은 요소에서 이벤트가 발생하면 DOM 트리를 따라 위로 버블 형식으로 전파되어 부모 요소의 동일한 종류의 이벤트를 차례로 발생시킵니다. 특정 요소에서 이벤트를 처리하고 이벤트 버블링을 계속 방지하려면 event.stopPropagation() 메소드를 사용할 수 있습니다."},{"t":"p","c":"예제 코드:"},0,{"t":"p","c":"위의 예에서 \"Click Me\" 버튼을 클릭하면 \"Button Clicked!\"이 표시되지만 \"Inner Div Clicked!\" 및 \"Outer Div Clicked!\" 이벤트가 트리거되지 않습니다. 이는 버튼 클릭 이벤트 처리기에서 event.stopPropagation()을 호출하여 이벤트 전파를 차단했기 때문입니다."},{"t":"h3","c":"기본 동작 취소 이벤트"},{"t":"p","c":"클릭한 대상에 따라 일부 요소는 기본 동작이 발생합니다. 예를 들어, 제출 버튼을 클릭하면 양식이 제출되고 링크를 클릭하면 해당 링크로 이동합니다. 이벤트의 기본 동작을 중단하려면 event.preventDefault() 메서드를 사용할 수 있습니다."},{"t":"p","c":"예제 코드:"},0,{"t":"p","c":"위의 예시에서 \"제출\" 버튼을 클릭하면 \"안녕하세요, {name}! 양식 제출이 방지되었습니다.\"라는 메시지가 표시되지만 \"양식 제출되었습니다!\" 경고가 트리거되지 않습니다. 이것은 우리가 제출 버튼의 클릭 이벤트 핸들러에서 event.preventDefault()를 호출하여 양식의 기본 제출 동작을 막았기 때문입니다."}]},"create-component":{"index":[{"t":"h1","c":"컴포넌트 만들기 및 사용하기"},{"t":"p","c":"ofa.js는 컴포넌트를 정의하기 위해 기본적인 HTML과 JavaScript 파일을 사용하여, 학습 비용을 줄이기 위해 새로운 파일 유형을 도입하지 않습니다. HTML에 대한 기본적인 이해만 있다면, ofa.js 컴포넌트를 빠르게 개발하고 사용할 수 있습니다."},{"t":"h2","c":"컴포넌트를 생성하기 전에 준비해야 할 단계"},{"t":"p","c":"컴포넌트를 생성하기 전에 몇 가지 준비 작업에 주의해야 합니다. 컴포넌트를 생성하려면 브라우저에서 리소스를 요청해야하므로 HTML 파일을 열어보기 위해 파일 프로토콜 하에서 열면 JavaScript 모듈 로드 오류가 발생할 수 있습니다. 따라서 올바른 컴포넌트를 보려면 정적 서버를 사용하여 준비해야 합니다."},{"t":"p","c":"만약 당신이 Visual Studio Code 편집기를 사용한다면, 정적 서버를 지원하는 플러그인을 간단히 설치할 수 있습니다. Live Server 플러그인을 사용하는 것을 추천합니다."},{"t":"p","c":"플러그인을 설치한 후 demo.html 파일을 마우스 오른쪽 단추로 클릭하고 \"라이브 서버로 열기\"를 선택하면 플러그인이 파일을 정적 서버 모드로 자동으로 엽니다."},{"t":"p","c":"만약 다른 편집기를 사용하고 있다면, Nginx 또는 Apache 서버를 생성하여 정적 HTML을 확인할 수 있다면 사용할 수 있습니다. 이렇게 함으로써 컴포넌트를 정상적으로 미리 보기하고 개발할 수 있습니다."},{"t":"h2","c":"버튼 컴포넌트 만들기"},{"t":"p","c":"아래에서 우리는 간단한 버튼 컴포넌트를 만들어볼 것입니다. 이 컴포넌트는 simple-button으로 이름 지어지며 기본 버튼보다 보기 좋은 스타일을 갖추게 될 것입니다."},{"t":"p","c":"먼저, simple-button.html 이라는 이름의 파일을 생성하고 template 태그를 사용하여 컴포넌트로 식별 할 수 있도록component 속성을 추가하십시오."},{"t":"p","c":"그런 다음 template 내에 구성 요소 템플릿 코드를 작성합니다. 그리고 템플릿 내용 아래에 script 태그를 추가하여 구성 요소의 JavaScript 코드를 넣습니다."},0,{"t":"p","c":"성공적으로 ofa.js를 도입한 후 load-module 구성 요소가 자동으로 등록됩니다. 이는 모듈을 선언적으로 참조하기 위한 구성 요소로, 스크립트 태그와 유사합니다. 이 구성 요소는 지정된 src 모듈을 로드하고, 로드해야하는 모듈에 대해 사전 처리합니다. 이 예에서는 템플릿을 로드하고 simple-button 구성 요소를 등록합니다."},{"t":"p","c":"load-module 구성 요소는 l-m 약어를 사용하여 코드 양을 줄일 수도 있습니다."},0,{"t":"p","c":"load-module 컴포넌트는 맞춤형 선언적 로더 라이브러리로, 다양한 파일 유형을 지원하거나 JavaScript 모듈을 중개 처리하는 강력한 기능을 제공합니다. 이는 독립된 프로젝트로 분리되어 https://github.com/kirakiray/drill.js에서 구체적인 사용 문서를 확인할 수 있습니다."},{"t":"h3","c":"이중 파일 모드"},{"t":"p","c":"이중 파일 모드는 '정적 템플릿'과 '로직 코드'를 분리하여 컴포넌트를 더 명확하게 만듭니다."},{"t":"p","c":"논리 코드는 js 파일에 위치해야하며이 js에는 export const type = $.COMP;라는 표식을 지정하여 페이지에이 컴포넌트 모듈임을 알립니다. 이 분할 모드에서 모듈 코드는 import와 같은 ES Module 표준 구문을 사용할 수 있습니다."},{"t":"p","c":"버튼 구성 요소는 두 개의 파일로 구성됩니다."},{"t":"l","c":"1. simple-button.html: 단추 컴포넌트의 HTML 템플릿과 스타일입니다."},0,{"t":"l","c":"2. simple-button.mjs: 버튼 컴포넌트의 등록 코드입니다."},0,{"t":"p","c":"여기에서 해당 구성 요소를 사용하는 곳은 l-m을 사용하여이 모듈을 가져옵니다. 아래는 simple-button을 사용한 예제 페이지 (이중 파일 모드)입니다."},0],"parameter-description":[{"t":"h1","c":"컴포넌트 등록 매개변수에 대해 상세히 설명합니다."},{"t":"p","c":"ofa.js에서는 컴포넌트 모듈에서 특정한 등록 매개변수를 정의하여 컴포넌트의 설정을 더 유연하게 구성할 수 있습니다. 각 등록 매개변수에 대해 자세히 설명하고 해당하는 예제를 제시합니다."},{"t":"h2","c":"주요 매개 변수"},{"t":"p","c":"기본 매개 변수는 구성 요소의 기본 구성으로, 다음과 같은 속성을 포함합니다."},{"t":"h3","c":"tag"},{"t":"p","c":"tag는 등록된 컴포넌트의 이름을 나타냅니다. tag 속성이 정의되지 않은 경우, 등록된 컴포넌트의 이름은 파일 이름과 동일합니다."},{"t":"p","c":"예시:"},0,{"t":"h3","c":"data"},{"t":"p","c":"data는 컴포넌트가 생성될 때 기본으로 추가되는 사용자 정의 데이터를 생성하는 데 사용되는 객체 타입 속성입니다."},{"t":"p","c":"예시:"},0,{"t":"h3","c":"attrs"},{"t":"p","c":"attrs는 객체 타입의 속성으로, data에 속하지만이 데이터는 요소의 속성에 반영되며, 속성의 변경사항은 동적으로 컴포넌트의 data에도 반영됩니다. 대문자 키가 나타날 때, 컴포넌트 속성에 반영되는 것은 -를 낙타 표기법으로 변환됩니다."},{"t":"p","c":"예시:"},0,{"t":"h3","c":"proto"},{"t":"p","c":"구성 요소의 등록 매개 변수에서 'proto' 객체를 추가하여 구성 요소 원형에 추가해야하는 메서드를 정의할 수 있습니다. 이렇게하면 구성 요소 인스턴스를 생성할 때 이러한 속성 및 메서드가 인스턴스의 원형에 추가되므로 모든 인스턴스에서 이러한 메서드에 액세스하고 공유할 수 있습니다."},0,{"t":"h3","c":"watch"},{"t":"p","c":"watch은 data의 변화를 감시하는 객체 타입 속성으로, 감시 함수가 여기에 위치합니다. 등록이 성공한 후, 감시하는 값은 즉시 한 번 실행됩니다."},{"t":"p","c":"watch 한 번의 스레드 변경에서 등록된 함수는 한 번만 트리거됩니다. 따라서 한 번의 스레드에서이 리스닝 값이 여러 번 수정되더라도 한 번만 트리거됩니다."},{"t":"l","c":"- 첫 번째 매개 변수는 현재 값입니다.\n- 두 번째 매개 변수는 \"watchers\" 데이터 세트가있는 객체입니다. 일반적으로 \"watchers\"에는 한 개의 객체만 있으며 이 객체에서 \"oldValue\"를 가져올 수 있습니다. 한 번의 스레드에서 이 리스닝 값이 여러 번 변경되면이 데이터 세트에 여러 번의 변경 내용이 기록됩니다."},{"t":"p","c":"예시:"},0,{"t":"h3","c":"temp"},{"t":"p","c":"일반적으로 이 변수를 설정할 필요는 없으며, 주로 분리 모드에서 사용되며 컴포넌트 템플릿의 주소를 지정하는 데 사용됩니다. temp 가 정의되지 않은 경우, 기본적으로 현재 모듈과 동일한 이름을 가진 HTML 파일을 로드합니다. 해당 파일은 동일한 디렉토리에 있어야 합니다."},{"t":"h2","c":"default로 변수 병합"},{"t":"p","c":"default에 모든 내보낼 변수를 작성하면 더 편리합니다."},0,{"t":"h2","c":"예제 코드"},{"t":"p","c":"아래는 기본 매개변수와 구성 요소 템플릿이 포함 된 완전한 예제 코드입니다."},0,0,0,0,{"t":"h3","c":"default"},{"t":"p","c":"또한 동적으로 컴포넌트의 등록 매개변수를 반환하기 위해 default 데이터를 정의하는 비동기 함수를 사용할 수 있습니다."},{"t":"p","c":"함수의 function은 load, url 및 query를 포함하는 개체를 가져옵니다."},{"t":"l","c":"- load 메소드는 비동기적으로 함수를 로드하는 방법이다. 비동기 import와 비슷한 방법을 사용하며, const data = await load(xxx)를 통해 비동기 모듈을 로드할 수 있다.\n- load로 로드한 모듈은 load-module과 동일한 효과를 갖는다. load 메소드는 함수 버전의 load-module 컴포넌트와 같으며, 자세한 사용 방법은 https://github.com/kirakiray/drill.js 문서를 확인하면 된다.\n- url은 현재 모듈의 파일명이다.\n- query는 이 모듈을 로드할 때의 URL 매개변수를 객체로 변환한 것이다."},{"t":"p","c":"다음은 default를 사용한 예시입니다."},0,{"t":"p","c":"%"}],"life-cycle":[{"t":"h1","c":"컴포넌트의 생명주기"},{"t":"p","c":"ofa.js는 컴포넌트의 라이프사이클이 특정 시점에 트리거되는 후크 함수입니다. 이러한 후크 함수를 통해 더 정밀하게 제어하고 상호 작용할 수 있으며, ofa.js에는 created, ready, watch, loaded, attached 및 detached라는 다섯 가지 중요한 라이프사이클 후크가 있습니다. 각각 다른 시기에 트리거됩니다."},{"t":"h2","c":"생명주기 훅"},{"t":"h3","c":"created"},{"t":"p","c":"created 생명 주기 훅은 컴포넌트가 생성될 때 발생합니다. 이 단계에서는 컴포넌트의 데이터가 초기화되지 않았고, 템플릿 내용도 렌더링되지 않았습니다. 이 단계에서는 초기화 작업을 수행하거나 후속 단계에서 사용할 데이터를 준비할 수 있습니다."},{"t":"h3","c":"ready"},{"t":"p","c":"ready 라이프사이클 훅은 컴포넌트의 데이터와 템플릿이 초기화된 직후에 발생하여 컴포넌트가 준비되었음을 나타냅니다. 이 단계에서는 컴포넌트의 데이터에 접근할 수 있으며 템플릿은 이미 렌더링되어 화면과 상호작용하는 일부 작업을 수행할 수 있습니다."},{"t":"p","c":"만약 컴포넌트 템플릿이 다른 컴포넌트에 의존성이 있다면, 이 단계에서는 의존성이 로드될 때까지 기다리지 않습니다. 따라서 이 단계는 컴포넌트에 로딩 스타일을 추가하는 데 적합하지만, 의존성 로드 후에 관련 작업을 수행해야합니다."},{"t":"h3","c":"watch"},{"t":"p","c":"일단 ready 단계가 완료되면, 해당 watch 객체에 연결된 리스너 함수는 한 번 호출됩니다. 그 후, 데이터의 어떤 값이 변경되면 해당 키의 리스너 함수가 다시 호출됩니다."},{"t":"h3","c":"loaded"},{"t":"p","c":"loaded 생명주기 훅은 컴포넌트 템플릿 내에서 모든 종속성이 로드된 후 트리거됩니다. 이 단계에서 컴포넌트를 렌더링하기 전에 모든 종속성이 완전히 로드되었는지 확인합니다. 이 시점에서 ready 단계에서 추가된 로딩 스타일을 제거하기에 적합합니다."},{"t":"h3","c":"attached"},{"t":"p","c":"attached 라이프사이클 훅은 컴포넌트가 문서에 추가될 때 호출됩니다. 이 단계에서 컴포넌트 내부 엘리먼트의 크기 관련 정보를 가져오고 데이터 바인딩 및 전역 이벤트 조작에 적합합니다."},{"t":"h3","c":"detached"},{"t":"p","c":"리소스 릭을 방지하기 위해 'detached' 라이프사이클 훅은 컴포넌트가 문서에서 제거 될 때 트리거됩니다. 이 단계에서 이벤트 리스너를 취소하거나 리소스를 해제하는 등의 정리 작업을 수행 할 수 있습니다."},{"t":"h2","c":"예시 디모"},{"t":"p","c":"아래는 라이프사이클 훅을 사용하는 방법을 보여주는 예시입니다."},0,{"t":"h2","c":"생명주기 다이어그램"},0],"web-components":[{"t":"h1","c":"컴포넌트 기본 지식"},{"t":"p","c":"ofa.js는 Web Components 기술을 기반으로한 패키지 라이브러리로, 컴포넌트 개발 과정을 단순화하고 가속화하기 위해 설계되었습니다. 이는 복잡한 기술 세부 정보를 숨김으로써 개발자가 고품질 컴포넌트 및 응용 프로그램을 더 집중적으로 개발할 수 있도록 합니다."},{"t":"p","c":"컴포넌트를 더 잘 개발하기 위해서는 Web Components에 대한 지식을 습득하는 것이 필요합니다. 아래에 소개되는 지식은 ofa.js뿐만 아니라 다른 Web Components를 사용하는 프레임워크에서도 동일하게 도움이 될 수 있습니다."},{"t":"h2","c":"Shadow DOM 컨테이너"},{"t":"p","c":"Web Components에서 Shadow DOM은 구성 요소 내부의 스타일과 구조를 캡슐화하기 위해 격리된 컨테이너를 제공합니다. 이는 구성 요소 내부의 스타일과 DOM 구조가 외부의 스타일과 구조와 상호 간섭하지 않으며, 따라서 구성 요소의 예측 가능성과 유지 보수성을 보장합니다."},{"t":"p","c":"ofa.js에서 각 구성 요소마다 Shadow DOM 컨테이너가 있으며, 이는 구성 요소의 내부 콘텐츠를 격리하는 데 사용됩니다. 템플릿 콘텐츠는이 컨테이너에 렌더링됩니다. $를 사용하여 얻은 구성 요소 인스턴스는 shadow 속성을 사용하여 구성 요소 내부의 Shadow DOM 컨테이너에 액세스하여 구성 요소 내부 요소를 조작하고 액세스할 수 있습니다."},0,{"t":"h2","c":"Web Components에서 일반적으로 사용되는 CSS 선택자"},{"t":"p","c":"Web Components는 구성 요소 내부의 다른 부분을 선택하고 스타일 지정하기 위해 특수한 CSS 선택자를 제공합니다. 다음은 일반적으로 사용되는 선택자들입니다."},{"t":"h3","c":":host 선택자"},{"t":"p","c":":host 선택자는 컴포넌트 자체의 외부 컨테이너를 선택하는 데 사용됩니다. 이 선택자를 사용하여 컴포넌트의 스타일을 정의할 수 있습니다."},0,{"t":"h3","c":"::slotted() 선택자"},{"t":"p","c":"::slotted() 선택자는 슬롯으로 감싸진 요소를 선택하는 데 사용됩니다. 이 선택자를 사용하여 컴포넌트 내부의 스타일에서 슬롯의 내용을 스타일링할 수 있습니다."},0,{"t":"h2","c":"슬롯(Slot) 사용"},{"t":"p","c":"슬롯은 웹 컴포넌트에서 컴포넌트 내에 외부 내용을 삽입하는 메커니즘입니다. 슬롯을 사용하면 사용자 정의 내용을 컴포넌트 내부로 전달하여 더 유연한 컴포넌트 구조를 구현할 수 있습니다."},{"t":"h3","c":"단일 슬롯"},{"t":"p","c":"컴포넌트 템플릿에서는 <slot> 요소를 사용하여 슬롯을 정의할 수 있습니다. 외부에서 입력된 내용은 슬롯 안쪽에 삽입됩니다."},0,0,{"t":"h3","c":"여러 개의 네임드 슬롯"},{"t":"p","c":"기본 슬롯 외에도 여러 개의 이름 지정 슬롯을 정의할 수 있습니다. 이름 지정 슬롯을 사용하면 개발자는 다른 내용을 서로 다른 슬롯 위치에 삽입할 수 있습니다."},0,0,{"t":"h2","c":"slotchange 이벤트의 사용"},{"t":"p","c":"slotchange 이벤트는 슬롯 내용이 변경될 때 발생합니다. 이벤트를 듣고 슬롯 내용과 관련된 작업을 실행할 수 있습니다."},0],"template-syntax":[{"t":"h1","c":"모델 언어 문법"},{"t":"p","c":"ofa.js는 강력한 템플릿 문법을 제공하여 컴포넌트의 인터페이스 요소와 데이터를 더 유연하게 조작할 수 있습니다. 이러한 템플릿 문법을 사용하여 다양한 인터페이스 효과와 상호 작용 경험을 구현할 수 있습니다."},{"t":"l","c":"- 텍스트 렌더링：템플릿 파일에서 텍스트를 빠르게 렌더링합니다.\n- class：템플릿 파일에서 클래스 이름을 빠르게 렌더링합니다.\n- 싱크：데이터를 템플릿 파일에 빠르게 동기화합니다.\n- 조건부 렌더링：템플릿 파일에서 필요에 따라 컨텐츠를 렌더링합니다.\n- 리스트 렌더링：템플릿 파일에 배열 데이터를 빠르게 렌더링합니다."}]},"create-app":{"index":[{"t":"h1","c":"소개"},{"t":"p","c":"제외하고도, ofa.js는 구성 요소를 개발하는 것뿐만 아니라 완전한 기능의 응용 프로그램을 개발하는 데에도 사용될 수 있습니다."},{"t":"p","c":"ofa.js는 애플리케이션을 o-app 구성 요소로 통합하며, 이 태그를 직접 사용하여 애플리케이션을 빠르게 만들 수 있습니다. 이 방법을 통해 애플리케이션의 생성이 간단하고 효율적으로 이루어집니다."},{"t":"p","c":"또한, ofa.js 공식로 라우팅 및 SSG(정적 페이지 생성) 솔루션을 제공하여 개발자가 더 견고한 응용 프로그램을 구축하는 데 도움을 줍니다. 이러한 기능은 개발 프로세스를 가속화하고 응용 프로그램의 로직과 사용자 경험에 집중할 수 있도록 하며, 하부 세부 사항을 너무 많이 걱정하지 않도록 합니다."},0,{"t":"p","c":"위에는 간단한 애플리케이션 튜토리얼 코드 예제입니다. 애플리케이션 개발 과정을 차근차근 설명하겠습니다."}],"page":[{"t":"h1","c":"사용 o-page 컴포넌트"},{"t":"p","c":"o-page는 ofa.js 내에서 개발자들에게 편의를 제공하기 위해 만든 커스텀 컴포넌트입니다. 이 컴포넌트는 애플리케이션 개발에서 중요한 역할을 합니다. 만약 당신이 컴포넌트의 템플릿 구문을 사용하고 싶지만 완전히 새로운 컴포넌트를 생성하고 싶지 않다면, o-page 컴포넌트가 최선의 선택이 될 것입니다."},{"t":"h2","c":"페이지 모듈"},{"t":"p","c":"단일 파일 페이지 모듈을 만들 때는 컴포넌트 모듈을 만드는 것과 유사합니다. template 태그를 사용하여 페이지의 템플릿 코드를 감싸고 page 속성을 추가합니다. 이 태그 안에서는 다른 컴포넌트나 페이지 모듈과 상호작용하기 위해 템플릿 언어를 자유롭게 사용할 수 있습니다."},0,{"t":"p","c":"HTML 파일에서는 o-page 태그의 src 속성을 사용하여 페이지 모듈의 파일 경로를 지정합니다. 페이지 내용은 이 구성 요소 내에서 렌더링됩니다."},0,{"t":"h2","c":"이중 파일 모드"},{"t":"p","c":"두 파일 모드는 '정적 템플릿'과 '로직 코드'를 분리하여 페이지의 내용을 더 명확하게 만듭니다."},{"t":"p","c":"아래는 o-page 구성 요소와 페이지 모듈을 사용하는 단계입니다."},{"t":"p","c":"페이지 모듈 만들기"},{"t":"p","c":"컴포넌트 모듈 생성과 유사하게 페이지 모듈을 생성하지만 type 속성을 $.PAGE로 설정합니다. 페이지 모듈에서 사용 가능한 매개변수에는 temp, data, proto, 그리고 watch가 있습니다."},0,{"t":"l","c":"2. 페이지 템플릿 생성:"},{"t":"p","c":"페이지 모듈과 동일한 디렉토리에 my-page-template.html이라는 페이지 템플릿 파일을 만드십시오. 이 템플릿 파일에서는 컴포넌트 템플릿 언어를 사용하여 상호 작용할 수 있으며, 이전에 언급한 컴포넌트 템플릿 언어와 유사한 방식을 사용합니다."},0,{"t":"p","c":"너의 HTML 파일에서 <o-page> 태그를 사용하여 o-page 컴포넌트를 사용하고 src 속성을 통해 페이지 모듈의 파일 경로를 참조하십시오. 페이지의 내용은 이 컴포넌트 내부에서 렌더링됩니다."},0,{"t":"p","c":"이렇게하면 페이지를 열 때 o-page 컴포넌트가 my-page.mjs 이 페이지 모듈을 동적으로로드하고 모듈의 템플릿과 데이터를 기반으로 페이지 콘텐츠를 렌더링합니다. 페이지 모듈의 라이프사이클과 템플릿 구문은 컴포넌트 모듈과 일치하여 페이지 개발 및 관리를 더 일관적이고 유연하게 만듭니다."}],"app":[{"t":"h1","c":"o-app 컴포넌트 사용하기"},{"t":"p","c":"o-app 태그를 사용하면 완전한 응용 프로그램 창을 쉽게 만들 수 있습니다. 아래는 응용 프로그램을 만들고 구성하는 단계입니다."},{"t":"p","c":"문자가 약간 지루해 보입니다. 애플리케이션 사용 예시 로 이동하여 실제로 시도해 보기를 권장합니다."},{"t":"h2","c":"바탕 코드"},{"t":"l","c":"1. HTML 파일을 만들고 o-app 태그를 앱의 디스플레이 창으로 설정합니다. o-app에 전체 화면 스타일을 적용하여 애플리케이션이 전체 화면을 차지하도록 하십시오."},0,{"t":"p","c":"역할을 수행할 es 모듈을 생성하여 애플리케이션의 구성 데이터를 설정합니다. 구성 데이터에는 다음 옵션들이 포함됩니다:"},{"t":"l","c":"   - home: 문자열 형식으로, 애플리케이션의 홈페이지 모듈 주소입니다.\n   - loading: 함수 형식으로, 새로운 페이지를 로드할 때 이 함수가 실행되어 내용이 애플리케이션에 삽입됩니다. 이는 로딩 중인 동안 힌트로 사용되며 페이지 로드가 완료되면 자동으로 해당 로딩 요소가 제거됩니다.\n   - fail: 함수 형식으로, 애플리케이션이 페이지 로드를 실패한 경우 이 함수가 실행되어 반환된 값이 애플리케이션에 로드 실패 메시지로 표시됩니다. 함수는 로드 실패한 페이지의 src 주소와 오류 보고 객체를 포함합니다.\n   - pageAnime: 페이지 간 전환시에 사용되는 애니메이션 설정입니다."},{"t":"p","c":"아래는 응용 프로그램 설정 데이터 예제입니다:"},0,{"t":"p","c":"HTML 파일에서 o-app 태그를 사용하고 src 속성을 통해 구성 데이터의 ES 모듈을 참조합니다."},0,{"t":"p","c":"위 단계를 통해 'o-app' 컴포넌트를 사용하는 애플리케이션 창을 성공적으로 만들었습니다. 'o-app' 컴포넌트는 구성 데이터의 설정에 따라 페이지를 로드하고 로딩 중 또는 로드 실패에 대한 안내를 표시하며 페이지 전환 애니메이션을 지원합니다. 이렇게 하면 기능이 완벽하고 상호 작용이 가능한 애플리케이션을 빠르게 구축할 수 있습니다."},{"t":"h2","c":"라우팅 전환"},{"t":"p","c":"\"o-app\" 앱에서는 한 페이지 모듈에서 다른 페이지 모듈로 쉽게 이동할 수 있습니다. 아래는 라우팅 이동을 수행하는 다양한 방법을 소개합니다."},{"t":"h3","c":"사용<a>태그로 페이지 이동하기"},{"t":"p","c":"페이지의 HTML에서 <a> 태그를 사용하여 라우팅을 구현할 수 있습니다. href 속성을 대상 페이지 모듈의 경로로 지정하고 olink 속성을 추가하여 o-app 구성 요소에 이것이 라우팅 링크임을 알려줘야 합니다."},0,{"t":"h3","c":"goto"},{"t":"p","c":"페이지 템플릿에서는 on:click 속성을 사용하여 클릭 이벤트를 바인딩하고 모듈의 goto 메소드를 호출하여 라우팅 이동을 할 수 있습니다."},0,{"t":"p","c":"다시는 또는 대상 요소에서 직접 제거하세요."},0,{"t":"h3","c":"전환 및 페이지 반환 대체"},{"t":"p","c":"o-app는 goto 메서드 외에도 replace 및 back 메서드를 지원합니다."},{"t":"l","c":"- replace 메서드는 이동을 대체하는 데 사용됩니다. 이는 현재 페이지의 경로를 대체하여 새 페이지가 현재 페이지의 경로가되도록합니다."},0,{"t":"l","c":"- back 메소드는 이전 페이지로 돌아갑니다."},0,{"t":"p","c":"경고해야 할 점은 앱 내에서 컴포넌트의 라우팅 상태를 유지하지만, 라우팅 데이터가 현재 브라우저 탭에 바인딩되지 않는다는 것입니다. 이렇게하면 애플리케이션에서 페이지 간 이동과 탐색을 쉽게 구현할 수 있습니다."},{"t":"p","c":"널널마가로8"},{"t":"p","c":"전에 언급한 방법을 사용하여 o-app 앱에서 유연한 라우팅 전환을 구현할 수 있으며, 사용자가 다양한 페이지 내용을 편리하게 탐색할 수 있습니다."},{"t":"h2","c":"어플리케이션 및 현재 페이지에 접속하기"},{"t":"p","c":"앱 내의 각 요소(구성 요소 포함)는 app 속성을 통해 o-app 인스턴스에 액세스할 수 있습니다. 전체 앱과 상호 작용해야 하는 작업에 매우 유용합니다."},{"t":"p","c":"앱의 app.current 속성을 통해 현재 활성화된 페이지 모듈의 주소를 얻을 수 있습니다."},{"t":"p","c":"이 상황의 사용 예시는 다음과 같습니다."},0,{"t":"p","c":"위의 예에서 .app 선택기로 애플리케이션 태그를 가져와 app.current 속성을 통해 현재 활성화된 페이지 주소를 얻었습니다."},{"t":"h2","c":"사용 팁: 다음 페이지 캐시 미리 저장하기"},{"t":"p","c":"사용자가 다음 페이지로 이동 할 것으로 예상되는 경우가 있습니다. 사용자 경험을 향상시키기 위해 다음 페이지의 페이지 모듈을 미리 캐시해두고, 실제로 이동할 때 즉시로드 할 수 있도록하여 사용자의 대기 시간을 줄이고 사용자 경험을 더욱 원활하게 만들 수 있습니다."},{"t":"p","c":"현재 페이지의 JavaScript 코드에서 load 메소드를 호출하고 다음 페이지의 모듈 경로를 전달하면 해당 모듈이 로드되고 캐시됩니다."},0],"subrouting":[{"t":"h1","c":"서브 라우팅 모드"},{"t":"p","c":"ofa.js에서는 서브 라우팅을 몇 가지 프론트엔드 프레임워크와 다르게 설정합니다. ofa.js는 더 직관적인 방식을 사용하여 페이지 모듈에 부모 페이지를 설정하여 컨테이너로 사용하여 서브 라우팅 요구 사항을 충족시킵니다."},{"t":"h2","c":"부모 페이지 컨테이너 설정"},{"t":"p","c":"자식 라우트를 만들려면 먼저 자식 페이지의 페이지 모듈에서 parent 매개변수를 설정하여 부모 페이지의 페이지 모듈 주소를 지정해야 합니다. 이렇게 하면 자식 페이지가 로드될 때 ofa.js가 자동으로 자식 페이지를 부모 페이지 컨테이너로 감싸게 됩니다."},0,{"t":"p","c":"위의 예시에서, 하위 페이지의 페이지 모듈은 parent 매개변수를 통해 부모 페이지 컨테이너의 주소를 지정합니다."},{"t":"h2","c":"부모 페이지 컨테이너 템플릿 설정"},{"t":"p","c":"적당한 위치에 자식 페이지를 삽입 할 수 있도록 하는 <slot> 요소가 부모 페이지 컨테이너 템플릿에 설정되어야합니다. 동시에 <slot> 요소의 컨테이너 요소가 position: relative로 설정되도록하여 부모 페이지 컨테이너에서 자식 페이지가 절대 위치로 나타날 수 있도록해야합니다."},{"t":"p","c":"아래는 부모 페이지 컨테이너의 예제 템플릿입니다."},0,{"t":"p","c":"위의 예에서 slot을 가진 컨테이너 요소를 설정하여 하위 페이지를 해당 컨테이너에 삽입합니다. 컨테이너 요소가 상대적 위치를 가지도록 하여 하위 페이지가 컨테이너 위치를 기준으로 정렬될 수 있도록 합니다."},{"t":"p","c":"이러한 방식을 사용하면 부모페이지 컨테이너와 자식페이지의 연결을 설정하여 자식페이지의 로딩과 렌더링을 구현할 수 있어서 더 직관적으로 서브 라우트를 구성할 수 있습니다."},{"t":"h2","c":"부모 페이지의 라우트 리스너"},{"t":"p","c":"대부분의 경우, 여러 페이지가 하나의 상위 페이지를 컨테이너로 공유하고, 이러한 페이지 간에 이동할 때 상위 페이지는 새로 고쳐지지 않습니다. 이 경우, 상위 페이지는 여전히 경로 변경을 감시하여 페이지를 새로 고치지 않고도 해당 조작을 수행할 수 있습니다."},{"t":"h3","c":"라우터 변화 감지"},{"t":"p","c":"부모 페이지 모듈은 routerChange 함수를 설정할 수 있으며, 이 함수는 라우터의 변경을 감지합니다. 페이지가 라우터 전환을 하고 부모 페이지를 새로 고치지 않을 때, routerChange 이벤트가 발생합니다. 이 이벤트는 현재 페이지의 정보와 이동하는 방식(type)을 전달합니다."},{"t":"p","c":"아래는 부모 페이지 모듈의 예제이며, routerChange 함수를 설정하여 경로 변화를 감지하는 방법을 보여줍니다."},0,{"t":"p","c":"위의 예시에서 routerChange 함수는 두 개의 매개변수를 받습니다. current는 현재 페이지의 주소를 나타내고, type은 이동 방식을 나타냅니다. 페이지가 라우팅 변경될 때마다 이 함수가 트리거되며, 해당 정보를 출력합니다."}],"o-router":[{"t":"h1","c":"오 라우터 컴포넌트 사용"},{"t":"p","c":"o-router 컴포넌트는 o-app 내에서 현재 브라우저 탭에 라우팅을 바인딩하는 컴포넌트입니다. 페이지 라우팅과 표시를 더 편리하게 관리할 수 있게 도와줍니다."},{"t":"h2","c":"o-router 컴포넌트 로드"},{"t":"p","c":"먼저, 페이지에서 o-router 컴포넌트를 참조해야 합니다. router.mjs 파일을 다음과 같은 방법으로 참조할 수 있습니다:"},0,{"t":"h2","c":"o-router 컴포넌트 사용"},{"t":"p","c":"o-router 구성 요소는 o-app 구성 요소의 외부에 래핑하여 사용됩니다. 이렇게 하면 응용 프로그램 내의 경로가 현재 브라우저 탭에 바인딩될 수 있습니다."},0,{"t":"h2","c":"텍스트를 번역할 수 없습니다."},{"t":"p","c":"o-router 컴포넌트는 fix-body 속성을 제공합니다. 이 속성을 설정하면 컴포넌트가 <html> 태그에 자동으로 스타일을 추가하여 애플리케이션의 크기가 페이지 크기와 동일하게 만들어 애플리케이션 콘텐츠가 전체 창에 가득 차도록 합니다."},0],"scsr":[{"t":"h1","c":"정적 클라이언트 렌더링(SCSR)"},{"t":"h2","c":"SCSR란 무엇인가요?"},{"t":"p","c":"SCSR 전체 이름인 정적 클라이언트 측 렌더링은 정적 클라이언트 측 렌더링으로 알려져 있으며 CSR (클라이언트 측 렌더링)의 변형 중 하나입니다. SCSR은 CSR의 사용자 경험을 유지하면서 페이지가 정적 상태에서도 크롤러에서 검색될 수 있도록 합니다."},{"t":"h2","c":"SCSR 사용 방법"},{"t":"p","c":"SCSR 라이브러리를 인용하는 방법은 다음과 같습니다:"},0,{"t":"h2","c":"SCSR 작동 원리"},{"t":"p","c":"SCSR 는 페이지 모듈의 파일 단일 실행 모드를 통해 페이지 렌더링을 위해 o-page 태그를 사용하지 않고 직접 실행됩니다. 구체적으로는 페이지 모듈의 템플릿 코드를 o-app 내에 바로 넣는 것을 의미합니다."},{"t":"p","c":"아래는 SCSR 예제입니다. 페이지에 페이지 모듈의 내용을 직접 렌더링하는 방법을 보여줍니다."},0,{"t":"p","c":"SCSR를 통해template 태그 내의 내용은 페이지에 직접 렌더링되며, 이 부분의 내용은 실제로 단일 파일 모드의 페이지 모듈입니다."},{"t":"p","c":"위에서 언급한 home.html 페이지를 기반으로 하여 help 페이지를 만듭니다."},0,{"t":"p","c":"홈 화면에서 \"도움말로 이동\"을 클릭하면 help.html 페이지로 부드럽게 전환되어 클라이언트 측 렌더링 전환 효과가 구현되었습니다."},{"t":"h2","c":"주의 사항"},{"t":"p","c":"모든 SCSR 기반 페이지는 페이지 설명 (예 : 제목, 메타 설명, 키워드)과 페이지 템플릿 내용을 제외한 모든 리소스 참조를 일관되게 유지하여 페이지 전환 및 새로 고침 후의 일관된 사용자 경험을 보장해야합니다."},{"t":"h2","c":"SSR 계획에 대해"},{"t":"p","c":"현재의 SCSR 방안은 사실상 SSG (Static Site Generation) 방안과 유사한데, 이는 페이지를 미리 정적 콘텐츠로 렌더링한 후 클라이언트를 통해 상호작용을 할 수 있게 합니다. ofa.js는 독립적인 컴포넌트 래핑 솔루션을 제공하여 프론트엔드 개발자가 컴포넌트를 패키징하고 전통적인 백엔드 렌더링 페이지 방법(Node.js, Go, Java, PHP 등의 웹 사이트 렌더링 프레임워크)과 결합하여 백엔드 개발자가 이러한 패키징된 컴포넌트를 사용하여 고품질의 웹 페이지를 빠르게 구축할 수 있게 합니다."},{"t":"p","c":"우리는 미래에 완전한 SSR(Server-Side Rendering) 솔루션을 제공할 계획입니다. 이 솔루션은 대략적으로 다음 페이지의 요소 내용을 가져와 현재 페이지의 태그 내용과 비교하여 동적으로 속성 추가, 삭제 및 수정 등 작업을 수행합니다. 그러나 이 SSR 솔루션은 시간이 많이 소요될 수 있습니다. 왜냐하면이 과정은 복잡한 요소 비교 및 수정 작업을 포함하기 때문입니다."},{"t":"p","c":"ofa.js는 새롭게 등장한 프레임워크이며, 그리고 작성자의 아마추어 시간도 제한되어 있어 아직 이 SSR 솔루션을 완전히 개발하지 못했습니다. 그러나 앞으로 ofa.js가 더 많은 사용자들에게 사용되고 SSR 솔루션에 대한 강한 요구가 출현하면 작성자는 계속해서 이 솔루션을 개선하고 개발할 것입니다. 현재, 작성자는 프레임워크의 안정성과 기능 확장에 집중하고 있으며, 동시에 사용자의 피드백과 제안을 환영하여 앞으로 사용자의 요구를 더욱 잘 만족시킬 수 있도록 노력할 것입니다."}]},"others":{"data-sharing":[{"t":"h1","c":"데이터 공유"},{"t":"p","c":"ofa.js는 다른 제3자 프레임워크와 다릅니다. 전통적인 상태 관리 모델을 사용하지 않습니다. 상태 업데이트는 무감지적이어야 한다고 저자는 생각합니다. 즉, 데이터를 변경하면 자동으로 데이터 업데이트가 발생해야합니다."},{"t":"p","c":"ofa.js는 우수한 데이터 공유 능력을 타고났으며, 해당 인스턴스는 데이터 공유 라이브러리 Stanz를 기반으로 개발되었습니다. 인스턴스의 객체는 모두 동기화될 수 있습니다. 데이터 공유를 구현하려면 독립적인 Stanz 객체를 생성하고 모든 구성 요소가 직접 참조하도록하면 됩니다."},{"t":"p","c":"아래 예제는 데이터 공유 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"위의 예제에서는 두 개의 컴포넌트가 attached 라이프사이클에서 자신에게 데이터를 씁니다. 그리고 컴포넌트의 obj는 공유 데이터가 됩니다. detached 라이프사이클 이후에 이전에 공유된 데이터를 null로 설정하여 데이터가 재활용되도록 합니다."},{"t":"h2","c":"주의 사항"},{"t":"p","c":"데이터가 공유될 경우, 적절한 시간에 데이터를 회수하여 메모리 누수를 방지해야 합니다."},0],"about-micro-frontend":[{"t":"h1","c":"마이크로 프론트 엔드에 대해"},{"t":"p","c":"마이크로 프론트엔드는 프론트엔드 아키텍처 패턴으로, 팀이 대규모이고 복잡한 프론트엔드 애플리케이션을 더 잘 구축하고 유지할 수 있도록 돕습니다. 이는 마이크로서비스 아키텍처의 개념을 차용하여 프론트엔드 애플리케이션을 더 작은 독립적인 부분으로 분리하며, 각 부분은 서로 다른 팀에서 개발, 테스트 및 배포할 수 있습니다."},{"t":"p","c":"전통적인 단일 프론트 엔드 응용 프로그램은 계속해서 확장되면서 유지 및 확장이 어려워질 수 있습니다. 마이크로 프론트 엔드의 목표는 응용 프로그램을 더 작고 관리 가능한 모듈로 분할하여 개발 팀이 이러한 모듈을 독립적으로 개발하고 배포할 수 있도록하여 팀의 효율성과 응용 프로그램의 유지 보수성을 향상시키는 것입니다."},{"t":"p","c":"ofa.js는 마이크로 프론트 엔드의 특성을 갖춘 기본적으로 개발된 프레임워크입니다. 다른 프레임워크와의 차이점은 ofa.js를 기반으로 개발된 컴포넌트, 페이지 및 애플리케이션을 사전 컴파일할 필요가 없다는 것입니다. React, Vue, Angular 등의 일부 프레임워크와 달리 이들은 노드.js 환경에서 빌드를 수행하여 클라이언트용 코드를 생성해야 합니다. 그러나 ofa.js의 개발 코드는 추가적인 빌드 단계 없이 정적 서버에 직접 배치할 수 있으며, 실시간으로 확인, 사용 및 실행할 수 있습니다."},{"t":"p","c":"ofa.js는 마이크로 프론트엔드를 따르는 특징을 가지고 있습니다."},{"t":"l","c":"1. 독립적인 배포: 각 구성요소와 페이지는 독립적으로 개발, 테스트 및 배포할 수 있어 팀이 새로운 기능을 신속하게 출시하고 문제를 해결할 수 있게 합니다.\n\n2. 통합: ofa.js로 개발된 애플리케이션은 다양한 모듈을 함께 조합할 수 있습니다. 이는 애플리케이션, 페이지, 구성 요소 등의 방법으로 조합을 공유할 수 있습니다.\n\n3. 독립된 팀: 각 프론트엔드 모듈(구성 요소/페이지/애플리케이션)은 독립된 팀에 의해 개발과 유지보수가 가능하여 팀의 자율성과 혁신을 장려합니다.\n\n4. 공유 자원: ofa.js 프로젝트에서는 일관성과 효율성을 보장하기 위해 스타일, 구성 요소, 페이지 등과 같이 일부 공유 자원이 존재합니다.\n\n5. 요구에 따른 로딩: ofa.js의 애플리케이션은 필요에 따라 모듈을 로딩하여 애플리케이션의 성능과 로딩 속도를 향상시킬 수 있습니다."},{"t":"p","c":"ofa.js는 직접적으로 Vue 및 React와 같은 프레임워크로 개발된 컴포넌트를 사용할 수 없지만, ofa.js로 개발된 컴포넌트는 Vue 및 React에서 사용할 수 있으므로 다양한 기술 스택 개발자에게 더 큰 유연성과 확장성을 제공합니다."},{"t":"p","c":"Vue에서 웹 컴포넌트 사용:"},{"t":"l","c":"- Vue 웹 컴포넌트 래퍼\n- Vue와 웹 컴포넌트 통합하기\n- Vue에서 웹 컴포넌트 사용하는 방법"},{"t":"p","c":"React에서 Web Components를 사용하는 방법:"},{"t":"l","c":"- React와 함께 Web Components 사용하기\n- React에서 Web Components 사용하기\n- Web Components를 React에 통합하기"}],"coexist-with-jquery":[{"t":"h1","c":"jQuery와 함께 사용하기"},{"t":"p","c":"만약에 이번에 oca.js(≥4.3.40)를 사용한다면, 동시에 jQuery와 함께 사용할 수 있습니다. 주로 두 가지 선택지를 가집니다:"},{"t":"h2","c":"1. 사용 noConflict"},{"t":"p","c":"jQuery를 가져온 후에 noConflict 메소드를 호출하여 $ 변수를 해제하여 충돌을 피할 수 있습니다."},0,{"t":"h2","c":"2. 라이브러리를 순서대로 가져오기"},{"t":"p","c":"다른 방법은 라이브러리를 순차적으로 가져오는 것이며, 더 늦게 가져온 라이브러리는 $ 변수를 사용할 수 있습니다. 이 경우 전역 변수 ofa를 사용하여 원래의 $를 대체할 수 있습니다."},0,{"t":"p","c":"ofa.js와 jQuery가 충돌하지 않고 동일한 페이지에서 함께 사용될 수 있도록 하려면 이 두 가지 방법 중 하나를 사용할 수 있습니다."}]}},"api":{"index":[{"t":"h1","c":"API 소개"},{"t":"p","c":"ofa.js API 개요입니다. 필요할 때 자세한 문서를 찾아 보기 위해 먼저 살펴보세요."},{"t":"h2","c":"인스턴스 관련"},{"t":"l","c":"- $：인스턴스를 가져오는 주요 메소드\n- all：모든 관련 인스턴스를 가져옴\n- prev：대상 요소의 이전 인스턴스를 가져옴\n- prevs：대상 요소 앞에 있는 모든 인스턴스를 가져옴\n- next：대상 요소의 다음 인턴스를 가져옴\n- nexts：대상 요소 뒤에 있는 모든 인스턴스를 가져옴\n- siblings：대상 요소의 모든 인접 요소 인스턴스를 가져옴\n- parent：부모 요소 인스턴스를 가져옴\n- parents：모든 부모 요소의 인스턴스 집합을 가져옴\n- clone：인스턴스를 복제하는 메소드\n- ele：인스턴스의 실제 기본 요소를 가져옴\n- shadow：사용자 정의 컴포넌트의 그림자 루트 노드를 가져옴\n- root：대상 인스턴스의 루트 노드를 가져옴\n- 자식 요소：숫자를 통해 직접 자식 요소를 가져옴\n- host：대상의 앱 요소 인스턴스를 가져옴"},{"t":"h2","c":"노드 조작"},{"t":"l","c":"- 추가 또는 삭제 child 노드\n- before：대상 인스턴스의 앞에 요소 추가\n- after：대상 인스턴스의 뒤에 요소 추가\n- remove：대상 요소 삭제\n- wrap：대상 요소 위에 레이어 추가\n- unwrap：대상 요소에 대한 레이어 제거"},{"t":"h2","c":"속성 조작"},{"t":"l","c":"- text：대상 요소의 텍스트를 가져오거나 설정합니다.\n- html：대상 요소의 HTML 코드를 가져오거나 설정합니다.\n- attr：대상 요소의 속성(attributes)을 가져오거나 설정합니다.\n- css대상 요소의 스타일을 가져오거나 설정합니다.\n- style：대상 요소의 기본 스타일을 가져옵니다.\n- classList：대상 요소의 기본 class 목록을 가져옵니다.\n- data：대상 요소의 기본 데이터 집합을 가져옵니다."},{"t":"h2","c":"이벤트 관련"},{"t":"l","c":"- on: 이벤트를 대상 요소에 바인딩합니다.\n- one: 대상 요소에 일회성 이벤트를 바인딩합니다.\n- emit: 이벤트를 강제로 발생시킵니다.\n- off: 바인딩된 이벤트를 해제합니다."},{"t":"h2","c":"템플릿 문법"},{"t":"l","c":"- 텍스트 렌더링：템플릿 파일에서 텍스트를 빠르게 렌더링합니다.\n- class：템플릿 파일에서 클래스 이름을 빠르게 렌더링합니다.\n- sync：템플릿 파일로 데이터를 빠르게 동기화합니다.\n- 조건부 렌더링템플릿 파일에서 필요에 따라 내용을 렌더링합니다.\n- 리스트 렌더링：템플릿 파일에서 배열 데이터를 빠르게 렌더링합니다."},{"t":"h2","c":"수명 주기"},{"t":"l","c":"- created：컴포넌트가 생성되지만 내용이 렌더링되기 전에 발생합니다.\n- ready：컴포넌트가 생성되고 내용이 렌더링된 후에 발생합니다.\n- watch：컴포넌트가 초기화되고 값이 변경된 후에 발생합니다.\n- loaded：컴포넌트에 포함된 리소스가 로드된 후에 발생합니다.\n- attached：컴포넌트가 문서에 추가된 후에 발생합니다.\n- detached：컴포넌트가 문서에서 제거된 후에 발생합니다.\n- routerChange：중첩된 부모 페이지가 애플리케이션 라우팅이 변경될 때 발생합니다."},{"t":"h2","c":"기타"},{"t":"l","c":"- 박스 모델: 대상 요소의 모든 크기 관련 데이터를 가져옵니다.\n- formData: 폼 데이터를 편리하게 바인딩하고 가져옵니다.\n- 태그: 대상의 태그 이름을 가져옵니다.\n- 인덱스: 대상 요소의 부모 요소 내에서의 순서를 가져옵니다.\n- is: 대상 요소가 CSS 선택자 표현식과 일치하는지 확인합니다.\n- 새로고침: 컴포넌트의 인터페이스를 수동으로 새로고침합니다.\n- 경로: 컴포넌트 또는 페이지의 등록 파일 주소를 가져옵니다.\n- 확장: 인스턴스의 데이터 또는 메소드를 확장하거나 ofa.js의 내부 데이터 또는 메소드를 확장합니다.\n- 버전: 현재로서의 ofa.js의 버전 번호를 가져옵니다.\n- 인스턴스 데이터 특성: 인스턴스 데이터의 하위 객체 데이터 특성에 대해 설명하고 데이터 변경을 어떻게 감시할지 소개합니다"}],"instance":{"dollar":[{"t":"h1","c":"$"},{"t":"p","c":"$ 함수는 ofa.js의 핵심 함수로서 DOM 요소 인스턴스를 조작하는 데 사용됩니다. 아래에서 $의 주요 역할을 소개하겠습니다."},{"t":"h2","c":"요소 인스턴스 얻기"},{"t":"p","c":"$ 메서드를 사용하여 페이지에서 CSS 선택자와 일치하는 첫 번째 요소 인스턴스를 가져올 수 있으며 해당 요소를 조작할 수 있습니다. 다음은 예제입니다:"},0,0,0,0,{"t":"p","c":"위의 예시에서는 $ 기호를 사용하여 id가 \"target1\"인 요소 인스턴스를 선택하고 text 속성을 설정하여 텍스트 내용을 수정했습니다."},{"t":"h2","c":"서브 엘리먼트 검색 예시"},{"t":"p","c":"실제로도 $ 메소드를 갖고 있으며, 인스턴스의 $ 메소드를 통해 조건을 충족하는 첫 번째 자식 요소 인스턴스를 얻을 수 있습니다."},0,0,0,0,{"t":"h2","c":"변환 실패"},{"t":"p","c":"요소 인스턴스를 직접 다른 곳에 삽입하지 마십시오. 이 작업은 기존 요소에 영향을 줄 수 있습니다. 복사본을 만들어야 하는 경우 clone 메서드를 사용할 수 있습니다."},0,0,0,0,{"t":"h2","c":"얻는 노드에서 자식 요소를 가져옵니다."},{"t":"p","c":"shadow 속성을 통해 인스턴스를 얻은 다음 $ 메소드를 사용하여 원하는 요소를 가져올 수 있습니다."},0,{"t":"h2","c":"직접 요소 인스턴스화"},{"t":"p","c":"너는 다음의 방법을 통해 원시 요소를 $ 인스턴스 객체로 직접 초기화할 수 있습니다."},0,0,{"t":"p","c":"이렇게하면 $ 인스턴스를 사용하여 제공되는 기능을 사용하여 기존의 HTML 요소를 쉽게 변환 할 수 있습니다."},{"t":"h2","c":"생성 요소 인스턴스"},{"t":"p","c":"$를 사용하여 기존 요소 인스턴스를 가져오는 것 외에도 새로운 요소 인스턴스를 만들고 페이지에 추가할 수 있습니다."},{"t":"h3","c":"문자열 생성을 통해"},{"t":"p","c":"$$$ 함수를 사용하여 문자열을 사용하여 새로운 요소 인스턴스를 만들 수 있습니다. 예를 들어 다음과 같습니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 $ 함수를 사용하여 지정된 스타일과 텍스트 내용을 가진 새 요소 인스턴스를 생성하고, \"target1\"이라는 id를 가진 기존 요소 인스턴스에 추가했습니다."},{"t":"h3","c":"객체 생성을 통해"},{"t":"p","c":"$$$ 함수를 사용하여 객체 방식으로 새 요소 인스턴스를 생성할 수도 있습니다. 다음과 같이 보여줍니다:"},0,0,0,0,{"t":"p","c":"이 예제에서는 $ 함수를 사용하여 객체 방식으로 새 요소 인스턴스를 정의하고, 태그 유형, 텍스트 내용 및 스타일 속성을 포함시켜 \"target1\" ID를 가진 기존 요소 인스턴스에 추가합니다."}],"all":[{"t":"h1","c":"all"},{"t":"p","c":"all 메소드를 사용하면 CSS 선택자와 일치하는 페이지의 모든 요소를 가져와 해당 요소를 포함하는 배열을 반환할 수 있습니다."},0,0,0,0,{"t":"h2","c":"하위 요소 가져오기"},{"t":"p","c":"실례 instance는 \"all\" 메소드도 가지고 있으며, 해당 메소드를 통해 하위 요소를 선택하고 가져올 수 있습니다."},0,0,0,0],"prev":[{"t":"h1","c":"prev"},{"t":"p","c":"이 텍스트는 번역할 수 없습니다."},0,0,0,0],"prevs":[{"t":"h1","c":"prevs"},{"t":"p","c":"prevs 속성을 사용하면 현재 요소 이전의 모든 인접 요소 인스턴스를 쉽게 얻을 수 있으며, 이러한 요소는 배열 형태로 반환됩니다."},0,0,0,0],"next":[{"t":"h1","c":"next"},{"t":"p","c":"리스트에서 next 속성을 사용하면 요소의 다음 인접한 요소 인스턴스를 얻을 수 있습니다."},0,0,0,0],"nexts":[{"t":"h1","c":"nexts"},{"t":"p","c":"nexts 속성을 사용하면 해당 요소 이후의 모든 인접한 요소 인스턴스를 쉽게 얻을 수 있으며, 이러한 요소들은 배열 형태로 반환됩니다."},0,0,0,0],"siblings":[{"t":"h1","c":"siblings"},{"t":"p","c":"siblings 속성을 사용하면 현재 요소의 모든 인접한 요소 인스턴스를 쉽게 얻을 수 있습니다. 이 요소들은 배열 형태로 반환됩니다."},0,0,0,0],"parent":[{"t":"h1","c":"parent"},{"t":"p","c":"'parent' 속성을 사용하면 인스턴스의 부모 요소 인스턴스를 얻을 수 있습니다."},0,0,0,0],"parents":[{"t":"h1","c":"parents"},{"t":"p","c":"parents 속성을 사용하면 현재 요소의 모든 부모 요소 인스턴스를 쉽게 가져올 수 있으며, 이러한 요소들은 배열 형태로 반환됩니다."},0,0,0,0],"clone":[{"t":"h1","c":"clone"},{"t":"p","c":"clone 메서드를 사용하면 요소의 인스턴스를 복제하고 생성할 수 있습니다."},0,0,0,0],"ele":[{"t":"h1","c":"ele"},{"t":"p","c":"ele 속성을 통해 인스턴스의 실제 요소를 가져올 수 있으므로 네이티브 속성 또는 메서드를 사용할 수 있습니다."},0,0,0,0,{"t":"p","c":"위의 예제에서는 ele 속성을 사용하여 요소를 가져오고 내부 HTML 내용을 수정하고 레코드에 사용되는 요소의 tagName을 수정했습니다. 이를 통해 기본 JavaScript 메서드와 결합하여 요소에 더 복잡한 조작을 할 수 있습니다."}],"shadow":[{"t":"h1","c":"shadow"},{"t":"p","c":"shadow 속성을 사용하면 요소의 그림자 루트 노드 인스턴스를 얻을 수 있습니다."},0,0,0,{"t":"p","c":"주의해야 할 점은 템플릿 구문이 있는 요소에서 그림자 노드 내의 요소를 직접 수정하는 것을 피하여 작업의 일관성과 유지 관리성을 보장하는 것이다."},{"t":"h2","c":"외부에서 구성 요소의 그림자 요소 내의 요소 인스턴스를 가져옵니다."},{"t":"p","c":"다음과 같이 외부에서 사용자 정의 요소 인스턴스를 가져올 수도 있으며, shadow 속성을 통해 그림자 노드 내부의 요소에 액세스할 수 있습니다."},0],"root":[{"t":"h1","c":"root"},{"t":"p","c":"root 속성을 사용하여 요소의 루트 노드를 가져옵니다."},{"t":"p","c":"페이지에서 일반 요소의 루트 노드는 document 인스턴스입니다."},0,0,0,0,{"t":"h2","c":"그림자 노드 내의 요소"},{"t":"p","c":"컴포넌트 내 요소들은 외부 환경과 격리되어 있기 때문에, 그림자 노드 내의 요소의 root 속성은 그림자 루트 노드입니다."},0,0,0],"children":[{"t":"h1","c":"초 단위"},{"t":"p","c":"인스턴스의 하위 요소를 가져오는 것은 매우 간단합니다. 인스턴스를 배열처럼 취급하여 숫자를 사용하여 하위 요소 인스턴스를 얻을 수 있습니다."},0,0,0,0,{"t":"h2","c":"length"},{"t":"p","c":"노드의 자식 노드 수를 가져옵니다. 예시는 위에 나와 있습니다."},0],"host":[{"t":"h1","c":"host"},{"t":"p","c":"사용 host 속성을 통해 요소의 호스트 컴포넌트 인스턴스를 얻을 수 있습니다. 이는 컴포넌트 내에서 호스트 컴포넌트의 데이터와 메서드에 접근하는 데 매우 유용합니다."},{"t":"p","c":"아래는 호스트 컴포넌트의 인스턴스를 가져오는 'host' 속성을 사용하는 방법을 보여주는 예제입니다."},0,0,0,{"t":"p","c":"이 예제에서는 host-demo라는 사용자 정의 컴포넌트를 생성하고 컴포넌트 내부에서 해당 호스트 컴포넌트 인스턴스에 접근하여 그들이 동일한지 비교합니다."},{"t":"p","c":"요소가 컴포넌트 내에 없으면 host의 값은 null이 됩니다. 예를 들어:"},0,0,0,0,{"t":"p","c":"이 예제에서 #target 요소는 body 하위에 있으며 어떠한 컴포넌트나 페이지에도 속하지 않으므로 $(\"#target\").host의 값은 null입니다."}],"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app 내부에 있는 요소들은 o-app 내부의 o-page의 그림자 노드 내부에 있는 요소들이거나 내부의 하위 컴포넌트입니다. 이들의 app 속성은 이 o-app의 요소 인스턴스를 가리킵니다."},{"t":"p","c":"아래는 o-app 요소 내에서 app 속성에 액세스하는 방법을 보여주는 예시입니다."},0,{"t":"p","c":"코드는 다음과 같습니다:"},0,0,0,{"t":"p","c":"위의 예제에서 o-app 요소의 app 속성에는 o-page 요소와 test-comp 사용자 정의 컴포넌트 내의 요소가 포함되어 있습니다. 이는 이들이 app 속성을 통해 o-app 요소의 데이터와 메소드에 접근할 수 있다는 것을 의미합니다."}]},"operation":{"array-like":[{"t":"h1","c":"자식 요소 추가 또는 제거하기"},{"t":"p","c":"요소 인스턴스는 배열과 유사한 특성을 가지며 노드를 추가하거나 제거하는 데 필요한 몇 가지 배열 메서드를 사용할 수 있습니다. push, unshift, pop, shift, splice 메서드를 사용할 때 내부에서 자동으로 $ 메서드의 초기화 작업이 수행되므로 구체적인 요소 문자열이나 개체를 직접 작성할 수 있습니다."},{"t":"p","c":"같은 방식으로 forEach、map、some 등의 다른 배열 메소드를 사용할 수도 있습니다."},{"t":"p","c":"중요한 것은 템플릿 구문을 가진 요소에는 자식 요소를 추가하거나 삭제하지 않는 것입니다."},{"t":"h2","c":"push"},{"t":"p","c":"끝에 자식 요소를 추가합니다."},0,0,0,0,{"t":"h2","c":"unshift"},{"t":"p","c":"배열의 시작에 하위 요소를 추가합니다. 다음은 예입니다:"},0,0,0,0,{"t":"h2","c":"pop"},{"t":"p","c":"바로 앞의 요소를 제거하세요."},0,0,0,0,{"t":"h2","c":"shift"},{"t":"p","c":"리스트의 첫 번째 원소를 삭제하십시오."},0,0,0,0,{"t":"h2","c":"splice"},{"t":"p","c":"기존 하위 요소를 삭제하거나 대체하거나 새로운 하위 요소를 추가할 수 있습니다. 이는 배열의 splice 메소드와 유사한 방식으로 사용됩니다. 다음은 예시입니다."},0,0,0,0],"before":[{"t":"h1","c":"before"},{"t":"p","c":"before 메서드는 대상 요소 앞에 요소를 추가하는 데 사용됩니다. before 작업을 수행하기 전에 $ 메서드의 초기화 작업이 자동으로 수행되므로 구체적인 요소 문자열이나 객체를 직접 작성할 수 있습니다."},{"t":"p","c":"템플릿 구문을 가진 요소에서는 요소를 조작하지 마세요."},0,0,0,0],"after":[{"t":"h1","c":"after"},{"t":"p","c":"after 메소드는 대상 요소 뒤에 요소를 추가하는 데 사용됩니다. after 작업을 실행하기 전에 $ 메소드의 초기화 작업이 자동으로 수행되므로 구체적인 요소 문자열이나 객체를 직접 작성할 수 있습니다."},{"t":"p","c":"템플릿 구문을 가진 요소에서는 요소를 조작하지 마세요."},0,0,0,0],"remove":[{"t":"h1","c":"remove"},{"t":"p","c":"대상 노드를 삭제합니다."},{"t":"p","c":"템플릿 구문을 가진 요소에서는 요소를 조작하지 마세요."},0,0,0,0],"wrap":[{"t":"h1","c":"wrap"},{"t":"p","c":"wrap 메서드는 대상 요소의 외부에 한 층의 요소를 감싸는 역할을 합니다. wrap 작업을 수행하기 전에 자동으로 $ 메서드의 초기화 작업을 수행하므로 구체적인 요소 문자열 또는 객체를 직접 작성할 수 있습니다."},{"t":"p","c":"다음은 예시입니다."},0,0,0,0,{"t":"h2","c":"주의 사항"},{"t":"p","c":"대상 요소는 반드시 부모 노드를 가져야하며, 그렇지 않으면 래핑 작업이 실패합니다."},0,{"t":"p","c":"템플릿 구문을 가진 요소에서는 요소를 조작하지 마세요."}],"unwrap":[{"t":"h1","c":"unwrap"},{"t":"p","c":"unwrap 메서드는 대상 요소에서 외부에 둘러싸인 요소를 제거하는 데 사용됩니다."},{"t":"p","c":"다음은 예시입니다."},0,0,0,0,{"t":"h2","c":"주의 사항"},{"t":"p","c":"대상 요소는 반드시 부모 노드를 가져야하며, 그렇지 않으면 래핑 작업이 실패합니다."},0,{"t":"p","c":"형제 요소가 있는 경우 unwrap를 실행할 수 없습니다."},0,{"t":"p","c":"템플릿 구문을 가진 요소에서는 요소를 조작하지 마세요."}]},"props":{"text":[{"t":"h1","c":"text"},{"t":"p","c":"text 메서드는 요소의 텍스트 내용을 가져오거나 설정하는 데 사용됩니다."},{"t":"h2","c":"직접 사용"},{"t":"p","c":"당신은 요소의 텍스트 내용을 직접 얻거나 설정할 수 있습니다. 아래에 예시가 있습니다."},0,0,0,0,{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"템플릿 내에서 :text 속성을 사용하여 대상 요소에 해당 속성 값을 설정할 수도 있습니다. 이는 컴포넌트 렌더링에 특히 유용합니다. 다음은 예제입니다:"},0,0,0],"html":[{"t":"h1","c":"html"},{"t":"p","c":"대상 내의 HTML 코드를 설정합니다."},0,0,0,0,{"t":"h2","c":"주의 사항"},{"t":"p","c":"html은 상당히 위험한 방법이며 script에 삽입될 경우 내부의 javascript 코드가 자동으로 실행됩니다. 사용시 XSS에 대비하여 주의해야합니다."},{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"이메일 템플릿 내에서 :html 속성을 사용하여 대상 요소에 해당하는 속성 값을 설정할 수도 있습니다. 이는 컴포넌트 렌더링에 특히 유용합니다. 아래는 예시입니다."},0,0,0],"attr":[{"t":"h1","c":"attr"},{"t":"p","c":"attr 메서드는 요소의 attributes를 가져오거나 설정하는 데 사용됩니다."},{"t":"h2","c":"직접 사용"},{"t":"p","c":"속성을 가져오거나 설정하기 위해 attr 메소드를 직접 사용할 수 있습니다. 다음은 예시입니다."},0,0,0,0,{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"템플릿 내부에서 attr:aaa=\"bbb\" 형식을 사용하여 대상 요소의 aaa 속성을 구성요소 bbb의 값을 설정할 수도 있습니다. 이 방법은 구성요소 렌더링에 특히 유용합니다. 다음은 예시입니다:"},0,0,0],"css":[{"t":"h1","c":"css"},{"t":"p","c":"css 메서드는 대상 요소의 스타일을 가져오거나 설정하는 데 사용됩니다."},{"t":"h2","c":"직접 사용"},{"t":"p","c":"요소의 스타일을 가져 오거나 설정하려면 css 메소드를 직접 사용할 수 있습니다. 다음은 예시입니다:"},0,0,0,0,{"t":"h2","c":"노봉번부밪흈노봉푸볤나능퓸처"},{"t":"p","c":"css 객체를 얻으면 요소에 직접 설정된 스타일 값을 얻을 수 있습니다. 아래는 예시입니다."},0,0,0,0,{"t":"p","c":"css 객체의 특성을 사용하여 대상 요소의 스타일을 빠르게 조정할 수 있습니다."},{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"\"잠재적인 요소의 스타일을 설정하기 위해 템플릿 구문을 사용할 수도 있습니다. 아래에는 예시가 있습니다.\""},0,0,0,{"t":"h2","c":"CSS 설정 팁"},{"t":"p","c":"$ele.css = {...$ele.css, color:'red'} 방식을 사용하여 요소의 특정 스타일 속성을 수정할 수 있습니다. 다른 스타일 속성에는 영향을 미치지 않습니다. 이 방법은 전체 스타일을 다시 작성하지 않고도 하나의 속성만 수정할 수 있습니다."},{"t":"h3","c":"예시"},0,{"t":"p","c":"위의 예에서는 { ...myElement.css, color: 'red' }를 사용하여 요소의 색상 스타일만 변경하고 다른 스타일 속성은 유지했습니다. 이는 요소의 스타일을 유연하게 수정할 수있는 편리한 팁입니다."}],"style":[{"t":"h1","c":"style"},{"t":"p","c":"style 속성을 사용하여 원래의 모양을 유지하세요."},{"t":"p","c":"style 속성은 스타일의 실제 값을 가져올 수 없으며 style 속성에 설정된 값만 가져올 수 있습니다. style 메서드는 css 메서드와 유사하지만 전체 스타일을 덮어쓸 수 없습니다. css와 비교하면 style 메서드의 내부 실행 효율이 더 높습니다."},{"t":"p","c":"전체 예시는 다음과 같습니다. style을 사용하는 방법을 설명합니다."},0,0,0,0,{"t":"p","c":"style 메서드는 스타일 속성의 값만 가져오거나 설정하는 것을 기억하세요. 실제 계산된 스타일은 아닙니다."}],"class-list":[{"t":"h1","c":"classList"},{"t":"p","c":"classList 속성은 네이티브와 일치합니다."},{"t":"p","c":"아래는 classList를 사용하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"classList 속성은 요소의 스타일을 동적으로 변경하기 위해 클래스 이름을 쉽게 추가, 제거 및 전환할 수 있게 해줍니다. 자세한 조작 방법은 classList를 참조하세요."}],"data":[{"t":"h1","c":"data"},{"t":"p","c":"요소의 dataset을 가져와서 원시 dataset과 data 속성을 일치시킵니다."},0,0,0,0]},"event":{"on":[{"t":"h1","c":"on"},{"t":"p","c":"\"on\" 메서드를 사용하여 대상 요소에 이벤트 핸들러를 등록할 수 있습니다. 이를 통해 사용자의 상호 작용을 쉽게 감지하고 대응할 수 있습니다."},{"t":"p","c":"아래는 버튼 요소에 클릭 이벤트 처리기를 등록하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예제에서 우리는 on 메소드를 사용하여 버튼 요소에 클릭 이벤트 핸들러를 추가했습니다. 사용자가 버튼을 클릭하면 이벤트 처리기가 트리거되고, 카운터가 증가하여 결과가 페이지에 표시됩니다."},{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"이미지 알림%markup%"},0,0,0,{"t":"p","c":"이 예제에서는 버튼 요소에 on:click을 사용하여 addCount라는 메서드를 바인딩합니다. 사용자가 버튼을 클릭할 때마다 이 메서드가 호출되고, 카운터 값이 증가되고 페이지에 표시됩니다. 이 방법을 사용하면 이벤트 핸들러를 컴포넌트의 메서드와 연결하여 더 복잡한 상호 작용을 구현할 수 있습니다."},{"t":"h2","c":"event"},{"t":"p","c":"등록 후에 트리거되는 함수는 이벤트와 함께 제공됩니다."},0,0,0,0],"one":[{"t":"h1","c":"one"},{"t":"p","c":"one 메서드를 사용하면 대상 요소에 일회용 이벤트 처리기를 등록할 수 있으며, 이는 이벤트 처리기가 한 번 트리거 된 후 자동으로 바인딩이 해제되어 다시 트리거되지 않음을 의미합니다."},{"t":"p","c":"아래는 버튼 요소에 클릭 이벤트 핸들러를 등록하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 one 메서드를 사용하여 버튼 요소에 클릭 이벤트 핸들러를 추가했습니다. 사용자가 버튼을 클릭하면 이벤트 핸들러가 트리거되지만 다시 트리거되지 않습니다. 이는 이벤트 핸들러가 언바인딩되었기 때문입니다."},{"t":"h2","c":"템플릿 구문의 사용 방법"},{"t":"p","c":"액션을 위해 대상 요소에 일회성 이벤트 핸들러를 바인딩하기 위해 템플릿 구문을 사용할 수도 있습니다. 다음은 예시입니다."},0,0,0,{"t":"p","c":"이 예제에서는 'one:click'이라는 이벤트를 버튼 요소에 바인딩하여 'addCount'라는 메서드를 호출합니다. 사용자가 버튼을 클릭하면이 메서드가 호출되지만 다시 트리거되지 않습니다. 이는 일회성 이벤트 처리기입니다."}],"emit":[{"t":"h1","c":"emit"},{"t":"p","c":"코드 \"emit\" 메서드를 사용하면 이벤트를 수동으로 트리거 할 수 있으며, 트리거된 이벤트는 버블링 메커니즘을 갖고 있습니다. 버블링 메커니즘은 이벤트가 내부 요소에서 외부 요소로 버블링되며, 내부에서 외부로 이벤트가 계층적으로 트리거됨을 의미합니다."},{"t":"p","c":"아래는 emit 메소드를 사용하여 사용자 정의 이벤트를 트리거하고 버블링 메커니즘을 사용하여 이벤트를 외부 요소로 전달하는 방법을 보여주는 예시입니다."},0,0,0,0,{"t":"p","c":"이 예시에서는 <ul> 요소와 <li> 요소에 대해 동일한 사용자 정의 이벤트인 custom-event를 등록했습니다. 이벤트를 발생시킬 때 emit 메서드를 사용하면 이벤트가 <li> 요소에서 <ul> 요소로 버블링되어 두 개의 이벤트 처리기가 트리거됩니다."},{"t":"h2","c":"사용자 지정 데이터"},{"t":"p","c":"data 매개변수를 사용하여 사용자 지정 데이터를 이벤트 처리기로 전달할 수 있습니다."},0,0,0,0,{"t":"p","c":"이 예제에서 우리는 'data' 매개 변수를 통해 사용자 정의 데이터를 이벤트 핸들러에 전달했습니다. 이벤트 핸들러는 전달된 데이터를 가져오기 위해 'event.data'를 사용할 수 있습니다."},{"t":"h2","c":"버블링 이벤트 트리거 없음"},{"t":"p","c":"이벤트 버블링을 원치 않는 경우 이벤트를 발생시킬 때 bubbles: false 매개변수를 추가할 수 있습니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 bubbles: false 매개변수를 사용하여 사용자 정의 이벤트를 트리거했습니다. 이 이벤트는 상위 요소로 버블링되지 않기 때문에 <li> 요소의 이벤트 처리기만 트리거됩니다."},{"t":"h2","c":"투과 루트 노드"},{"t":"p","c":"기본적으로 이벤트는 사용자 정의 구성요소의 Shadow DOM을 통과하지 않습니다. 그러나 composed: true를 설정하여 사용자 정의 이벤트가 루트 노드를 통과하여 루트 노드 외부의 요소를 트리거 할 수 있습니다."},0,0,0,0,0,{"t":"p","c":"이 예제에서는 composed-test라는 사용자 정의 컴포넌트를 만들었습니다. 이 컴포넌트에는 그림자 DOM에 있는 요소와 이벤트를 트리거하는 버튼이 포함되어 있습니다. 기본적으로 이벤트는 그림자 DOM을 통과하지 않고 루트 노드로 이동하지 않습니다. 그러나 이벤트가 트리거 될 때 composed: true 매개변수를 사용하여 이벤트가 루트 노드로 통과하여 루트 노드 외부의 요소를 트리거할 수 있게합니다."}],"off":[{"t":"h1","c":"off"},{"t":"p","c":"사용하는 \"off\" 메서드로 등록된 이벤트 핸들러를 해제하고 이벤트의 감지를 취소할 수 있습니다."},{"t":"p","c":"아래는 off 메서드를 사용하여 이벤트 리스너를 취소하는 방법을 보여주는 예시입니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 클릭 이벤트 핸들러 'f'를 등록했습니다. 버튼이 클릭되면 이벤트 핸들러에서는 #logger에서 클릭 횟수를 표시합니다. off 메서드를 사용하여 클릭 횟수가 3이 되면 이벤트 감지를 취소했습니다."}]},"temp-syntax":{"text-render":[{"t":"h1","c":"텍스트 렌더링"},{"t":"p","c":"{{xxx}} 형식의 템플릿 내에서 중괄호 두 개를 사용하여 텍스트를 렌더링할 수 있습니다. 여기서 xxx는 컴포넌트나 페이지 자체의 속성입니다. 이를 통해 속성의 값을 직접 페이지에 렌더링할 수 있습니다."},{"t":"p","c":"다음은 템플릿에서 텍스트를 렌더링하는 방법을 보여주는 예제입니다:"},0,0,0,{"t":"p","c":"해당 텍스트는 번역할 수 없습니다."}],"class":[{"t":"h1","c":"class"},{"t":"p","c":"당신은 class 구문을 사용하여 템플릿 내의 클래스 이름을 빠르게 변경할 수 있습니다. class:aaa=\"bbb\"에서 bbb 표현식(또는 컴포넌트 자체의 bbb 속성)이 true일 때 대상 요소에 aaa className이 추가됩니다."},{"t":"p","c":"클래스 이름에는 대문자를 포함할 수 없으며, 대신 -를 구분 기호로 사용해야합니다."},{"t":"p","c":"아래는 템플릿에서 요소의 클래스 이름을 전환하는 방법을 보여주는 예제입니다."},0,0,0,{"t":"h2","c":"직접 class를 사용하기"},{"t":"p","c":"당신은 class 메소드를 사용하여 요소의 className을 직접 조정할 수 있습니다. 아래 예시에서는 class 메소드를 사용하여 클래스 이름을 동적으로 추가하고 삭제하는 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"여기 예시에서는 우선 class 메소드를 사용하여 요소에 color-red 클래스를 추가하고, 1초 후에 제거한 다음, 0.5초 후에 color-blue 클래스를 요소에 추가합니다. 이렇게 하면 대상 요소의 스타일이 동적으로 변경됩니다."},{"t":"p","c":"우리는 클래스 이름을 조작하는 데 classList 속성을 사용하는 것을 권장합니다. 이것은 더 일반적이고 표준적인 방법입니다."}],"sync":[{"t":"h1","c":"sync"},{"t":"p","c":"양방향 데이터 바인딩을 위해 sync 구문을 사용하여 컴포넌트를 바인딩합니다."},0,0,0,{"t":"p","c":"sync는 내장된 컴포넌트 인스턴스 속성과도 바인딩할 수 있습니다. 예제는 양방향 데이터 바인딩에서 확인하실 수 있습니다."}],"condition":[{"t":"h1","c":"조건부 렌더링"},{"t":"p","c":"조건부 렌더링은 세 가지 조건 컴포넌트를 통해 구현됩니다:"},{"t":"h2","c":"x-if"},{"t":"p","c":"x-if은 주요한 조건부 컴포넌트로, value 값을 설정해야 합니다. 만약 value의 조건이 충족되면, 해당 내용을 표시합니다."},{"t":"h2","c":"x-else-if"},{"t":"p","c":"x-else-if는 x-if 또는 x-else-if 뒤에 오며, value 값을 설정해야 합니다. 이전의 조건 컴포넌트가 충족되지 않고, 자신의 value가 true인 경우, 그 안에 내용이 표시됩니다."},{"t":"h2","c":"x-else"},{"t":"p","c":"x-else는 x-if 또는 x-else-if 뒤에 따라올 수 있으며, 마지막에 위치합니다. 이전의 모든 조건이 충족되지 않을 경우, x-else는 자체적으로 내용을 표시합니다. value 값을 설정할 필요가 없습니다."},{"t":"h2","c":"예시"},0,0,0,{"t":"p","c":"이 예제에서는 이러한 조건부 렌더링 컴포넌트를 사용하여 'count'의 값에 따라 표시할 내용을 선택합니다. 'count'가 3으로 나누어 떨어질 때 'x-if' 조건이 충족되어 빨간색 텍스트가 표시됩니다. '(count + 1)'이 3으로 나누어 떨어질 때 'x-else-if' 조건이 충족되어 초록색 텍스트가 표시됩니다. 그렇지 않으면 파란색 텍스트가 표시됩니다."}],"fill":[{"t":"h1","c":"x-fill"},{"t":"p","c":"x-fill 컴포넌트를 사용하여 리스트 렌더링을 수행합니다. 배열 데이터를 채우기 위해 value 속성을 설정하세요."},{"t":"p","c":"x-fill 내부에서는 특수 변수 $index를 사용하여 현재 목록 항목의 인덱스를 대표하고, $data를 사용하여 목록 항목 자체의 데이터를 대표할 수 있습니다."},{"t":"p","c":"하지만 텍스트를 번역할 수 없습니다."},0,0,0,{"t":"p","c":"이 예제에서는 x-fill 컴포넌트를 사용하여 배열 arr을 렌더링하고 각 항목에서 인덱스와 데이터를 표시합니다."},{"t":"h2","c":"템플릿 리스트 렌더링"},{"t":"p","c":"템플릿 요소 template를 사용하고 name 속성을 추가하여 컴포넌트 내의 임시 템플릿을 사용자 정의할 수 있습니다. x-fill을 사용할 때 어떤 템플릿을 채울지를 지정하는 데 name 속성을 사용합니다."},{"t":"p","c":"아래는 템플릿 리스트 렌더링을 사용하는 예제입니다:"},0,0,0,{"t":"p","c":"이 예제에서는 \"easyLi\"라는 템플릿을 만들고 x-fill을 사용하여 배열 arr의 데이터를 채우고 각 항목에서 인덱스와 데이터의 이름을 표시합니다."},{"t":"h2","c":"중첩된 목록 렌더링"},{"t":"p","c":"중첩 목록 렌더링시, 두 번째 계층부터 템플릿을 사용하여 채워야합니다. 이러한 설계는 다층 중첩 목록 렌더링 코드가 복잡해지는 것을 피하기 위한 것입니다."},{"t":"p","c":"아래는 중첩된 목록을 렌더링하는 방법을 보여주는 예제입니다."},0,0,0,{"t":"p","c":"이 예제에서는 배열 'arr'이 있습니다. 이 배열은 두 개의 객체를 포함하고 있습니다. 각 객체는 'name' 속성과 중첩된 하위 항목을 포함할 수 있는 'childs' 속성을 가지고 있습니다. 우리는 'x-fill'을 사용하여 목록을 채우고, 하위 항목을 렌더링하는 템플릿 \"easyLi\"를 사용합니다. 항목에 하위 항목이 있는 경우 'x-if'를 사용하여 중첩된 목록을 만듭니다."},{"t":"h2","c":"재귀 목록 렌더링"},{"t":"p","c":"모델 렌더링은 재귀 렌더링도 가능합니다. 이는 트리 구조의 목록을 구축하는 데 매우 유용합니다."},{"t":"p","c":"아래는 재귀적으로 목록을 렌더링하는 예제입니다."},0,0,0,{"t":"p","c":"이 예제에서 우리는 arr이라는 배열을 가지고 있습니다. 배열에는 두 개의 객체가 포함되어 있습니다. 각 객체는 name 속성과 중첩된 하위 항목을 포함 할 수있는 childs 속성이 있습니다. 우리는 리스트를 채우기 위해 x-fill을 사용하고, 하위 항목을 렌더링하기 위해 \"easyLi\" 템플릿을 사용합니다. 항목에 하위 항목이있는 경우 재귀적으로 하위 목록을 렌더링하기 위해 x-fill을 사용하여 재귀 목록 렌더링을 구현했습니다."},{"t":"h2","c":"replace-temp"},{"t":"p","c":"때로는 셀렉트 또는 테이블에 목록을 렌더링하려고 할 때 브라우저가 <x-fill> 요소를 자동으로 제거하여 목록 렌더링을 제대로 수행할 수 없을 때가 있습니다. 이 경우, replace-temp를 사용하여 렌더링할 수 있습니다. replace-temp를 사용하는 방법은 <template> 태그 내에서 is=\"replace-temp\"를 설정하고 이 템플릿을 브라우저가 자동으로 수정하는 요소 내에 배치하는 것입니다."},0,0,0]},"life-cycle":{"created":[{"t":"h1","c":"created"},{"t":"p","c":"created 생명 주기 훅은 컴포넌트가 생성될 때 발생합니다. 이 단계에서는 컴포넌트의 데이터가 초기화되지 않았고, 템플릿 내용도 렌더링되지 않았습니다. 이 단계에서는 초기화 작업을 수행하거나 후속 단계에서 사용할 데이터를 준비할 수 있습니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0],"ready":[{"t":"h1","c":"ready"},{"t":"p","c":"ready 라이프사이클 훅은 컴포넌트의 데이터와 템플릿이 초기화된 직후에 발생하여 컴포넌트가 준비되었음을 나타냅니다. 이 단계에서는 컴포넌트의 데이터에 접근할 수 있으며 템플릿은 이미 렌더링되어 화면과 상호작용하는 일부 작업을 수행할 수 있습니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0],"watch":[{"t":"h1","c":"watch"},{"t":"p","c":"일단 ready 단계가 완료되면, 해당 watch 객체에 연결된 리스너 함수는 한 번 호출됩니다. 그 후, 데이터의 어떤 값이 변경되면 해당 키의 리스너 함수가 다시 호출됩니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0],"loaded":[{"t":"h1","c":"loaded"},{"t":"p","c":"loaded 생명주기 훅은 컴포넌트 템플릿 내에서 모든 종속성이 로드된 후 트리거됩니다. 이 단계에서 컴포넌트를 렌더링하기 전에 모든 종속성이 완전히 로드되었는지 확인합니다. 이 시점에서 ready 단계에서 추가된 로딩 스타일을 제거하기에 적합합니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0],"attached":[{"t":"h1","c":"attached"},{"t":"p","c":"attached 라이프사이클 훅은 컴포넌트가 문서에 추가될 때 호출됩니다. 이 단계에서 컴포넌트 내부 엘리먼트의 크기 관련 정보를 가져오고 데이터 바인딩 및 전역 이벤트 조작에 적합합니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0],"router-change":[{"t":"h1","c":"소스 이벤트"},{"t":"p","c":"routerChange 이벤트는 o-page 요소에 특정한 이벤트로서, o-page의 중첩 부모 페이지에서만 트리거됩니다. 이 이벤트는 애플리케이션의 라우팅이 변경될 때 새로운 페이지로 이동하거나 이전 페이지로 돌아갈 때 트리거됩니다."},{"t":"p","c":"그것은 애플리케이션의 라우트 변경을 감시하고 대응하는 방법을 제공합니다. 일반적으로 중첩된 페이지의 부모 페이지에서 사용됩니다. 라우트가 변경되면 routerChange 이벤트를 수신하여 해당 작업을 실행할 수 있습니다. 예를 들어 페이지 콘텐츠를 업데이트하거나 탐색 상태를 변화시킬 수 있습니다."},{"t":"p","c":"이 이벤트는 다중 중첩 페이지를 갖는 애플리케이션을 구축하는 데 매우 유용하며 페이지 간 탐색과 통신을보다 쉽게합니다."},{"t":"h2","c":"예시"},{"t":"p","c":"중첩 페이지로 이동을 참조하세요."}],"detached":[{"t":"h1","c":"detached"},{"t":"p","c":"리소스 릭을 방지하기 위해 'detached' 라이프사이클 훅은 컴포넌트가 문서에서 제거 될 때 트리거됩니다. 이 단계에서 이벤트 리스너를 취소하거나 리소스를 해제하는 등의 정리 작업을 수행 할 수 있습니다."},{"t":"h2","c":"예제 코드"},0,0,0,0,0,{"t":"h2","c":"생명주기 다이어그램"},0]},"others":{"app":[{"t":"h1","c":"app"},{"t":"p","c":"o-app 는 ofa.js 의 핵심 컴포넌트 중 하나로 전체 애플리케이션을 구성하고 관리하기 위해 사용됩니다. 여기에는 앱의 몇 가지 주요 속성과 메서드가 있습니다:"},{"t":"h2","c":"src"},{"t":"p","c":"src 속성은 애플리케이션의 매개 변수 구성 모듈의 구체적인 주소를 지정하는 데 사용됩니다. 자세한 예제는 사례를 참조하십시오."},0,{"t":"h2","c":"current"},{"t":"p","c":"current 속성은 현재 표시되는 페이지 인스턴스를 가져오는 데 사용됩니다. 이를 통해 현재 표시되는 페이지에 액세스하고 조작할 수 있으며, 예를 들어 내용을 업데이트하거나 특정 작업을 실행할 수 있습니다."},0,{"t":"h2","c":"goto"},{"t":"p","c":"goto 메소드는 지정된 페이지로 이동하는 데 사용됩니다. 대상 페이지의 주소를 전달할 수 있고, 앱은 해당 페이지를 로드하고 표시합니다. 이는 앱 내비게이션에서 중요한 메소드입니다."},0,{"t":"h2","c":"replace"},{"t":"p","c":"replace 메서드는 goto와 유사하지만 현재 페이지를 대체하는 데 사용됩니다. 새 페이지를 스택에 추가하지 않고 페이지를 대체하고자 할 때 사용할 수 있습니다."},0,{"t":"h2","c":"back"},{"t":"p","c":"back 메소드는 이전 페이지로 돌아가는데 사용됩니다. 이를 통해 사용자는 이전 페이지로 이동할 수 있습니다."},0,{"t":"h2","c":"routers"},{"t":"p","c":"routers 속성은 애플리케이션의 라우팅 구성 정보를 포함합니다. 이는 애플리케이션의 각 페이지의 라우팅 규칙과 매핑을 정의하는 중요한 속성입니다. 라우팅 구성은 페이지 간 탐색 및 URL 처리 방법을 결정합니다."},0],"page":[{"t":"h1","c":"o-page 컴포넌트"},{"t":"p","c":"o-page 는 ofa.js 에서 중요한 구성요소 중 하나로, 독립된 페이지나 페이지 모듈을 나타냅니다. 다음은 o-page 의 몇 가지 주요 속성과 메서드입니다:"},{"t":"h2","c":"src 속성"},{"t":"p","c":"src 속성은 페이지 모듈의 구체적인 주소를 지정하는 데 사용됩니다. 이는 페이지의 내용과 동작을 지정하는 중요한 속성으로, 특정 페이지의 내용을 어디서 로드할지 애플리케이션에 알려줍니다."},{"t":"p","c":"구글번역 서비스를 사용하여 번역한 결과입니다. 번역의 정확성을 보장할 수 없으니 참고 바랍니다.```javascript\n// 예제 코드 : 현재 페이지 주소 가져오기\n// const page = $(\"o-app\").current;\n...\nready(){\n  // 페이지 모듈의 라이프사이클 내에서, this는 현재 페이지 모듈 자체입니다.\n  const page = this;\n}\n..."},0,{"t":"h2","c":"replace 메서드"},{"t":"p","c":"replace 메서드는 현재 페이지를 다른 페이지로 대체하는 데 사용됩니다. 이는 app의 replace 메서드와 유사하지만 페이지 내에서 대체 작업을 수행합니다."},0,{"t":"h2","c":"뒤로가기 메서드"},{"t":"p","c":"뒤로 가기(back) 메소드는 이전 페이지로 돌아가는 데 사용됩니다. 이는 사용자를 이전 페이지로 이동시키며, 웹 브라우저의 뒤로 가기 기능과 유사합니다."},0],"box":[{"t":"h1","c":"박스 모델"},{"t":"p","c":"웹 개발에서 요소의 크기는 중요한 개념이며, 내용 영역, 안쪽 여백, 테두리 및 바깥 여백을 포함합니다. 다음은 요소 크기를 나타내는 관련 속성입니다."},{"t":"h2","c":"width"},{"t":"p","c":"width는 요소의 콘텐츠 영역의 너비를 나타내며, 패딩, 테두리 및 마진은 포함하지 않습니다."},{"t":"h2","c":"height"},{"t":"p","c":"height는 요소의 콘텐츠 영역의 높이를 나타내며, 패딩, 테두리 및 마진은 포함하지 않습니다."},{"t":"h2","c":"clientWidth"},{"t":"p","c":"clientWidth는 내부 여백을 포함하지만 테두리와 바깥 여백은 포함하지 않는 요소의 가시적인 내용 영역의 너비를 나타냅니다."},{"t":"h2","c":"clientHeight"},{"t":"p","c":"clientHeight는 엘리먼트의 보이는 콘텐츠 영역의 높이를 나타내며, 패딩을 포함하지만 테두리와 마진은 포함하지 않습니다."},{"t":"h2","c":"offsetWidth"},{"t":"p","c":"offsetWidth는 요소의 전체 너비를 나타내며 내용 영역, 안쪽 여백, 테두리 및 바깥 여백을 포함합니다."},{"t":"h2","c":"offsetHeight"},{"t":"p","c":"offsetHeight는 요소의 전체 높이를 나타내며, 내용 영역, 패딩, 테두리 및 마진을 포함합니다."},{"t":"h2","c":"outerWidth"},{"t":"p","c":"outerWidth는 요소의 전체 너비를 나타내며, 콘텐츠 영역을 포함합니다."},0,0,0,0],"form-data":[{"t":"h1","c":"formData"},{"t":"p","c":"formData 메소드는 폼 요소와 바인딩된 개체 데이터를 생성하여 폼 요소의 처리를 더 간단하고 효율적으로 만들어줍니다. 이 메소드는 대상 요소 내의 모든 폼 요소의 값을 포함하는 개체를 생성하며, 이 개체는 폼 요소의 변경 사항을 실시간으로 반영합니다."},{"t":"p","c":"아래 예시에서는 formData 메서드를 사용하여 양식 요소와 바인딩된 객체 데이터를 생성하는 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 텍스트 입력 상자, 라디오 버튼 및 텍스트 영역이 포함된 양식을 생성하고 formData 메서드를 사용하여 이러한 양식 요소의 값을 포함하는 data 객체를 만듭니다. 우리는 또한 watch 메서드를 사용하여 데이터의 변경을 모니터링하고 데이터를 실시간으로 페이지에 표시합니다. 사용자가 양식 요소의 값을 수정할 때 data 객체가 업데이트되어 데이터 처리가 매우 간단하고 효율적이게 됩니다."},{"t":"h2","c":"양방향 데이터 바인딩"},{"t":"p","c":"생성 된 객체 데이터는 역으로 바인딩할 수 ​​있습니다. 이는 객체의 속성을 수정 할 때 관련 양식 요소 값도 자동으로 업데이트됨을 의미합니다. 이것은 양식 데이터를 처리 할 때 매우 유용하며 쉽게 양방향 데이터 바인딩을 구현할 수 있습니다."},{"t":"p","c":"아래의 예제에서는 formData 메소드로 생성된 객체 데이터를 사용하는 방법과 양방향 데이터 바인딩을 하는 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 먼저 텍스트 입력 상자, 라디오 버튼 및 텍스트 영역이 포함된 폼을 만들었고, formData 메서드를 사용하여 데이터 객체 data를 생성했습니다. 그런 다음 data 객체의 속성을 수정함으로써 양방향 데이터 바인딩, 즉 폼 요소의 값이 객체의 속성 변경과 자동으로 업데이트되는 기능을 구현했습니다. 이러한 양방향 데이터 바인딩 기능은 폼 데이터와의 상호 작용을 더 편리하게 만듭니다."},{"t":"h2","c":"특정 폼 모니터링"},{"t":"p","c":"formData() 메서드는 기본적으로 대상 요소 내의 모든 input、select 및 textarea 요소를 감지합니다. 그러나 특정한 폼 요소만 감지하려면 CSS 선택자를 전달하여 구현할 수 있습니다."},{"t":"p","c":"이 아래 예제에서는 CSS 선택기를 전달하여 특정한 양식 요소를 감시하는 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"여기 예시에서는 \"class\"가 \"use-it\"인 양식 요소만 감시하도록 하려고 하기 때문에 \".use-it\"을 formData() 메소드에 매개변수로 전달합니다. 이렇게 하면 해당 클래스 이름이 있는 양식 요소만 감시되고 생성된 데이터 객체에 포함됩니다. 이는 양식 요소를 선택적으로 감시하여 양식 데이터를 더 정확하게 관리하는 데 매우 유용합니다."},{"t":"h2","c":"사용자 정의 양식"},{"t":"p","c":"사용자 정의 폼 컴포넌트를 사용하려면 사용자 정의 컴포넌트에 value 속성을 추가하고 name 특성을 설정하기만 하면 됩니다."},{"t":"p","c":"아래 예시에서는 \"custom-input\"이라는 사용자 정의 폼 컴포넌트를 생성합니다. 이 컴포넌트는 편집 가능한 텍스트 상자로, 텍스트가 변경될 때 마다 value 속성을 실시간으로 업데이트합니다."},0,0,0,0,{"t":"p","c":"사용자 정의 양식 컴포넌트를 사용할 때는 해당 컴포넌트를 양식에 추가하고 필요한 'name' 속성을 설정하기만 하면됩니다."},0,{"t":"p","c":"이전 예제에서는 <custom-input> 요소를 추가하고 name 속성을 설정하여 사용자 지정 폼 컴포넌트를 사용했습니다. 그런 다음 formData() 메서드를 사용하여 입력 요소와 사용자 지정 컴포넌트의 값을 모니터링하여 실시간으로 양식 데이터를 가져오고 처리합니다. 이 방법을 사용하면 사용자 지정 폼 컴포넌트를 포함하여 양식을 쉽게 확장하여 특정 요구 사항을 충족할 수 있습니다."},{"t":"h2","c":"컴포넌트나 페이지 내에서 양식 데이터 사용하기"},{"t":"p","c":"가끔은 컴포넌트나 페이지에서 양식 데이터를 사용해야하며, 'ready' 주기 수명이 생성되어 컴포넌트에 바인딩되어야합니다."},{"t":"p","c":"아래 예제에서는 사용자 정의 컴포넌트 내에서 양식 데이터를 사용하는 방법을 보여줍니다. 이 컴포넌트에는 텍스트 입력 상자가 포함되어 있으며, 내용을 입력할 때마다 데이터가 로그에 실시간으로 업데이트됩니다."},0,0,0,{"t":"p","c":"ready 라이프사이클 주기를 통해 컴포넌트가 준비되면 this.shadow.formData() 메서드를 사용하여 폼 데이터 객체 fdata를 생성했습니다. 그런 다음 fdata의 변경 사항을 감시하기 위해 watch를 사용하여 데이터가 변경될 때 JSON 문자열로 변환하고 logtext를 업데이트하여 폼 데이터를 실시간으로 표시하는 기능을 구현했습니다."}],"tag":[{"t":"h1","c":"tag"},{"t":"p","c":"tag 속성은 요소의 태그를 가져옵니다. 소문자 문자열을 반환합니다."},{"t":"p","c":"아래의 예제에서는 tag 메소드를 사용하여 요소의 태그를 가져오는 방법을 보여줍니다."},0,0,0,0],"refresh":[{"t":"h1","c":"refresh"},{"t":"p","c":"컴포넌트의 렌더링 뷰를 갱신하는 데 사용되며, 때로는 컴포넌트의 데이터가 업데이트되지 않을 때 이 방법을 사용하여 컴포넌트의 뷰를 새로 고칠 수 있습니다."},0,0,0],"is":[{"t":"h1","c":"is"},{"t":"p","c":"요소가 표현식과 일치하는지 여부를 검사하는 데 사용됩니다."},0,0,0,0],"path":[{"t":"h1","c":"PATH"},{"t":"p","c":"PATH 속성은 일반적으로 커스텀 컴포넌트나 페이지 컴포넌트에 사용되며 해당 컴포넌트의 등록된 컴포넌트 파일의 주소를 가져오는 데 사용됩니다. 이는 개발 과정에서 컴포넌트의 소스를 파악하는 데 도움이 됩니다. 특히 다른 리소스 파일을 참조하거나 로드해야 할 때 파일 경로를 구축하는 데 PATH 속성을 사용할 수 있습니다."},{"t":"p","c":"아래의 예는 사용자 정의 컴포넌트에서 PATH 속성을 사용하는 방법을 보여줍니다."},0,{"t":"p","c":"이 예에서는 id가 \"myCustomComponent\"인 my-comp 요소를 선택하여, PATH 속성을 통해 해당 사용자 정의 구성 요소의 파일 경로를 가져왔습니다. 필요에 따라 스크립트 부분에서 componentPath 변수를 사용할 수 있으며, 예를 들어 다른 리소스 파일의 경로를 구축하거나 기타 작업에 사용할 수 있습니다."}],"index":[{"t":"h1","c":"index"},{"t":"p","c":"index 속성은 요소가 부모 요소 내에서의 위치를 가져옵니다. 이 위치는 0부터 세어지며, 즉 첫 번째 요소의 위치는 0이고, 두 번째 요소는 1이며, 이와 같이 계속됩니다."},{"t":"p","c":"아래 예제에서는 index 속성을 사용하여 요소가 부모 요소 내에서의 위치를 가져오는 방법을 보여줍니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 첫 번째로 id가 \"target\"인 <li> 요소를 선택합니다. 그런 다음 index 속성을 사용하여 해당 요소의 부모 요소인 <ul>에서의 위치, 즉 두 번째 요소를 가져옵니다. 따라서 index의 값은 1입니다. 그런 다음 이 값을 id가 \"logger\"인 <div> 요소에 표시합니다."}],"extend":[{"t":"h1","c":"extend"},{"t":"p","c":"extend는 인스턴스의 속성이나 메서드를 확장하는 고차 함수입니다."},0,0,0,0,{"t":"h2","c":"$ 하위 항목 확장"},{"t":"p","c":"fn.extend를 통해 jQuery와 유사하게 기본 인스턴스의 속성이나 메소드를 확장할 수 있습니다. fn에서 확장한 속성이나 메소드는 모든 인스턴스에 적용됩니다."},0,0,0,0,{"t":"h2","c":"확장 템플릿 구문"},{"t":"p","c":"확장으로 속성이나 기능을 추가하여 템플릿 문법을 향상시키고, 구성 요소에 전용 템플릿 문법을 제공할 수 있습니다. 그러나 주의할 점은 비공식적인 템플릿 문법을 사용하지 않는 것이 좋습니다. 왜냐하면 그들은 사용자에게 학습 비용을 지우기 때문이며, 많은 비공식 템플릿 문법은 개발 경험을 낮출 수 있습니다."},{"t":"h3","c":"확장 속성"},{"t":"p","c":"확장 속성을 통해 템플릿에서 :를 사용하여 설정할 수 있습니다. 아래에서는 red 속성을 확장하고 red가 true인 경우 폰트 색상이 빨간색으로 변경됩니다."},0,0,0,0,0,{"t":"p","c":"이 예에서는 템플릿 구문에 'red' 속성을 추가했습니다. 'count % 3'이 0이 아닐 때 글꼴 색상이 빨간색으로 변경됩니다."},{"t":"h3","c":"확장 방법"},{"t":"p","c":"확장 메서드 extend를 사용하여 템플릿 구문에서 사용할 수 있도록 할 수도 있습니다. 메서드 이름은 콜론 앞의 부분입니다. 여기에서는 color 템플릿 구문을 확장하고, 뒤에 오는 매개변수는 정의된 확장 메서드로 전달됩니다."},{"t":"p","c":"이곳에서 always 속성을 true로 설정했으며, 이는 컴포넌트가 화면을 새로 고칠 때마다이 정의 된 메소드를 호출함을 의미합니다. always를 설정하지 않으면이 템플릿 구문 함수는 한 번만 실행됩니다."},{"t":"p","c":"여기서 'options'은 더 많은 매개변수를 제공하여 보다 맞춤화된 템플릿 문법 개발을 도와줍니다."},0,0,0,0,0,{"t":"h2","c":"템플릿 구문의 원리"},{"t":"p","c":"지금까지 당신은 이미 이해할 수 있다는 것을 알 수 있어야 합니다. ofa.js의 많은 템플릿 문법은 실제로 extend를 통해 확장되었습니다."},{"t":"l","c":"- class、attr 메서드는 뷰를 새로 고칠 때마다 실행됩니다.\n- on、one과 같은 함수 바인딩은 한 번만 실행됩니다."},{"t":"p","c":"아래는 이해를 돕기 위해 볼 수 있는 ofa.js 템플릿 렌더링 원칙의 예시입니다."},0,0,0],"version":[{"t":"h1","c":"version"},{"t":"p","c":"ofa.version 속성을 통해 현재로서 가져온 ofa.js의 버전 번호를 얻을 수 있습니다."},0,0,0,0,0,{"t":"p","c":"이렇게 하면 페이지에서 현재 사용 중인 ofa.js 버전을 표시할 수 있습니다."}],"stanz":[{"t":"h1","c":"실례 데이터 특징"},{"t":"p","c":"$로 가져오거나 생성한 인스턴스 객체는 stanz의 데이터 특성을 완벽하게 가지고 있으며 $ 인스턴스는 stanz에서 상속됩니다. 이는 stanz가 제공하는 데이터 조작 방법과 특성을 활용하여 인스턴스 객체의 데이터를 조작하고 모니터링할 수 있다는 것을 의미합니다."},0,{"t":"h2","c":"watch"},{"t":"p","c":"사례는 watch 메서드를 통해 값의 변경을 감시 할 수 있습니다. 객체의 하위 객체의 값을 변경하더라도 객체의 watch 메서드에서 변경 사항을 감지 할 수 있습니다."},{"t":"p","c":"아래는 $ 인스턴스와 watch 메소드를 사용하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 먼저 $ 인스턴스 객체 target을 생성한 다음 watch 메소드를 사용하여 해당 객체의 변경 사항을 감시합니다. 예를 들어 target.bbb.child.val의 값을 변경하더라도 watch 메소드에서 이러한 변경 사항을 감시하고 logger 요소의 내용을 업데이트합니다. 이는 $ 인스턴스 객체의 강력한 기능을 보여주며 객체의 변경 사항을 쉽게 모니터링 할 수 있도록합니다."},{"t":"h2","c":"watchTick"},{"t":"p","c":"watchTick와 watch 메서드는 기능적으로 유사하지만, watchTick은 내부적으로 스로틀링 작업을 수행하여 단일 스레드에서 한번 실행되므로, 일부 성능 요구사항이 더 높은 경우 데이터 변경을 더 효과적으로 감시할 수 있습니다."},{"t":"p","c":"아래는 $ 인스턴스의 watchTick 메서드를 사용하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예제에서 우리는 먼저 $ 인스턴스 객체 target을 생성합니다. 그런 다음 watch 메서드와 watchTick 메서드를 사용하여 객체의 변경 사항을 모니터링합니다. watch 메서드는 데이터가 변경될 때 즉시 실행되고, watchTick 메서드는 단일 스레드에서 한 번 실행되므로 모니터링 작업의 빈도를 제한할 수 있습니다. 데이터의 변경 사항을 모니터링하기 위해 watch 또는 watchTick 메서드를 선택할 수 있습니다."},{"t":"h2","c":"unwatch"},{"t":"p","c":"unwatch 메서드는 데이터의 감시를 취소하는 데 사용됩니다. 이전에 등록된 watch 또는 watchTick 감시를 취소할 수 있습니다."},{"t":"p","c":"아래는 $ 인스턴스의 unwatch 메서드를 사용하는 방법을 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예시에서는 먼저 $ 인스턴스 오브젝트 target을 생성한 다음 watch 메소드와 watchTick 메소드를 사용하여 두 개의 리스너를 등록합니다. 그런 다음 unwatch 메소드를 사용하여 이전에 저장한 리스너 ID tid1과 tid2를 전달하여 이 두 개의 리스너를 해제합니다. 이는 첫 번째 setTimeout에서의 속성 변경이 리스너를 트리거하지 않음을 의미합니다. 왜냐하면 리스너가 해제되었기 때문입니다."},{"t":"h2","c":"감시되지 않는 값"},{"t":"p","c":"$ 인스턴스에서는 _로 시작하는 속성 이름은 watch 또는 watchTick 메서드에 의해 감시되지 않을 것임을 나타냅니다. 일부 임시 또는 개인 속성에 대한 이러한 속성은 감시를 트리거하지 않고 자유롭게 변경할 수 있습니다."},{"t":"p","c":"아래는 어떻게 밑줄로 시작하는 속성 값을 사용하여 감시되지 않는지 보여주는 예제입니다."},0,0,0,0,{"t":"p","c":"이 예제에서는 $ 인스턴스 객체 target을 만들고, watch 메소드를 사용하여 속성 값의 변경을 감시합니다. setTimeout 내에서 _aaa 속성 값을 변경하려고 시도하지만, 이 변경은 감시를 트리거하지 않습니다. 이는 감시를 트리거하지 않고 속성 값을 업데이트해야하는 경우에 매우 유용합니다."},{"t":"h2","c":"기본 기능"},{"t":"p","c":"인스턴스에 설정된 객체 데이터는 Stanz 인스턴스로 변환되며, 이러한 Stanz 인스턴스는 감지 할 수 있습니다."},0,{"t":"p","c":"우리는 $.stanz를 사용하여 인스턴스에 바인딩되지 않은 Stanz 데이터를 생성할 수도 있습니다."},0,{"t":"p","c":"이 예제는 객체 데이터를 Stanz 인스턴스로 설정하여 듣기 위한 기본적인 특징을 보여줍니다."},{"t":"p","c":"자세한 기능은 stanz을 참조하십시오."}]}}}